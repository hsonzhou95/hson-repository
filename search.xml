<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>10道高频JavaScript手写面试题及答案</title>
    <url>/2020/01/07/10%E9%81%93%E9%AB%98%E9%A2%91JavaScript%E6%89%8B%E5%86%99%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88/</url>
    <content><![CDATA[<h2 id="10道高频JavaScript手写面试题及答案"><a href="#10道高频JavaScript手写面试题及答案" class="headerlink" title="10道高频JavaScript手写面试题及答案"></a>10道高频JavaScript手写面试题及答案</h2><a id="more"></a>
<h3 id="JavaScript笔试部分"><a href="#JavaScript笔试部分" class="headerlink" title="JavaScript笔试部分"></a><strong>JavaScript笔试部分</strong></h3><h4 id="深拷贝（deepclone）"><a href="#深拷贝（deepclone）" class="headerlink" title="深拷贝（deepclone）"></a>深拷贝（deepclone）</h4><p>简单版：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> newObj = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(oldObj));</span><br></pre></td></tr></table></figure>

<p>局限性 ：</p>
<ul>
<li><p>1、他无法实现函数、RegExp等特殊对象的克隆</p>
</li>
<li><p>2、会抛弃对象的constructor，所有的构造函数会指向Object</p>
</li>
<li><p>3、对象有循环引用，会报错</p>
</li>
</ul>
<h4 id="实现Event-event-bus"><a href="#实现Event-event-bus" class="headerlink" title="实现Event (event bus)"></a><strong>实现Event (event bus)</strong></h4><blockquote>
<p>event bus既是node中各个模块的基石，又是前端组件通信的依赖手段之一，同时涉及了订阅-发布设计模式，是非常重要的基础。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EventEmeitter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>()&#123;</span><br><span class="line">        <span class="keyword">this</span>._events = <span class="keyword">this</span>._events || <span class="keyword">new</span> <span class="built_in">Map</span>(); <span class="comment">//储存事件/回调键值对</span></span><br><span class="line">        <span class="keyword">this</span>._maxListeners = <span class="keyword">this</span>._maxListeners || <span class="number">1</span>o;<span class="comment">//设立监听上限</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//触发名为type的事件</span></span><br><span class="line">EventEmeitter.prototype.emit = <span class="function"><span class="keyword">function</span>(<span class="params">type,...args</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> hander;</span><br><span class="line">    <span class="comment">//从储存事件键值对的this._events中获取对应事件回调函数</span></span><br><span class="line">    handler = <span class="keyword">this</span>._events.get(type);</span><br><span class="line">    <span class="keyword">if</span> (args.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        hander.apply(<span class="keyword">this</span>,args);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        handler.call(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//监听名为type事件</span></span><br><span class="line">EventEmeitter.prototype.addListener = <span class="function"><span class="keyword">function</span>(<span class="params">type,fn</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//将type事件以及对应的fn函数放入this._events中储存</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>._events.get(type)) &#123;</span><br><span class="line">        <span class="keyword">this</span>._events.set(type,fn);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="实现instanceOf"><a href="#实现instanceOf" class="headerlink" title="实现instanceOf"></a>实现instanceOf</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//模拟 instanceof</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">instance_of</span>(<span class="params">L,R</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> O = R.prototype;<span class="comment">//取 R 的显示原型</span></span><br><span class="line">    L = L.__proto__;<span class="comment">//取 L 的隐式原型</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (L === <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (O === L)</span><br><span class="line">        <span class="comment">// 这里重点 ：当 O 严格等于 L 时，返回 true</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        L = L.__proto__;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="模拟new"><a href="#模拟new" class="headerlink" title="模拟new"></a>模拟new</h4><h5 id="new操作符做了这些事："><a href="#new操作符做了这些事：" class="headerlink" title="new操作符做了这些事："></a>new操作符做了这些事：</h5><ul>
<li>他创建了一个全新的对象</li>
<li>他会被执行[[Prototype]] (也就是<strong>proto</strong>) 链接</li>
<li>它使this指向新创建的对象</li>
<li>通过new创建的每个对象将最终被[[Prototype]]链接到这个函数的prototype对象上</li>
<li>如果函数没有返回对象类型Object(包含Function，Array，Date，RegExg，Error)，那么new表达式中的函数调用将返回对象引用</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// objectFactory(name,'cxk','18')</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">objectFactory</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> obj = <span class="keyword">new</span> object();</span><br><span class="line">    <span class="keyword">const</span> Constructor = [].shift.call(<span class="built_in">arguments</span>);</span><br><span class="line"></span><br><span class="line">    obj.__proto__ = Constructor.prototype;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> ret = Constructor.apply(obj,<span class="built_in">arguments</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">typeof</span> ret === <span class="string">"object"</span> ? ret : obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="实现一个call"><a href="#实现一个call" class="headerlink" title="实现一个call"></a>实现一个call</h4><h5 id="call做了什么："><a href="#call做了什么：" class="headerlink" title="call做了什么："></a>call做了什么：</h5><ul>
<li>将函数设为对象的属性</li>
<li>执行&amp;删除这个函数</li>
<li>指定this到函数并传人给定参数执行函数</li>
<li>如果不传人参数，默认指向为 window</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//模拟 call bar.mycall(null);</span></span><br><span class="line"><span class="comment">//实现一个call方法；</span></span><br><span class="line"><span class="built_in">Function</span>.prototype.myCall = <span class="function"><span class="keyword">function</span>(<span class="params">context</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//此处没有考虑context非object情况</span></span><br><span class="line">    context.fn = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">let</span> args = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>,len = <span class="built_in">arguments</span>.length,i &lt; len; i++)&#123;</span><br><span class="line">        args.push(<span class="built_in">arguments</span>[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    context.fn(...args);</span><br><span class="line">    <span class="keyword">let</span> result = context.fn(...args);</span><br><span class="line">    <span class="keyword">delete</span> context.fn;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="实现apply方法"><a href="#实现apply方法" class="headerlink" title="实现apply方法"></a>实现apply方法</h4><h5 id="apply原理与call很相似"><a href="#apply原理与call很相似" class="headerlink" title="apply原理与call很相似"></a>apply原理与call很相似</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//模拟 apply</span></span><br><span class="line"><span class="built_in">Function</span>.prototype.myapply = <span class="function"><span class="keyword">function</span>(<span class="params">context,arr</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> context = <span class="built_in">Object</span>(context) || <span class="built_in">window</span>;</span><br><span class="line">    context.fn = <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> result;</span><br><span class="line">    <span class="keyword">if</span> (!arr)&#123;</span><br><span class="line">        result = context.fn();</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> args = [];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>,len = arr.length;i &lt; len; i++)&#123;</span><br><span class="line">            args.push(<span class="string">"arr["</span>+ i +<span class="string">"]"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        result = <span class="built_in">eval</span>(<span class="string">"context.fn("</span>+ args + <span class="string">")"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span> context.fn;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="实现bind"><a href="#实现bind" class="headerlink" title="实现bind"></a>实现bind</h4><h5 id="实现bind要做什么"><a href="#实现bind要做什么" class="headerlink" title="实现bind要做什么"></a>实现bind要做什么</h5><ul>
<li>返回一个函数，绑定this，传递预置参数</li>
<li>bind返回的函数可以作为构造函数使用。故作为构造函数时应使得this失效，但是传人的参数依然有效</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// mdn的实现</span></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">Function</span>.prototype.bind) &#123;</span><br><span class="line">  <span class="built_in">Function</span>.prototype.bind = <span class="function"><span class="keyword">function</span>(<span class="params">oThis</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">this</span> !== <span class="string">'function'</span>) &#123;</span><br><span class="line">      <span class="comment">// closest thing possible to the ECMAScript 5</span></span><br><span class="line">      <span class="comment">// internal IsCallable function</span></span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'Function.prototype.bind - what is trying to be bound is not callable'</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> aArgs   = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>),</span><br><span class="line">        fToBind = <span class="keyword">this</span>,</span><br><span class="line">        fNOP    = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;,</span><br><span class="line">        fBound  = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">          <span class="comment">// this instanceof fBound === true时,说明返回的fBound被当做new的构造函数调用</span></span><br><span class="line">          <span class="keyword">return</span> fToBind.apply(<span class="keyword">this</span> <span class="keyword">instanceof</span> fBound</span><br><span class="line">                 ? <span class="keyword">this</span></span><br><span class="line">                 : oThis,</span><br><span class="line">                 <span class="comment">// 获取调用时(fBound)的传参.bind 返回的函数入参往往是这么传递的</span></span><br><span class="line">                 aArgs.concat(<span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>)));</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 维护原型关系</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.prototype) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 下行的代码使fBound.prototype是fNOP的实例,因此</span></span><br><span class="line">    <span class="comment">// 返回的fBound若作为new的构造函数,new生成的新对象作为this传入fBound,新对象的__proto__就是fNOP的实例</span></span><br><span class="line">    fBound.prototype = <span class="keyword">new</span> fNOP();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> fBound;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">详解请移步JavaScript深入之bind的模拟实现 #12</span><br><span class="line"></span><br><span class="line">模拟<span class="built_in">Object</span>.create</span><br><span class="line"><span class="built_in">Object</span>.create()方法创建一个新对象，使用现有的对象来提供新创建的对象的__proto__。</span><br><span class="line"><span class="comment">// 模拟 Object.create</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">create</span>(<span class="params">proto</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">  F.prototype = proto;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> F();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="模拟Object-create"><a href="#模拟Object-create" class="headerlink" title="模拟Object.create"></a><strong>模拟Object.create</strong></h4><h5 id="Object-create-方法创建一个新对象，使用现有的对象来提供新创建的对象的proto"><a href="#Object-create-方法创建一个新对象，使用现有的对象来提供新创建的对象的proto" class="headerlink" title="Object.create()方法创建一个新对象，使用现有的对象来提供新创建的对象的proto."></a>Object.create()方法创建一个新对象，使用现有的对象来提供新创建的对象的<strong><em>proto</em></strong>.</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 模拟 Object.create</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">create</span>(<span class="params">proto</span>)</span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		F.prototype=protp;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> F()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="解析-URL-Params为对象"><a href="#解析-URL-Params为对象" class="headerlink" title="解析 URL Params为对象"></a><strong>解析 URL Params为对象</strong></h4> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let url = &apos;http://www.domain.com/?user=anonymous&amp;id=123&amp;id=456&amp;city=%E5%8C%97%E4%BA%AC&amp;enabled&apos;;</span><br><span class="line">parseParam(url)</span><br><span class="line"></span><br><span class="line">/* 结果</span><br><span class="line">&#123; user: &apos;anonymous&apos;,</span><br><span class="line">  id: [ 123, 456 ], // 重复出现的 key 要组装成数组，能被转成数字的就转成数字类型</span><br><span class="line">  city: &apos;北京&apos;, // 中文需解码</span><br><span class="line">  enabled: true, // 未指定值得 key 约定为 true</span><br><span class="line">&#125;</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>

<h4 id="转化为驼峰，命名"><a href="#转化为驼峰，命名" class="headerlink" title="转化为驼峰，命名"></a>转化为驼峰，命名</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s1= <span class="string">"get-element-by-id"</span></span><br><span class="line"><span class="comment">//转化为 getElementById</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> f = <span class="function"><span class="keyword">function</span>(<span class="params">s</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> s.replace(<span class="regexp">/-\w/g</span>,<span class="function"><span class="keyword">function</span>(<span class="params">x</span>)</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> x.slice(<span class="number">1</span>).toUpperCase();</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="源自：https-juejin-im-post-5e100cdef265da5d75243229"><a href="#源自：https-juejin-im-post-5e100cdef265da5d75243229" class="headerlink" title="源自：https://juejin.im/post/5e100cdef265da5d75243229"></a>源自：<a href="https://juejin.im/post/5e100cdef265da5d75243229" target="_blank" rel="noopener">https://juejin.im/post/5e100cdef265da5d75243229</a></h4><h4 id="声明：文章著作权归作者所有，如有侵权，请联系删除。"><a href="#声明：文章著作权归作者所有，如有侵权，请联系删除。" class="headerlink" title="声明：文章著作权归作者所有，如有侵权，请联系删除。"></a>声明：文章著作权归作者所有，如有侵权，请联系删除。</h4>]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JS面试常客，防抖与节流</title>
    <url>/2020/01/07/JS%E9%9D%A2%E8%AF%95%E5%B8%B8%E5%AE%A2%EF%BC%8C%E9%98%B2%E6%8A%96%E4%B8%8E%E8%8A%82%E6%B5%81/</url>
    <content><![CDATA[<a id="more"></a>
<h2 id="Js中防抖与节流的应用场景，以及在Vue中如何实现防抖与节流"><a href="#Js中防抖与节流的应用场景，以及在Vue中如何实现防抖与节流" class="headerlink" title="Js中防抖与节流的应用场景，以及在Vue中如何实现防抖与节流"></a>Js中防抖与节流的应用场景，以及在Vue中如何实现防抖与节流</h2><h3 id="为什么会用到防抖与节流"><a href="#为什么会用到防抖与节流" class="headerlink" title="为什么会用到防抖与节流"></a>为什么会用到防抖与节流</h3><blockquote>
<p>在项目中常常会使用到提交按钮和搜索框的功能，但在使用过程中，如果一直点击提交按钮或者搜索输入的内容进行发起请求，那么这样做会大大的影响性能的问题，为考虑到性能方面的优化问题，所以就会用到防抖与节流。</p>
</blockquote>
<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><h4 id="防抖函数（debounce）："><a href="#防抖函数（debounce）：" class="headerlink" title="防抖函数（debounce）："></a>防抖函数（debounce）：</h4><blockquote>
<p> 在滚动事件中需要做个复杂计算或者实现一个按钮的防二次点击操作 。</p>
</blockquote>
<h4 id="节流函数（throttle）："><a href="#节流函数（throttle）：" class="headerlink" title="节流函数（throttle）："></a>节流函数（throttle）：</h4><blockquote>
<p>规定在某一个单位内，只触发一次函数，如果这个单位时间内触发多次函数，只有一次生效；典型的按理就是鼠标不断点击触发，规定在n秒内多次点击只有一次生效。</p>
</blockquote>
<p><strong>注意：在setTimeout中的this会失效，在setTimeout当中this的指向是window，解决办法是在setTimeout函数外面定义一个that=this就可以了</strong></p>
<h4 id="在Vue中的实际代码："><a href="#在Vue中的实际代码：" class="headerlink" title="在Vue中的实际代码："></a>在Vue中的实际代码：</h4><h5 id="1、输入框，输入最后一个字2-5秒后执行（防抖：debounce）"><a href="#1、输入框，输入最后一个字2-5秒后执行（防抖：debounce）" class="headerlink" title="1、输入框，输入最后一个字2.5秒后执行（防抖：debounce）"></a>1、输入框，输入最后一个字2.5秒后执行（防抖：debounce）</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;el-input v-modle=&quot;msg&quot; @keyup=&quot;debounce&quot;&gt;&lt;/el-input&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"></span><br><span class="line">    let timer;//注意不要将thimer定义在debounce内部，将他放在全局</span><br><span class="line">    export default &#123;</span><br><span class="line">        name: &quot;deoucn&quot;,</span><br><span class="line">        data()&#123;</span><br><span class="line">            return&#123;</span><br><span class="line">                msg:&apos;&apos;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        methods:&#123;</span><br><span class="line">            debounce()&#123;</span><br><span class="line">                let that = this;</span><br><span class="line">                if(timer)&#123;</span><br><span class="line">                    clearTimeout(timer)</span><br><span class="line">                &#125;</span><br><span class="line">                timer = setTimeout(function()&#123;</span><br><span class="line">                    console.log(&apos;输入内容&apos;);</span><br><span class="line">                &#125;,2500)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line"></span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>

<h5 id="2、在2-5秒内点击多次，只有一次生效（节流，throttle）"><a href="#2、在2-5秒内点击多次，只有一次生效（节流，throttle）" class="headerlink" title="2、在2.5秒内点击多次，只有一次生效（节流，throttle）"></a>2、在2.5秒内点击多次，只有一次生效（节流，throttle）</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;el-button @click=&quot;throlle&quot;&gt;保存&lt;/el-button&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"></span><br><span class="line">    let lastTime;//注意不要将thimer定义在debounce内部，将他放在全局</span><br><span class="line">    export default &#123;</span><br><span class="line">        name: &quot;deoucn&quot;,</span><br><span class="line">        data()&#123;</span><br><span class="line"></span><br><span class="line">        &#125;,</span><br><span class="line">        methods:&#123;</span><br><span class="line">            throlle()&#123;</span><br><span class="line">                let that = this;</span><br><span class="line">                let time = +new Date();</span><br><span class="line">                if (lastTime &amp;&amp; lastTime - time &lt; 2500)&#123;</span><br><span class="line">                    clearTimeout(lastTime)</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                lastTime = setTimeout(function()&#123;</span><br><span class="line">                    console.log(&apos;使劲点&apos;);</span><br><span class="line">                    lastTime = +new Date();</span><br><span class="line">                &#125;,100)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line"></span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>好了，到这里一个简单的防抖函数和节流函数就完成了，是不是看上去超级简单！！！</p>
</blockquote>
<h2 id="参考文献：-https-www-cnblogs-com-yalong-p-10556665-html"><a href="#参考文献：-https-www-cnblogs-com-yalong-p-10556665-html" class="headerlink" title="参考文献： https://www.cnblogs.com/yalong/p/10556665.html"></a>参考文献： <a href="https://www.cnblogs.com/yalong/p/10556665.html" target="_blank" rel="noopener">https://www.cnblogs.com/yalong/p/10556665.html</a></h2>]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>防抖</tag>
        <tag>节流</tag>
      </tags>
  </entry>
  <entry>
    <title>React知识点查漏补缺</title>
    <url>/2020/01/04/React%E7%9F%A5%E8%AF%86%E7%82%B9%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA/</url>
    <content><![CDATA[<h2 id="React知识点查漏补缺"><a href="#React知识点查漏补缺" class="headerlink" title="React知识点查漏补缺"></a>React知识点查漏补缺</h2><h4 id="问题1：什么是虚拟DOM？"><a href="#问题1：什么是虚拟DOM？" class="headerlink" title="问题1：什么是虚拟DOM？"></a>问题1：什么是虚拟DOM？</h4><blockquote>
<p>难度: ⭐</p>
</blockquote>
<h5 id="虚拟-DOM-VDOM-是真实-DOM-在内存中的表示。UI-的表示形式保存在内存中，并与实际的-DOM-同步。这是一个发生在渲染函数被调用和元素在屏幕上显示之间的步骤，整个过程被称为调和。"><a href="#虚拟-DOM-VDOM-是真实-DOM-在内存中的表示。UI-的表示形式保存在内存中，并与实际的-DOM-同步。这是一个发生在渲染函数被调用和元素在屏幕上显示之间的步骤，整个过程被称为调和。" class="headerlink" title="虚拟 DOM (VDOM)是真实 DOM 在内存中的表示。UI 的表示形式保存在内存中，并与实际的 DOM 同步。这是一个发生在渲染函数被调用和元素在屏幕上显示之间的步骤，整个过程被称为调和。"></a><strong>虚拟 DOM (VDOM)</strong>是真实 DOM 在内存中的表示。UI 的表示形式保存在内存中，并与实际的 DOM 同步。这是一个发生在渲染函数被调用和元素在屏幕上显示之间的步骤，整个过程被称为<strong>调和</strong>。</h5><h4 id="问题2：类组件和函数组件之间的区别是啥"><a href="#问题2：类组件和函数组件之间的区别是啥" class="headerlink" title="问题2：类组件和函数组件之间的区别是啥?"></a>问题2：类组件和函数组件之间的区别是啥?</h4><blockquote>
<p>难度: ⭐⭐</p>
</blockquote>
<ul>
<li>类组件可以使用其他特性，如状态state和生命周期钩子。</li>
<li>当组件只是接收props渲染到页面时，就是无状态组件，就属于函数组件，也被称为哑组件或展示组件。</li>
</ul>
<h5 id="函数组件和类组件当然是有区别的，而且函数组件的性能比类组件的性能要高，因为类组件使用的时候要实例化，而函数组件直接执行函数取返回结果即可，为了提高性能，尽量使用函数组件。"><a href="#函数组件和类组件当然是有区别的，而且函数组件的性能比类组件的性能要高，因为类组件使用的时候要实例化，而函数组件直接执行函数取返回结果即可，为了提高性能，尽量使用函数组件。" class="headerlink" title="函数组件和类组件当然是有区别的，而且函数组件的性能比类组件的性能要高，因为类组件使用的时候要实例化，而函数组件直接执行函数取返回结果即可，为了提高性能，尽量使用函数组件。"></a>函数组件和类组件当然是有区别的，而且函数组件的性能比类组件的性能要高，因为类组件使用的时候要实例化，而函数组件直接执行函数取返回结果即可，为了提高性能，尽量使用函数组件。</h5><table>
<thead>
<tr>
<th>区别</th>
<th>函数组件</th>
<th>类组件</th>
</tr>
</thead>
<tbody><tr>
<td>是否有this</td>
<td>没有</td>
<td>有</td>
</tr>
<tr>
<td>是否有生命周期</td>
<td>没有</td>
<td>有</td>
</tr>
<tr>
<td>是否有状态state</td>
<td>没有</td>
<td>有</td>
</tr>
</tbody></table>
<h4 id="问题3-React中refs干嘛用的？"><a href="#问题3-React中refs干嘛用的？" class="headerlink" title="问题3 React中refs干嘛用的？"></a>问题3 React中refs干嘛用的？</h4><blockquote>
<p>难度: ⭐⭐</p>
</blockquote>
<h5 id="Refs-提供了一种访问在render方法中创建的-DOM-节点或者-React-元素的方法。在典型的数据流中，props-是父子组件交互的唯一方式，想要修改子组件，需要使用新的pros重新渲染它。凡事有例外，某些情况下咱们需要在典型数据流外，强制修改子代，这个时候可以使用-Refs。"><a href="#Refs-提供了一种访问在render方法中创建的-DOM-节点或者-React-元素的方法。在典型的数据流中，props-是父子组件交互的唯一方式，想要修改子组件，需要使用新的pros重新渲染它。凡事有例外，某些情况下咱们需要在典型数据流外，强制修改子代，这个时候可以使用-Refs。" class="headerlink" title="Refs 提供了一种访问在render方法中创建的 DOM 节点或者 React 元素的方法。在典型的数据流中，props 是父子组件交互的唯一方式，想要修改子组件，需要使用新的pros重新渲染它。凡事有例外，某些情况下咱们需要在典型数据流外，强制修改子代，这个时候可以使用 Refs。"></a><code>Refs</code> 提供了一种访问在<code>render</code>方法中创建的 DOM 节点或者 React 元素的方法。在典型的数据流中，<code>props</code> 是父子组件交互的唯一方式，想要修改子组件，需要使用新的<code>pros</code>重新渲染它。凡事有例外，某些情况下咱们需要在典型数据流外，强制修改子代，这个时候可以使用 <code>Refs</code>。</h5><h5 id="咱们可以在组件添加一个-ref-属性来使用，该属性的值是一个回调函数，接收作为其第一个参数的底层-DOM-元素或组件的挂载实例。"><a href="#咱们可以在组件添加一个-ref-属性来使用，该属性的值是一个回调函数，接收作为其第一个参数的底层-DOM-元素或组件的挂载实例。" class="headerlink" title="咱们可以在组件添加一个 ref 属性来使用，该属性的值是一个回调函数，接收作为其第一个参数的底层 DOM 元素或组件的挂载实例。"></a>咱们可以在组件添加一个 <code>ref</code> 属性来使用，该属性的值是一个回调函数，接收作为其第一个参数的底层 DOM 元素或组件的挂载实例。</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class UnControlledForm extends Component &#123;</span><br><span class="line">  handleSubmit = () =&gt; &#123;</span><br><span class="line">    console.log(&quot;Input Value: &quot;, this.input.value)</span><br><span class="line">  &#125;</span><br><span class="line">  render () &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;form onSubmit=&#123;this.handleSubmit&#125;&gt;</span><br><span class="line">        &lt;input</span><br><span class="line">          type=&apos;text&apos;</span><br><span class="line">          ref=&#123;(input) =&gt; this.input = input&#125; /&gt;</span><br><span class="line">        &lt;button type=&apos;submit&apos;&gt;Submit&lt;/button&gt;</span><br><span class="line">      &lt;/form&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="请注意，input-元素有一个ref属性，它的值是一个函数。该函数接收输入的实际-DOM-元素，然后将其放在实例上，这样就可以在-handleSubmit-函数内部访问它。"><a href="#请注意，input-元素有一个ref属性，它的值是一个函数。该函数接收输入的实际-DOM-元素，然后将其放在实例上，这样就可以在-handleSubmit-函数内部访问它。" class="headerlink" title="请注意，input 元素有一个ref属性，它的值是一个函数。该函数接收输入的实际 DOM 元素，然后将其放在实例上，这样就可以在 handleSubmit 函数内部访问它。"></a>请注意，<code>input</code> 元素有一个<code>ref</code>属性，它的值是一个函数。该函数接收输入的实际 DOM 元素，然后将其放在实例上，这样就可以在 <code>handleSubmit</code> 函数内部访问它。</h5><h5 id="经常被误解的只有在类组件中才能使用-refs，但是refs也可以通过利用-JS-中的闭包与函数组件一起使用。"><a href="#经常被误解的只有在类组件中才能使用-refs，但是refs也可以通过利用-JS-中的闭包与函数组件一起使用。" class="headerlink" title="经常被误解的只有在类组件中才能使用 refs，但是refs也可以通过利用 JS 中的闭包与函数组件一起使用。"></a>经常被误解的只有在类组件中才能使用 <code>refs</code>，但是<code>refs</code>也可以通过利用 JS 中的闭包与函数组件一起使用。</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function CustomForm (&#123;handleSubmit&#125;) &#123;</span><br><span class="line">  let inputElement</span><br><span class="line">  return (</span><br><span class="line">    &lt;form onSubmit=&#123;() =&gt; handleSubmit(inputElement.value)&#125;&gt;</span><br><span class="line">      &lt;input</span><br><span class="line">        type=&apos;text&apos;</span><br><span class="line">        ref=&#123;(input) =&gt; inputElement = input&#125; /&gt;</span><br><span class="line">      &lt;button type=&apos;submit&apos;&gt;Submit&lt;/button&gt;</span><br><span class="line">    &lt;/form&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="问题4-在React中如何处理事件"><a href="#问题4-在React中如何处理事件" class="headerlink" title="问题4 在React中如何处理事件"></a>问题4 在React中如何处理事件</h4><blockquote>
<p>难度: ⭐⭐</p>
</blockquote>
<h5 id="为了解决跨浏览器的兼容性问题，SyntheticEvent-实例将被传递给你的事件处理函数，SyntheticEvent是-React-跨浏览器的浏览器原生事件包装器，它还拥有和浏览器原生事件相同的接口，包括-stopPropagation-和-preventDefault-。"><a href="#为了解决跨浏览器的兼容性问题，SyntheticEvent-实例将被传递给你的事件处理函数，SyntheticEvent是-React-跨浏览器的浏览器原生事件包装器，它还拥有和浏览器原生事件相同的接口，包括-stopPropagation-和-preventDefault-。" class="headerlink" title="为了解决跨浏览器的兼容性问题，SyntheticEvent 实例将被传递给你的事件处理函数，SyntheticEvent是 React 跨浏览器的浏览器原生事件包装器，它还拥有和浏览器原生事件相同的接口，包括 stopPropagation() 和 preventDefault()。"></a>为了解决跨浏览器的兼容性问题，<code>SyntheticEvent</code> 实例将被传递给你的事件处理函数，<code>SyntheticEvent</code>是 React 跨浏览器的浏览器原生事件包装器，它还拥有和浏览器原生事件相同的接口，包括 <code>stopPropagation()</code> 和 <code>preventDefault()</code>。</h5><h5 id="比较有趣的是，React-实际上并不将事件附加到子节点本身。React-使用单个事件侦听器侦听顶层的所有事件。这对性能有好处，也意味着-React-在更新-DOM-时不需要跟踪事件监听器。"><a href="#比较有趣的是，React-实际上并不将事件附加到子节点本身。React-使用单个事件侦听器侦听顶层的所有事件。这对性能有好处，也意味着-React-在更新-DOM-时不需要跟踪事件监听器。" class="headerlink" title="比较有趣的是，React 实际上并不将事件附加到子节点本身。React 使用单个事件侦听器侦听顶层的所有事件。这对性能有好处，也意味着 React 在更新 DOM 时不需要跟踪事件监听器。"></a>比较有趣的是，React 实际上并不将事件附加到子节点本身。React 使用单个事件侦听器侦听顶层的所有事件。这对性能有好处，也意味着 React 在更新 DOM 时不需要跟踪事件监听器。</h5><h4 id="问题5-state和props区别是啥"><a href="#问题5-state和props区别是啥" class="headerlink" title="问题5 state和props区别是啥?"></a>问题5 state和props区别是啥?</h4><blockquote>
<p>难度: ⭐⭐</p>
</blockquote>
<h5 id="props和state是普通的-JS-对象。虽然它们都包含影响渲染输出的信息，但是它们在组件方面的功能是不同的。即"><a href="#props和state是普通的-JS-对象。虽然它们都包含影响渲染输出的信息，但是它们在组件方面的功能是不同的。即" class="headerlink" title="props和state是普通的 JS 对象。虽然它们都包含影响渲染输出的信息，但是它们在组件方面的功能是不同的。即"></a><code>props</code>和<code>state</code>是普通的 JS 对象。虽然它们都包含影响渲染输出的信息，但是它们在组件方面的功能是不同的。即</h5><ul>
<li><code>state</code> 是组件自己管理数据，控制自己的状态，可变；</li>
<li><code>props</code> 是外部传入的数据参数，不可变；</li>
<li>没有<code>state</code>的叫做无状态组件，有<code>state</code>的叫做有状态组件；</li>
<li>多用 <code>props</code>，少用 <code>state</code>，也就是多写无状态组件。</li>
</ul>
<h4 id="问题5-如何创建refs"><a href="#问题5-如何创建refs" class="headerlink" title="问题5 如何创建refs"></a>问题5 如何创建refs</h4><blockquote>
<p>难度: ⭐⭐</p>
</blockquote>
<h5 id="Refs-是使用-React-createRef-创建的，并通过-ref-属性附加到-React-元素。在构造组件时，通常将-Refs-分配给实例属性，以便可以在整个组件中引用它们。"><a href="#Refs-是使用-React-createRef-创建的，并通过-ref-属性附加到-React-元素。在构造组件时，通常将-Refs-分配给实例属性，以便可以在整个组件中引用它们。" class="headerlink" title="Refs 是使用 React.createRef() 创建的，并通过 ref 属性附加到 React 元素。在构造组件时，通常将 Refs 分配给实例属性，以便可以在整个组件中引用它们。"></a>Refs 是使用 <code>React.createRef()</code> 创建的，并通过 <code>ref</code> 属性附加到 React 元素。在构造组件时，通常将 <code>Refs</code> 分配给实例属性，以便可以在整个组件中引用它们。</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class MyComponent extends React.Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.myRef = React.createRef();</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return &lt;p ref=&#123;this.myRef&#125; /&gt;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或者这样用：</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class UserForm extends Component &#123;</span><br><span class="line">  handleSubmit = () =&gt; &#123;</span><br><span class="line">    console.log(&quot;Input Value is: &quot;, this.input.value)</span><br><span class="line">  &#125;</span><br><span class="line">  render () &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;form onSubmit=&#123;this.handleSubmit&#125;&gt;</span><br><span class="line">        &lt;input</span><br><span class="line">          type=&apos;text&apos;</span><br><span class="line">          ref=&#123;(input) =&gt; this.input = input&#125; /&gt; // Access DOM input in handle submit</span><br><span class="line">        &lt;button type=&apos;submit&apos;&gt;Submit&lt;/button&gt;</span><br><span class="line">      &lt;/form&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="问题7-什么是高阶组件"><a href="#问题7-什么是高阶组件" class="headerlink" title="问题7 什么是高阶组件"></a>问题7 什么是高阶组件</h4><blockquote>
<p>难度: ⭐⭐</p>
</blockquote>
<p><strong>高阶组件(HOC)</strong>是接受一个组件并返回一个新组件的函数。基本上，这是一个模式，是从 React 的组合特性中衍生出来的，称其为<strong>纯组件</strong>，因为它们可以接受任何动态提供的子组件，但不会修改或复制输入组件中的任何行为。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const EnhancedComponent = higherOrderComponent(WrappedComponent);</span><br></pre></td></tr></table></figure>

<p>HOC 可以用于以下许多用例</p>
<ul>
<li>代码重用、逻辑和引导抽象</li>
<li>渲染劫持</li>
<li>state 抽象和操作</li>
<li>props 处理</li>
</ul>
<h4 id="问题-8：在构造函数调用-super-并将-props-作为参数传入的作用是啥？"><a href="#问题-8：在构造函数调用-super-并将-props-作为参数传入的作用是啥？" class="headerlink" title="问题 8：在构造函数调用 super 并将 props 作为参数传入的作用是啥？"></a>问题 8：在构造函数调用 <code>super</code> 并将 <code>props</code> 作为参数传入的作用是啥？</h4><blockquote>
<p>难度: ⭐⭐</p>
</blockquote>
<h5 id="在调用-super-方法之前，子类构造函数无法使用this引用，ES6-子类也是如此。将-props-参数传递给-super-调用的主要原因是在子构造函数中能够通过this-props来获取传入的-props。"><a href="#在调用-super-方法之前，子类构造函数无法使用this引用，ES6-子类也是如此。将-props-参数传递给-super-调用的主要原因是在子构造函数中能够通过this-props来获取传入的-props。" class="headerlink" title="在调用 super() 方法之前，子类构造函数无法使用this引用，ES6 子类也是如此。将 props 参数传递给 super() 调用的主要原因是在子构造函数中能够通过this.props来获取传入的 props。"></a>在调用 <code>super()</code> 方法之前，子类构造函数无法使用<code>this</code>引用，ES6 子类也是如此。将 <code>props</code> 参数传递给 <code>super()</code> 调用的主要原因是在子构造函数中能够通过<code>this.props</code>来获取传入的 <code>props</code>。</h5><h5 id="传递props"><a href="#传递props" class="headerlink" title="传递props"></a>传递props</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class MyComponent extends React.Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    console.log(this.props);  // &#123; name: &apos;sudheer&apos;,age: 30 &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="没传递-props"><a href="#没传递-props" class="headerlink" title="没传递 props"></a><strong>没传递 props</strong></h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">class MyComponent extends React.Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super();</span><br><span class="line">    console.log(this.props); // undefined</span><br><span class="line">    // 但是 Props 参数仍然可用</span><br><span class="line">    console.log(props); // Prints &#123; name: &apos;sudheer&apos;,age: 30 &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    // 构造函数外部不受影响</span><br><span class="line">    console.log(this.props) // &#123; name: &apos;sudheer&apos;,age: 30 &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="上面示例揭示了一点。props-的行为只有在构造函数中是不同的，在构造函数之外也是一样的。"><a href="#上面示例揭示了一点。props-的行为只有在构造函数中是不同的，在构造函数之外也是一样的。" class="headerlink" title="上面示例揭示了一点。props 的行为只有在构造函数中是不同的，在构造函数之外也是一样的。"></a>上面示例揭示了一点。<code>props</code> 的行为只有在构造函数中是不同的，在构造函数之外也是一样的。</h6><h4 id="问题-9：什么是控制组件？"><a href="#问题-9：什么是控制组件？" class="headerlink" title="问题 9：什么是控制组件？"></a>问题 9：什么是控制组件？</h4><blockquote>
<p>难度: ⭐⭐⭐</p>
</blockquote>
<h5 id="在-HTML-中，表单元素如-、和-通常维护自己的状态，并根据用户输入进行更新。当用户提交表单时，来自上述元素的值将随表单一起发送。"><a href="#在-HTML-中，表单元素如-、和-通常维护自己的状态，并根据用户输入进行更新。当用户提交表单时，来自上述元素的值将随表单一起发送。" class="headerlink" title="在 HTML 中，表单元素如 、和``通常维护自己的状态，并根据用户输入进行更新。当用户提交表单时，来自上述元素的值将随表单一起发送。"></a>在 HTML 中，表单元素如 <code>、</code>和``通常维护自己的状态，并根据用户输入进行更新。当用户提交表单时，来自上述元素的值将随表单一起发送。</h5><h5 id="而-React-的工作方式则不同。包含表单的组件将跟踪其状态中的输入值，并在每次回调函数-例如onChange-触发时重新渲染组件，因为状态被更新。以这种方式由-React-控制其值的输入表单元素称为受控组件。"><a href="#而-React-的工作方式则不同。包含表单的组件将跟踪其状态中的输入值，并在每次回调函数-例如onChange-触发时重新渲染组件，因为状态被更新。以这种方式由-React-控制其值的输入表单元素称为受控组件。" class="headerlink" title="而 React 的工作方式则不同。包含表单的组件将跟踪其状态中的输入值，并在每次回调函数(例如onChange)触发时重新渲染组件，因为状态被更新。以这种方式由 React 控制其值的输入表单元素称为受控组件。"></a>而 React 的工作方式则不同。包含表单的组件将跟踪其状态中的输入值，并在每次回调函数(例如<code>onChange</code>)触发时重新渲染组件，因为状态被更新。以这种方式由 React 控制其值的输入表单元素称为<strong>受控组件</strong>。</h5><h4 id="问题-10：如何-React-createElement-？"><a href="#问题-10：如何-React-createElement-？" class="headerlink" title="问题 10：如何 React.createElement ？"></a>问题 10：如何 React.createElement ？</h4><blockquote>
<p>难度: ⭐⭐⭐</p>
</blockquote>
<h5 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const element = (</span><br><span class="line">  &lt;h1 className=&quot;greeting&quot;&gt;</span><br><span class="line">    Hello, world!</span><br><span class="line">  &lt;/h1&gt;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h5 id="上述代码如何使用-React-createElement-来实现"><a href="#上述代码如何使用-React-createElement-来实现" class="headerlink" title="上述代码如何使用 React.createElement 来实现:"></a>上述代码如何使用 <code>React.createElement</code> 来实现:</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const element = React.createElement(</span><br><span class="line">  &apos;h1&apos;,</span><br><span class="line">  &#123;className: &apos;greeting&apos;&#125;,</span><br><span class="line">  &apos;Hello, world!&apos;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h4 id="问题-11：讲讲什么是-JSX-？"><a href="#问题-11：讲讲什么是-JSX-？" class="headerlink" title="问题 11：讲讲什么是 JSX ？"></a>问题 11：讲讲什么是 JSX ？</h4><blockquote>
<p>难度: ⭐⭐⭐</p>
</blockquote>
<h5 id="当-Facebook-第一次发布-React-时，他们还引入了一种新的-JS-方言-JSX，将原始-HTML-模板嵌入到-JS-代码中。JSX-代码本身不能被浏览器读取，必须使用Babel和webpack等工具将其转换为传统的JS。很多开发人员就能无意识使用-JSX，因为它已经与-React-结合在一直了。"><a href="#当-Facebook-第一次发布-React-时，他们还引入了一种新的-JS-方言-JSX，将原始-HTML-模板嵌入到-JS-代码中。JSX-代码本身不能被浏览器读取，必须使用Babel和webpack等工具将其转换为传统的JS。很多开发人员就能无意识使用-JSX，因为它已经与-React-结合在一直了。" class="headerlink" title="当 Facebook 第一次发布 React 时，他们还引入了一种新的 JS 方言 JSX，将原始 HTML 模板嵌入到 JS 代码中。JSX 代码本身不能被浏览器读取，必须使用Babel和webpack等工具将其转换为传统的JS。很多开发人员就能无意识使用 JSX，因为它已经与 React 结合在一直了。"></a>当 <strong>Facebook</strong> 第一次发布 React 时，他们还引入了一种新的 JS 方言 <code>JSX</code>，将原始 HTML 模板嵌入到 JS 代码中。JSX 代码本身不能被浏览器读取，必须使用<code>Babel</code>和<code>webpack</code>等工具将其转换为传统的JS。很多开发人员就能无意识使用 JSX，因为它已经与 React 结合在一直了。</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class MyComponent extends React.Component &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    let props = this.props;</span><br><span class="line">    return (</span><br><span class="line">      &lt;p className=&quot;my-component&quot;&gt;</span><br><span class="line">      &lt;a href=&#123;props.url&#125;&gt;&#123;props.name&#125;&lt;/a&gt;</span><br><span class="line">      &lt;/p&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="问题-13：为什么不直接更新-state-呢"><a href="#问题-13：为什么不直接更新-state-呢" class="headerlink" title="问题 13：为什么不直接更新 state 呢 ?"></a>问题 13：为什么不直接更新 <code>state</code> 呢 ?</h4><blockquote>
<p>难度: ⭐⭐⭐</p>
</blockquote>
<h5 id="如果试图直接更新-state-，则不会重新渲染组件。"><a href="#如果试图直接更新-state-，则不会重新渲染组件。" class="headerlink" title="如果试图直接更新 state ，则不会重新渲染组件。"></a>如果试图直接更新 <code>state</code> ，则不会重新渲染组件。</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 错误</span><br><span class="line"> This.state.message = &apos;Hello world&apos;;</span><br></pre></td></tr></table></figure>

<h5 id="需要使用setState-方法来更新-state。它调度对组件state对象的更新。当state改变时，组件通过重新渲染来响应："><a href="#需要使用setState-方法来更新-state。它调度对组件state对象的更新。当state改变时，组件通过重新渲染来响应：" class="headerlink" title="需要使用setState()方法来更新 state。它调度对组件state对象的更新。当state改变时，组件通过重新渲染来响应："></a>需要使用<code>setState()</code>方法来更新 <code>state</code>。它调度对组件<code>state</code>对象的更新。当<code>state</code>改变时，组件通过重新渲染来响应：</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 正确做法</span><br><span class="line">This.setState(&#123;message: ‘Hello World’&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="问题-14：React-组件生命周期有哪些不同阶段？"><a href="#问题-14：React-组件生命周期有哪些不同阶段？" class="headerlink" title="问题 14：React 组件生命周期有哪些不同阶段？"></a>问题 14：React 组件生命周期有哪些不同阶段？</h4><blockquote>
<p>难度: ⭐⭐⭐</p>
</blockquote>
<h6 id="在组件生命周期中有四个不同的阶段："><a href="#在组件生命周期中有四个不同的阶段：" class="headerlink" title="在组件生命周期中有四个不同的阶段："></a>在组件生命周期中有四个不同的阶段：</h6><ol>
<li><strong>Initialization</strong>：在这个阶段，组件准备设置初始化状态和默认属性。</li>
<li><strong>Mounting</strong>：react 组件已经准备好挂载到浏览器 DOM 中。这个阶段包括<code>componentWillMount</code>和<code>componentDidMount</code>生命周期方法。</li>
<li><strong>Updating</strong>：在这个阶段，组件以两种方式更新，发送新的 props 和 state 状态。此阶段包括<code>shouldComponentUpdate</code>、<code>componentWillUpdate</code>和<code>componentDidUpdate</code>生命周期方法。</li>
<li><strong>Unmounting</strong>：在这个阶段，组件已经不再被需要了，它从浏览器 DOM 中卸载下来。这个阶段包含 <code>componentWillUnmount</code> 生命周期方法。</li>
</ol>
<p>除以上四个常用生命周期外，还有一个错误处理的阶段：</p>
<p><strong>Error Handling</strong>：在这个阶段，不论在渲染的过程中，还是在生命周期方法中或是在任何子组件的构造函数中发生错误，该组件都会被调用。这个阶段包含了 <code>componentDidCatch</code> 生命周期方法。</p>
<h4 id="问题-15：React-的生命周期方法有哪些？"><a href="#问题-15：React-的生命周期方法有哪些？" class="headerlink" title="问题 15：React 的生命周期方法有哪些？"></a>问题 15：React 的生命周期方法有哪些？</h4><blockquote>
<p>难度: ⭐⭐⭐</p>
</blockquote>
<ul>
<li><code>componentWillMount</code>:在渲染之前执行，用于根组件中的 App 级配置。</li>
<li><code>componentDidMount</code>：在第一次渲染之后执行，可以在这里做AJAX请求，DOM 的操作或状态更新以及设置事件监听器。</li>
<li><code>componentWillReceiveProps</code>：在初始化<code>render</code>的时候不会执行，它会在组件接受到新的状态(Props)时被触发，一般用于父组件状态更新时子组件的重新渲染</li>
<li><code>shouldComponentUpdate</code>：确定是否更新组件。默认情况下，它返回<code>true</code>。如果确定在 <code>state</code> 或 <code>props</code> 更新后组件不需要在重新渲染，则可以返回<code>false</code>，这是一个提高性能的方法。</li>
<li><code>componentWillUpdate</code>：在<code>shouldComponentUpdate</code>返回 <code>true</code> 确定要更新组件之前执行。</li>
<li><code>componentDidUpdate</code>：它主要用于更新DOM以响应<code>props</code>或<code>state</code>更改。</li>
<li><code>componentWillUnmount</code>：它用于取消任何的网络请求，或删除与组件关联的所有事件监听器。</li>
</ul>
<h4 id="问题-16：这三个点-…-在-React-干嘛用的？"><a href="#问题-16：这三个点-…-在-React-干嘛用的？" class="headerlink" title="问题 16：这三个点(…)在 React 干嘛用的？"></a>问题 16：这三个点(…)在 React 干嘛用的？</h4><blockquote>
<p>难度: ⭐⭐⭐</p>
</blockquote>
<h5 id="在React（使用JSX）代码中做什么？它叫什么？"><a href="#在React（使用JSX）代码中做什么？它叫什么？" class="headerlink" title="... 在React（使用JSX）代码中做什么？它叫什么？"></a><code>...</code> 在React（使用JSX）代码中做什么？它叫什么？</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;Modal &#123;...this.props&#125; title=&apos;Modal heading&apos;  animation=&#123;false&#125;/&gt;</span><br></pre></td></tr></table></figure>

<h5 id="这个叫扩展操作符号或者展开操作符，例如，如果this-props包含a：1和b：2，则"><a href="#这个叫扩展操作符号或者展开操作符，例如，如果this-props包含a：1和b：2，则" class="headerlink" title="这个叫扩展操作符号或者展开操作符，例如，如果this.props包含a：1和b：2，则"></a>这个叫扩展操作符号或者展开操作符，例如，如果<code>this.props</code>包含<code>a：1</code>和<code>b：2</code>，则</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;Modal &#123;...this.props&#125; title=&apos;Modal heading&apos; animation=&#123;false&#125;&gt;</span><br></pre></td></tr></table></figure>

<h5 id="等价于下面内容："><a href="#等价于下面内容：" class="headerlink" title="等价于下面内容："></a>等价于下面内容：</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;Modal a=&#123;this.props.a&#125; b=&#123;this.props.b&#125; title=&apos;Modal heading&apos; animation=&#123;false&#125;&gt;</span><br></pre></td></tr></table></figure>

<h5 id="扩展符号不仅适用于该用例，而且对于创建具有现有对象的大多数（或全部）属性的新对象非常方便，在更新state-咱们就经常这么做："><a href="#扩展符号不仅适用于该用例，而且对于创建具有现有对象的大多数（或全部）属性的新对象非常方便，在更新state-咱们就经常这么做：" class="headerlink" title="扩展符号不仅适用于该用例，而且对于创建具有现有对象的大多数（或全部）属性的新对象非常方便，在更新state 咱们就经常这么做："></a>扩展符号不仅适用于该用例，而且对于创建具有现有对象的大多数（或全部）属性的新对象非常方便，在更新<code>state</code> 咱们就经常这么做：</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">this.setState(prevState =&gt; &#123;</span><br><span class="line">    return &#123;foo: &#123;...prevState.foo, a: &quot;updated&quot;&#125;&#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="问题-17：使用-React-Hooks-好处是啥？"><a href="#问题-17：使用-React-Hooks-好处是啥？" class="headerlink" title="问题 17：使用 React Hooks 好处是啥？"></a>问题 17：使用 React Hooks 好处是啥？</h4><blockquote>
<p>难度: ⭐⭐⭐</p>
</blockquote>
<h5 id="首先，Hooks-通常支持提取和重用跨多个组件通用的有状态逻辑，而无需承担高阶组件或渲染-props-的负担。Hooks-可以轻松地操作函数组件的状态，而不需要将它们转换为类组件。"><a href="#首先，Hooks-通常支持提取和重用跨多个组件通用的有状态逻辑，而无需承担高阶组件或渲染-props-的负担。Hooks-可以轻松地操作函数组件的状态，而不需要将它们转换为类组件。" class="headerlink" title="首先，Hooks 通常支持提取和重用跨多个组件通用的有状态逻辑，而无需承担高阶组件或渲染 props 的负担。Hooks 可以轻松地操作函数组件的状态，而不需要将它们转换为类组件。"></a>首先，Hooks 通常支持提取和重用跨多个组件通用的有状态逻辑，而无需承担高阶组件或渲染 <code>props</code> 的负担。<code>Hooks</code> 可以轻松地操作函数组件的状态，而不需要将它们转换为类组件。</h5><h5 id="Hooks-在类中不起作用，通过使用它们，咱们可以完全避免使用生命周期方法，例如-componentDidMount、componentDidUpdate、componentWillUnmount。相反，使用像useEffect这样的内置钩子。"><a href="#Hooks-在类中不起作用，通过使用它们，咱们可以完全避免使用生命周期方法，例如-componentDidMount、componentDidUpdate、componentWillUnmount。相反，使用像useEffect这样的内置钩子。" class="headerlink" title="Hooks 在类中不起作用，通过使用它们，咱们可以完全避免使用生命周期方法，例如 componentDidMount、componentDidUpdate、componentWillUnmount。相反，使用像useEffect这样的内置钩子。"></a>Hooks 在类中不起作用，通过使用它们，咱们可以完全避免使用生命周期方法，例如 <code>componentDidMount</code>、<code>componentDidUpdate</code>、<code>componentWillUnmount</code>。相反，使用像<code>useEffect</code>这样的内置钩子。</h5><h4 id="问题-18：什么是-React-Hooks？"><a href="#问题-18：什么是-React-Hooks？" class="headerlink" title="问题 18：什么是 React Hooks？"></a>问题 18：什么是 React Hooks？</h4><blockquote>
<p>难度: ⭐⭐⭐</p>
</blockquote>
<h5 id="Hooks是-React-16-8-中的新添加内容。它们允许在不编写类的情况下使用state和其他-React-特性。使用-Hooks，可以从组件中提取有状态逻辑，这样就可以独立地测试和重用它。Hooks-允许咱们在不改变组件层次结构的情况下重用有状态逻辑，这样在许多组件之间或与社区共享-Hooks-变得很容易。"><a href="#Hooks是-React-16-8-中的新添加内容。它们允许在不编写类的情况下使用state和其他-React-特性。使用-Hooks，可以从组件中提取有状态逻辑，这样就可以独立地测试和重用它。Hooks-允许咱们在不改变组件层次结构的情况下重用有状态逻辑，这样在许多组件之间或与社区共享-Hooks-变得很容易。" class="headerlink" title="Hooks是 React 16.8 中的新添加内容。它们允许在不编写类的情况下使用state和其他 React 特性。使用 Hooks，可以从组件中提取有状态逻辑，这样就可以独立地测试和重用它。Hooks 允许咱们在不改变组件层次结构的情况下重用有状态逻辑，这样在许多组件之间或与社区共享 Hooks 变得很容易。"></a><strong>Hooks</strong>是 React 16.8 中的新添加内容。它们允许在不编写类的情况下使用<code>state</code>和其他 React 特性。使用 Hooks，可以从组件中提取有状态逻辑，这样就可以独立地测试和重用它。Hooks 允许咱们在不改变组件层次结构的情况下重用有状态逻辑，这样在许多组件之间或与社区共享 Hooks 变得很容易。</h5><h4 id="问题-19：React-中的-useState-是什么？"><a href="#问题-19：React-中的-useState-是什么？" class="headerlink" title="问题 19：React 中的 useState() 是什么？"></a>问题 19：React 中的 <code>useState()</code> 是什么？</h4><blockquote>
<p>难度: ⭐⭐⭐</p>
</blockquote>
<h5 id="下面说明useState-0-的用途："><a href="#下面说明useState-0-的用途：" class="headerlink" title="下面说明useState(0)的用途："></a>下面说明<code>useState(0)</code>的用途：</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const [count, setCounter] = useState(0);</span><br><span class="line">const [moreStuff, setMoreStuff] = useState(...);</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">const setCount = () =&gt; &#123;</span><br><span class="line">    setCounter(count + 1);</span><br><span class="line">    setMoreStuff(...);</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="useState-是一个内置的-React-Hook。useState-0-返回一个元组，其中第一个参数count是计数器的当前状态，setCounter-提供更新计数器状态的方法。"><a href="#useState-是一个内置的-React-Hook。useState-0-返回一个元组，其中第一个参数count是计数器的当前状态，setCounter-提供更新计数器状态的方法。" class="headerlink" title="useState 是一个内置的 React Hook。useState(0) 返回一个元组，其中第一个参数count是计数器的当前状态，setCounter 提供更新计数器状态的方法。"></a><code>useState</code> 是一个内置的 React Hook。<code>useState(0)</code> 返回一个元组，其中第一个参数<code>count</code>是计数器的当前状态，<code>setCounter</code> 提供更新计数器状态的方法。</h5><h5 id="咱们可以在任何地方使用setCounter方法更新计数状态-在这种情况下，咱们在setCount函数内部使用它可以做更多的事情，使用-Hooks，能够使咱们的代码保持更多功能，还可以避免过多使用基于类的组件。"><a href="#咱们可以在任何地方使用setCounter方法更新计数状态-在这种情况下，咱们在setCount函数内部使用它可以做更多的事情，使用-Hooks，能够使咱们的代码保持更多功能，还可以避免过多使用基于类的组件。" class="headerlink" title="咱们可以在任何地方使用setCounter方法更新计数状态-在这种情况下，咱们在setCount函数内部使用它可以做更多的事情，使用 Hooks，能够使咱们的代码保持更多功能，还可以避免过多使用基于类的组件。"></a>咱们可以在任何地方使用<code>setCounter</code>方法更新计数状态-在这种情况下，咱们在<code>setCount</code>函数内部使用它可以做更多的事情，使用 Hooks，能够使咱们的代码保持更多功能，还可以避免过多使用基于类的组件。</h5><h4 id="问题-20：React-中的StrictMode-严格模式-是什么？？"><a href="#问题-20：React-中的StrictMode-严格模式-是什么？？" class="headerlink" title="问题 20：React 中的StrictMode(严格模式)是什么？？"></a>问题 20：React 中的StrictMode(严格模式)是什么？？</h4><blockquote>
<p>难度: ⭐⭐⭐</p>
</blockquote>
<p>React 的<code>StrictMode</code>是一种辅助组件，可以帮助咱们编写更好的 react 组件，可以使用``包装一组组件，并且可以帮咱们以下检查：</p>
<ul>
<li>验证内部组件是否遵循某些推荐做法，如果没有，会在控制台给出警告。</li>
<li>验证是否使用的已经废弃的方法，如果有，会在控制台给出警告。</li>
<li>通过识别潜在的风险预防一些副作用。</li>
</ul>
<h4 id="问题-21：为什么类方法需要绑定到类实例？"><a href="#问题-21：为什么类方法需要绑定到类实例？" class="headerlink" title="问题 21：为什么类方法需要绑定到类实例？"></a>问题 21：为什么类方法需要绑定到类实例？</h4><blockquote>
<p>难度: ⭐⭐⭐</p>
</blockquote>
<h5 id="在-JS-中，this-值会根据当前上下文变化。在-React-类组件方法中，开发人员通常希望-this-引用组件的当前实例，因此有必要将这些方法绑定到实例。通常这是在构造函数中完成的"><a href="#在-JS-中，this-值会根据当前上下文变化。在-React-类组件方法中，开发人员通常希望-this-引用组件的当前实例，因此有必要将这些方法绑定到实例。通常这是在构造函数中完成的" class="headerlink" title="在 JS 中，this 值会根据当前上下文变化。在 React 类组件方法中，开发人员通常希望 this 引用组件的当前实例，因此有必要将这些方法绑定到实例。通常这是在构造函数中完成的:"></a>在 JS 中，<code>this</code> 值会根据当前上下文变化。在 React 类组件方法中，开发人员通常希望 <code>this</code> 引用组件的当前实例，因此有必要将这些方法绑定到实例。通常这是在构造函数中完成的:</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class SubmitButton extends React.Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.state = &#123;</span><br><span class="line">      isFormSubmitted: false</span><br><span class="line">    &#125;;</span><br><span class="line">    this.handleSubmit = this.handleSubmit.bind(this);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleSubmit() &#123;</span><br><span class="line">    this.setState(&#123;</span><br><span class="line">      isFormSubmitted: true</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;button onClick=&#123;this.handleSubmit&#125;&gt;Submit&lt;/button&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="问题-22：什么是-prop-drilling，如何避免？"><a href="#问题-22：什么是-prop-drilling，如何避免？" class="headerlink" title="问题 22：什么是 prop drilling，如何避免？"></a>问题 22：什么是 prop drilling，如何避免？</h4><blockquote>
<p>难度: ⭐⭐⭐</p>
</blockquote>
<h5 id="在构建-React-应用程序时，在多层嵌套组件来使用另一个嵌套组件提供的数据。最简单的方法是将一个-prop-从每个组件一层层的传递下去，从源组件传递到深层嵌套组件，这叫做prop-drilling。"><a href="#在构建-React-应用程序时，在多层嵌套组件来使用另一个嵌套组件提供的数据。最简单的方法是将一个-prop-从每个组件一层层的传递下去，从源组件传递到深层嵌套组件，这叫做prop-drilling。" class="headerlink" title="在构建 React 应用程序时，在多层嵌套组件来使用另一个嵌套组件提供的数据。最简单的方法是将一个 prop 从每个组件一层层的传递下去，从源组件传递到深层嵌套组件，这叫做prop drilling。"></a>在构建 React 应用程序时，在多层嵌套组件来使用另一个嵌套组件提供的数据。最简单的方法是将一个 <code>prop</code> 从每个组件一层层的传递下去，从源组件传递到深层嵌套组件，这叫做<strong>prop drilling</strong>。</h5><h5 id="prop-drilling的主要缺点是原本不需要数据的组件变得不必要地复杂，并且难以维护。"><a href="#prop-drilling的主要缺点是原本不需要数据的组件变得不必要地复杂，并且难以维护。" class="headerlink" title="prop drilling的主要缺点是原本不需要数据的组件变得不必要地复杂，并且难以维护。"></a><code>prop drilling</code>的主要缺点是原本不需要数据的组件变得不必要地复杂，并且难以维护。</h5><h5 id="为了避免prop-drilling，一种常用的方法是使用React-Context。通过定义提供数据的Provider组件，并允许嵌套的组件通过Consumer组件或useContext-Hook-使用上下文数据。"><a href="#为了避免prop-drilling，一种常用的方法是使用React-Context。通过定义提供数据的Provider组件，并允许嵌套的组件通过Consumer组件或useContext-Hook-使用上下文数据。" class="headerlink" title="为了避免prop drilling，一种常用的方法是使用React Context。通过定义提供数据的Provider组件，并允许嵌套的组件通过Consumer组件或useContext Hook 使用上下文数据。"></a>为了避免<code>prop drilling</code>，一种常用的方法是使用<strong>React Context</strong>。通过定义提供数据的<code>Provider</code>组件，并允许嵌套的组件通过<code>Consumer</code>组件或<code>useContext</code> Hook 使用上下文数据。</h5><h4 id="问题-23：描述-Flux-与-MVC？"><a href="#问题-23：描述-Flux-与-MVC？" class="headerlink" title="问题 23：描述 Flux 与 MVC？"></a>问题 23：描述 Flux 与 MVC？</h4><blockquote>
<p>难度: ⭐⭐⭐</p>
</blockquote>
<h6 id="传统的-MVC-模式在分离数据-Model-、UI-View和逻辑-Controller-方面工作得很好，但是-MVC-架构经常遇到两个主要问题"><a href="#传统的-MVC-模式在分离数据-Model-、UI-View和逻辑-Controller-方面工作得很好，但是-MVC-架构经常遇到两个主要问题" class="headerlink" title="传统的 MVC 模式在分离数据(Model)、UI(View和逻辑(Controller)方面工作得很好，但是 MVC 架构经常遇到两个主要问题:"></a>传统的 MVC 模式在分离数据(Model)、UI(View和逻辑(Controller)方面工作得很好，但是 MVC 架构经常遇到两个主要问题:</h6><p><strong>数据流不够清晰</strong>:跨视图发生的级联更新常常会导致混乱的事件网络，难于调试。</p>
<p><strong>缺乏数据完整性</strong>:模型数据可以在任何地方发生突变，从而在整个UI中产生不可预测的结果。</p>
<h6 id="使用-Flux-模式的复杂用户界面不再遭受级联更新，任何给定的React-组件都能够根据-store-提供的数据重建其状态。Flux-模式还通过限制对共享数据的直接访问来加强数据完整性。"><a href="#使用-Flux-模式的复杂用户界面不再遭受级联更新，任何给定的React-组件都能够根据-store-提供的数据重建其状态。Flux-模式还通过限制对共享数据的直接访问来加强数据完整性。" class="headerlink" title="使用 Flux 模式的复杂用户界面不再遭受级联更新，任何给定的React 组件都能够根据 store 提供的数据重建其状态。Flux 模式还通过限制对共享数据的直接访问来加强数据完整性。"></a>使用 Flux 模式的复杂用户界面不再遭受级联更新，任何给定的React 组件都能够根据 <code>store</code> 提供的数据重建其状态。Flux 模式还通过限制对共享数据的直接访问来加强数据完整性。</h6><h4 id="问题-24：受控组件和非受控组件区别是啥？"><a href="#问题-24：受控组件和非受控组件区别是啥？" class="headerlink" title="问题 24：受控组件和非受控组件区别是啥？"></a>问题 24：受控组件和非受控组件区别是啥？</h4><blockquote>
<p>难度: ⭐⭐⭐</p>
</blockquote>
<ul>
<li><strong>受控组件</strong>是 React 控制中的组件，并且是表单数据真实的唯一来源。</li>
<li>非受控组件是由 DOM 处理表单数据的地方，而不是在 React 组件中。</li>
</ul>
<h5 id="尽管非受控组件通常更易于实现，因为只需使用refs即可从-DOM-中获取值，但通常建议优先选择受控制的组件，而不是非受控制的组件。"><a href="#尽管非受控组件通常更易于实现，因为只需使用refs即可从-DOM-中获取值，但通常建议优先选择受控制的组件，而不是非受控制的组件。" class="headerlink" title="尽管非受控组件通常更易于实现，因为只需使用refs即可从 DOM 中获取值，但通常建议优先选择受控制的组件，而不是非受控制的组件。"></a>尽管非受控组件通常更易于实现，因为只需使用<code>refs</code>即可从 DOM 中获取值，但通常建议优先选择受控制的组件，而不是非受控制的组件。</h5><h5 id="这样做的主要原因是受控组件支持即时字段验证，允许有条件地禁用-启用按钮，强制输入格式。"><a href="#这样做的主要原因是受控组件支持即时字段验证，允许有条件地禁用-启用按钮，强制输入格式。" class="headerlink" title="这样做的主要原因是受控组件支持即时字段验证，允许有条件地禁用/启用按钮，强制输入格式。"></a>这样做的主要原因是受控组件支持即时字段验证，允许有条件地禁用/启用按钮，强制输入格式。</h5><h4 id="问题-25：这段代码有什么问题吗？"><a href="#问题-25：这段代码有什么问题吗？" class="headerlink" title="问题 25：这段代码有什么问题吗？"></a>问题 25：这段代码有什么问题吗？</h4><blockquote>
<p>难度: ⭐⭐⭐⭐</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">this.setState((prevState, props) =&gt; &#123;</span><br><span class="line">  return &#123;</span><br><span class="line">    streak: prevState.streak + props.count</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h6 id="没有什么问题。这种方式很少被使用，咱们可以将一个函数传递给setState，该函数接收上一个-state-的值和当前的props，并返回一个新的状态，如果咱们需要根据以前的状态重新设置状态，推荐使用这种方式。"><a href="#没有什么问题。这种方式很少被使用，咱们可以将一个函数传递给setState，该函数接收上一个-state-的值和当前的props，并返回一个新的状态，如果咱们需要根据以前的状态重新设置状态，推荐使用这种方式。" class="headerlink" title="没有什么问题。这种方式很少被使用，咱们可以将一个函数传递给setState，该函数接收上一个 state 的值和当前的props，并返回一个新的状态，如果咱们需要根据以前的状态重新设置状态，推荐使用这种方式。"></a>没有什么问题。这种方式很少被使用，咱们可以将一个函数传递给<code>setState</code>，该函数接收上一个 <code>state</code> 的值和当前的<code>props</code>，并返回一个新的状态，如果咱们需要根据以前的状态重新设置状态，推荐使用这种方式。</h6><h4 id="问题-26：什么是-React-Context"><a href="#问题-26：什么是-React-Context" class="headerlink" title="问题 26：什么是 React Context?"></a>问题 26：什么是 React Context?</h4><blockquote>
<p>难度: ⭐⭐⭐⭐</p>
</blockquote>
<h5 id="Context-通过组件树提供了一个传递数据的方法，从而避免了在每一个层级手动的传递-props-属性。"><a href="#Context-通过组件树提供了一个传递数据的方法，从而避免了在每一个层级手动的传递-props-属性。" class="headerlink" title="Context 通过组件树提供了一个传递数据的方法，从而避免了在每一个层级手动的传递 props 属性。"></a><code>Context</code> 通过组件树提供了一个传递数据的方法，从而避免了在每一个层级手动的传递 <code>props</code> 属性。</h5><h4 id="问题-27：什么是-React-Fiber"><a href="#问题-27：什么是-React-Fiber" class="headerlink" title="问题 27：什么是 React Fiber?"></a>问题 27：什么是 React Fiber?</h4><blockquote>
<p>难度: ⭐⭐⭐⭐</p>
</blockquote>
<h5 id="Fiber-是-React-16-中新的协调引擎或重新实现核心算法。它的主要目标是支持虚拟DOM的增量渲染。React-Fiber-的目标是提高其在动画、布局、手势、暂停、中止或重用等方面的适用性，并为不同类型的更新分配优先级，以及新的并发原语。"><a href="#Fiber-是-React-16-中新的协调引擎或重新实现核心算法。它的主要目标是支持虚拟DOM的增量渲染。React-Fiber-的目标是提高其在动画、布局、手势、暂停、中止或重用等方面的适用性，并为不同类型的更新分配优先级，以及新的并发原语。" class="headerlink" title="Fiber 是 React 16 中新的协调引擎或重新实现核心算法。它的主要目标是支持虚拟DOM的增量渲染。React Fiber 的目标是提高其在动画、布局、手势、暂停、中止或重用等方面的适用性，并为不同类型的更新分配优先级，以及新的并发原语。"></a><strong>Fiber</strong> 是 React 16 中新的协调引擎或重新实现核心算法。它的主要目标是支持虚拟DOM的增量渲染。<strong>React Fiber</strong> 的目标是提高其在动画、布局、手势、暂停、中止或重用等方面的适用性，并为不同类型的更新分配优先级，以及新的并发原语。</h5><h5 id="React-Fiber-的目标是增强其在动画、布局和手势等领域的适用性。它的主要特性是增量渲染-能够将渲染工作分割成块，并将其分散到多个帧中。"><a href="#React-Fiber-的目标是增强其在动画、布局和手势等领域的适用性。它的主要特性是增量渲染-能够将渲染工作分割成块，并将其分散到多个帧中。" class="headerlink" title="React Fiber 的目标是增强其在动画、布局和手势等领域的适用性。它的主要特性是增量渲染:能够将渲染工作分割成块，并将其分散到多个帧中。"></a>React Fiber 的目标是增强其在动画、布局和手势等领域的适用性。它的主要特性是增量渲染:能够将渲染工作分割成块，并将其分散到多个帧中。</h5><h4 id="问题-28：如何在-ReactJS-的-Props上应用验证？"><a href="#问题-28：如何在-ReactJS-的-Props上应用验证？" class="headerlink" title="问题 28：如何在 ReactJS 的 Props上应用验证？"></a>问题 28：如何在 ReactJS 的 Props上应用验证？</h4><blockquote>
<p>难度: ⭐⭐⭐⭐</p>
</blockquote>
<h5 id="当应用程序在开发模式下运行时，React-将自动检查咱们在组件上设置的所有-props，以确保它们具有正确的数据类型。对于不正确的类型，开发模式下会在控制台中生成警告消息，而在生产模式中由于性能影响而禁用它。强制的-props-用-isRequired定义的。"><a href="#当应用程序在开发模式下运行时，React-将自动检查咱们在组件上设置的所有-props，以确保它们具有正确的数据类型。对于不正确的类型，开发模式下会在控制台中生成警告消息，而在生产模式中由于性能影响而禁用它。强制的-props-用-isRequired定义的。" class="headerlink" title="当应用程序在开发模式下运行时，React 将自动检查咱们在组件上设置的所有 props，以确保它们具有正确的数据类型。对于不正确的类型，开发模式下会在控制台中生成警告消息，而在生产模式中由于性能影响而禁用它。强制的 props 用 isRequired定义的。"></a>当应用程序在开发模式下运行时，React 将自动检查咱们在组件上设置的所有 <code>props</code>，以确保它们具有正确的数据类型。对于不正确的类型，开发模式下会在控制台中生成警告消息，而在生产模式中由于性能影响而禁用它。强制的 <code>props</code> 用 <code>isRequired</code>定义的。</h5><p>下面是一组预定义的 prop 类型:</p>
<ul>
<li>React.PropTypes.string</li>
<li>React.PropTypes.number</li>
<li>React.PropTypes.func</li>
<li>React.PropTypes.node</li>
<li>React.PropTypes.bool</li>
</ul>
<p>例如，咱们为用户组件定义了如下的<code>propTypes</code></p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import PropTypes from &apos;prop-types&apos;;</span><br><span class="line"></span><br><span class="line">class User extends React.Component &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;h1&gt;Welcome, &#123;this.props.name&#125;&lt;/h1&gt;</span><br><span class="line">      &lt;h2&gt;Age, &#123;this.props.age&#125;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">User.propTypes = &#123;</span><br><span class="line">  name: PropTypes.string.isRequired,</span><br><span class="line">  age: PropTypes.number.isRequired</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="问题-29：在-React-中使用构造函数和-getInitialState-有什么区别？"><a href="#问题-29：在-React-中使用构造函数和-getInitialState-有什么区别？" class="headerlink" title="问题 29：在 React 中使用构造函数和 getInitialState 有什么区别？"></a>问题 29：在 React 中使用构造函数和 getInitialState 有什么区别？</h4><blockquote>
<p>难度: ⭐⭐⭐⭐</p>
</blockquote>
<h5 id="构造函数和getInitialState之间的区别就是ES6和ES5本身的区别。在使用ES6类时，应该在构造函数中初始化state，并在使用React-createClass时定义getInitialState方法。"><a href="#构造函数和getInitialState之间的区别就是ES6和ES5本身的区别。在使用ES6类时，应该在构造函数中初始化state，并在使用React-createClass时定义getInitialState方法。" class="headerlink" title="构造函数和getInitialState之间的区别就是ES6和ES5本身的区别。在使用ES6类时，应该在构造函数中初始化state，并在使用React.createClass时定义getInitialState方法。"></a>构造函数和<code>getInitialState</code>之间的区别就是<code>ES6</code>和<code>ES5</code>本身的区别。在使用<code>ES6</code>类时，应该在构造函数中初始化<code>state</code>，并在使用<code>React.createClass</code>时定义<code>getInitialState</code>方法。</h5> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class MyComponent extends React.Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.state = &#123; /* initial state */ &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="问题-30：如何有条件地向-React-组件添加属性？"><a href="#问题-30：如何有条件地向-React-组件添加属性？" class="headerlink" title="问题 30：如何有条件地向 React 组件添加属性？"></a>问题 30：如何有条件地向 React 组件添加属性？</h4><blockquote>
<p>难度: ⭐⭐⭐⭐</p>
</blockquote>
<h5 id="对于某些属性，React-非常聪明，如果传递给它的值是虚值，可以省略该属性。例如："><a href="#对于某些属性，React-非常聪明，如果传递给它的值是虚值，可以省略该属性。例如：" class="headerlink" title="对于某些属性，React 非常聪明，如果传递给它的值是虚值，可以省略该属性。例如："></a>对于某些属性，React 非常聪明，如果传递给它的值是虚值，可以省略该属性。例如：</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var InputComponent = React.createClass(&#123;</span><br><span class="line">    render: function() &#123;</span><br><span class="line">      var required = true;</span><br><span class="line">      var disabled = false;</span><br><span class="line"></span><br><span class="line">      return (</span><br><span class="line">        &lt;input type=&quot;text&quot; disabled=&#123;disabled&#125; required=	  			&#123;required&#125; /&gt;</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>渲染结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;input type=&quot;text&quot; required&gt;</span><br></pre></td></tr></table></figure>

<p>另一种可能的方法是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var condition = true;</span><br><span class="line"></span><br><span class="line">var component = (</span><br><span class="line">  &lt;p</span><br><span class="line">    value=&quot;foo&quot;</span><br><span class="line">    &#123; ...( condition &amp;&amp; &#123; disabled: true &#125; ) &#125; /&gt;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h4 id="问题-31：Hooks会取代-render-props-和高阶组件吗？"><a href="#问题-31：Hooks会取代-render-props-和高阶组件吗？" class="headerlink" title="问题 31：Hooks会取代 render props 和高阶组件吗？"></a>问题 31：Hooks会取代 <code>render props</code> 和高阶组件吗？</h4><blockquote>
<p>难度: ⭐⭐⭐⭐</p>
</blockquote>
<h5 id="通常，render-props和高阶组件仅渲染一个子组件。React团队认为，Hooks-是服务此用例的更简单方法。"><a href="#通常，render-props和高阶组件仅渲染一个子组件。React团队认为，Hooks-是服务此用例的更简单方法。" class="headerlink" title="通常，render props和高阶组件仅渲染一个子组件。React团队认为，Hooks 是服务此用例的更简单方法。"></a>通常，<code>render props</code>和高阶组件仅渲染一个子组件。React团队认为，Hooks 是服务此用例的更简单方法。</h5><h5 id="这两种模式仍然有一席之地-例如，一个虚拟的-scroller-组件可能有一个-renderItem-prop，或者一个可视化的容器组件可能有它自己的-DOM-结构-。但在大多数情况下，Hooks-就足够了，可以帮助减少树中的嵌套。"><a href="#这两种模式仍然有一席之地-例如，一个虚拟的-scroller-组件可能有一个-renderItem-prop，或者一个可视化的容器组件可能有它自己的-DOM-结构-。但在大多数情况下，Hooks-就足够了，可以帮助减少树中的嵌套。" class="headerlink" title="这两种模式仍然有一席之地(例如，一个虚拟的 scroller 组件可能有一个 renderItem prop，或者一个可视化的容器组件可能有它自己的 DOM 结构)。但在大多数情况下，Hooks 就足够了，可以帮助减少树中的嵌套。"></a>这两种模式仍然有一席之地(例如，一个虚拟的 <code>scroller</code> 组件可能有一个 <code>renderItem prop</code>，或者一个可视化的容器组件可能有它自己的 DOM 结构)。但在大多数情况下，Hooks 就足够了，可以帮助减少树中的嵌套。</h5><h4 id="问题-32：如何避免组件的重新渲染？"><a href="#问题-32：如何避免组件的重新渲染？" class="headerlink" title="问题 32：如何避免组件的重新渲染？"></a>问题 32：如何避免组件的重新渲染？</h4><blockquote>
<p>难度: ⭐⭐⭐⭐</p>
</blockquote>
<p>React 中最常见的问题之一是组件不必要地重新渲染。React 提供了两个方法，在这些情况下非常有用：</p>
<ul>
<li><code>React.memo()</code>:这可以防止不必要地重新渲染函数组件</li>
<li><code>PureComponent</code>:这可以防止不必要地重新渲染类组件</li>
</ul>
<h5 id="这两种方法都依赖于对传递给组件的props的浅比较，如果-props-没有改变，那么组件将不会重新渲染。虽然这两种工具都非常有用，但是浅比较会带来额外的性能损失，因此如果使用不当，这两种方法都会对性能产生负面影响。"><a href="#这两种方法都依赖于对传递给组件的props的浅比较，如果-props-没有改变，那么组件将不会重新渲染。虽然这两种工具都非常有用，但是浅比较会带来额外的性能损失，因此如果使用不当，这两种方法都会对性能产生负面影响。" class="headerlink" title="这两种方法都依赖于对传递给组件的props的浅比较，如果 props 没有改变，那么组件将不会重新渲染。虽然这两种工具都非常有用，但是浅比较会带来额外的性能损失，因此如果使用不当，这两种方法都会对性能产生负面影响。"></a>这两种方法都依赖于对传递给组件的<code>props</code>的浅比较，如果 <code>props</code> 没有改变，那么组件将不会重新渲染。虽然这两种工具都非常有用，但是浅比较会带来额外的性能损失，因此如果使用不当，这两种方法都会对性能产生负面影响。</h5><h5 id="通过使用-React-Profiler，可以在使用这些方法前后对性能进行测量，从而确保通过进行给定的更改来实际改进性能。"><a href="#通过使用-React-Profiler，可以在使用这些方法前后对性能进行测量，从而确保通过进行给定的更改来实际改进性能。" class="headerlink" title="通过使用 React Profiler，可以在使用这些方法前后对性能进行测量，从而确保通过进行给定的更改来实际改进性能。"></a>通过使用 <strong>React Profiler</strong>，可以在使用这些方法前后对性能进行测量，从而确保通过进行给定的更改来实际改进性能。</h5><h4 id="问题-33：什么是纯函数？"><a href="#问题-33：什么是纯函数？" class="headerlink" title="问题 33：什么是纯函数？"></a>问题 33：什么是纯函数？</h4><blockquote>
<p>难度: ⭐⭐⭐⭐⭐</p>
</blockquote>
<h5 id="纯函数是不依赖并且不会在其作用域之外修改变量状态的函数。本质上，纯函数始终在给定相同参数的情况下返回相同结果。"><a href="#纯函数是不依赖并且不会在其作用域之外修改变量状态的函数。本质上，纯函数始终在给定相同参数的情况下返回相同结果。" class="headerlink" title="纯函数是不依赖并且不会在其作用域之外修改变量状态的函数。本质上，纯函数始终在给定相同参数的情况下返回相同结果。"></a>纯函数是不依赖并且不会在其作用域之外修改变量状态的函数。本质上，纯函数始终在给定相同参数的情况下返回相同结果。</h5><h4 id="问题-34：当调用setState时，React-render-是如何工作的？"><a href="#问题-34：当调用setState时，React-render-是如何工作的？" class="headerlink" title="问题 34：当调用setState时，React render 是如何工作的？"></a>问题 34：当调用<code>setState</code>时，React <code>render</code> 是如何工作的？</h4><blockquote>
<p>难度: ⭐⭐⭐⭐⭐</p>
</blockquote>
<h5 id="咱们可以将”render“分为两个步骤："><a href="#咱们可以将”render“分为两个步骤：" class="headerlink" title="咱们可以将”render“分为两个步骤："></a>咱们可以将”<code>render</code>“分为两个步骤：</h5><ol>
<li><h5 id="虚拟-DOM-渲染-当render方法被调用时，它返回一个新的组件的虚拟-DOM-结构。当调用setState-时，render会被再次调用，因为默认情况下shouldComponentUpdate总是返回true，所以默认情况下-React-是没有优化的。"><a href="#虚拟-DOM-渲染-当render方法被调用时，它返回一个新的组件的虚拟-DOM-结构。当调用setState-时，render会被再次调用，因为默认情况下shouldComponentUpdate总是返回true，所以默认情况下-React-是没有优化的。" class="headerlink" title="虚拟 DOM 渲染:当render方法被调用时，它返回一个新的组件的虚拟 DOM 结构。当调用setState()时，render会被再次调用，因为默认情况下shouldComponentUpdate总是返回true，所以默认情况下 React 是没有优化的。"></a>虚拟 DOM 渲染:当<code>render</code>方法被调用时，它返回一个新的组件的虚拟 DOM 结构。当调用<code>setState()</code>时，<code>render</code>会被再次调用，因为默认情况下<code>shouldComponentUpdate</code>总是返回<code>true</code>，所以默认情况下 React 是没有优化的。</h5></li>
<li><h5 id="原生-DOM-渲染-React-只会在虚拟DOM中修改真实DOM节点，而且修改的次数非常少——这是很棒的React特性，它优化了真实DOM的变化，使React变得更快。"><a href="#原生-DOM-渲染-React-只会在虚拟DOM中修改真实DOM节点，而且修改的次数非常少——这是很棒的React特性，它优化了真实DOM的变化，使React变得更快。" class="headerlink" title="原生 DOM 渲染:React 只会在虚拟DOM中修改真实DOM节点，而且修改的次数非常少——这是很棒的React特性，它优化了真实DOM的变化，使React变得更快。"></a>原生 DOM 渲染:React 只会在虚拟DOM中修改真实DOM节点，而且修改的次数非常少——这是很棒的React特性，它优化了真实DOM的变化，使React变得更快。</h5></li>
</ol>
<h4 id="问题-35：如何避免在React重新绑定实例？"><a href="#问题-35：如何避免在React重新绑定实例？" class="headerlink" title="问题 35：如何避免在React重新绑定实例？"></a>问题 35：如何避免在React重新绑定实例？</h4><blockquote>
<p>难度: ⭐⭐⭐⭐⭐</p>
</blockquote>
<h6 id="有几种常用方法可以避免在-React-中绑定方法："><a href="#有几种常用方法可以避免在-React-中绑定方法：" class="headerlink" title="有几种常用方法可以避免在 React 中绑定方法："></a>有几种常用方法可以避免在 React 中绑定方法：</h6><h6 id="1-将事件处理程序定义为内联箭头函数"><a href="#1-将事件处理程序定义为内联箭头函数" class="headerlink" title="1.将事件处理程序定义为内联箭头函数"></a>1.将事件处理程序定义为内联箭头函数</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class SubmitButton extends React.Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.state = &#123;</span><br><span class="line">      isFormSubmitted: false</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;button onClick=&#123;() =&gt; &#123;</span><br><span class="line">        this.setState(&#123; isFormSubmitted: true &#125;);</span><br><span class="line">      &#125;&#125;&gt;Submit&lt;/button&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="2-使用箭头函数来定义方法："><a href="#2-使用箭头函数来定义方法：" class="headerlink" title="2.使用箭头函数来定义方法："></a>2.使用箭头函数来定义方法：</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class SubmitButton extends React.Component &#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    isFormSubmitted: false</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleSubmit = () =&gt; &#123;</span><br><span class="line">    this.setState(&#123;</span><br><span class="line">      isFormSubmitted: true</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;button onClick=&#123;this.handleSubmit&#125;&gt;Submit&lt;/button&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="3-使用带有-Hooks-的函数组件"><a href="#3-使用带有-Hooks-的函数组件" class="headerlink" title="3.使用带有 Hooks 的函数组件"></a>3.使用带有 Hooks 的函数组件</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const SubmitButton = () =&gt; &#123;</span><br><span class="line">  const [isFormSubmitted, setIsFormSubmitted] = useState(false);</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;button onClick=&#123;() =&gt; &#123;</span><br><span class="line">        setIsFormSubmitted(true);</span><br><span class="line">    &#125;&#125;&gt;Submit&lt;/button&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>React</category>
      </categories>
  </entry>
  <entry>
    <title>webpack+vue-cil框架的搭建</title>
    <url>/2019/12/28/webpack-vue-cil%E6%A1%86%E6%9E%B6%E7%9A%84%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<h2 id="Webpack"><a href="#Webpack" class="headerlink" title="Webpack"></a>Webpack</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><h5 id="现如今的开发当中，webpack的使用越来越频繁，而我们也经常需要使用诸如vue-cli-create-react-app等脚手架来搭建我们的项目，所以对webpack的学习必不可少，下面我们一起进入到webpack的学习当中。"><a href="#现如今的开发当中，webpack的使用越来越频繁，而我们也经常需要使用诸如vue-cli-create-react-app等脚手架来搭建我们的项目，所以对webpack的学习必不可少，下面我们一起进入到webpack的学习当中。" class="headerlink" title="现如今的开发当中，webpack的使用越来越频繁，而我们也经常需要使用诸如vue/cli create-react-app等脚手架来搭建我们的项目，所以对webpack的学习必不可少，下面我们一起进入到webpack的学习当中。"></a>现如今的开发当中，webpack的使用越来越频繁，而我们也经常需要使用诸如vue/cli create-react-app等脚手架来搭建我们的项目，所以对webpack的学习必不可少，下面我们一起进入到webpack的学习当中。</h5><a id="more"></a>
<h3 id="1-入门-一起来用这些小例子让你熟悉webpack的配置"><a href="#1-入门-一起来用这些小例子让你熟悉webpack的配置" class="headerlink" title="1 入门(一起来用这些小例子让你熟悉webpack的配置)"></a>1 入门(一起来用这些小例子让你熟悉webpack的配置)</h3><p><img src="" alt="avtvor"></p>
<h3 id="1-1初始化项目"><a href="#1-1初始化项目" class="headerlink" title="1.1初始化项目"></a>1.1初始化项目</h3><h6 id="新建一个目录，初始化npm"><a href="#新建一个目录，初始化npm" class="headerlink" title="新建一个目录，初始化npm"></a>新建一个目录，初始化npm</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm init</span><br></pre></td></tr></table></figure>

<h5 id="webpack是运行在node环境中的，我们需要安装以下两个npm包"><a href="#webpack是运行在node环境中的，我们需要安装以下两个npm包" class="headerlink" title="webpack是运行在node环境中的，我们需要安装以下两个npm包"></a>webpack是运行在node环境中的，我们需要安装以下两个npm包</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm i -D webpack webpack-cli</span><br></pre></td></tr></table></figure>

<ul>
<li>npm i -D 为npm install –save-dev的缩写</li>
<li>npm i -S 为npm install –save的缩写</li>
</ul>
<h5 id="新建一个文件夹src-然后新建一个文件main-js-写一点代码测试一下"><a href="#新建一个文件夹src-然后新建一个文件main-js-写一点代码测试一下" class="headerlink" title="新建一个文件夹src ,然后新建一个文件main.js,写一点代码测试一下"></a>新建一个文件夹<code>src</code> ,然后新建一个文件<code>main.js</code>,写一点代码测试一下</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">console.log(&apos;calle me &apos;)</span><br></pre></td></tr></table></figure>

<h5 id="配置package-json命令"><a href="#配置package-json命令" class="headerlink" title="配置package.json命令"></a>配置package.json命令</h5><p><img src="https://raw.githubusercontent.com/hsonzhou95/blogImg/master/webpack/w1.png?token=AMCTPYZ4L67I6Q2MRG6XTBK6AXEAM" alt="avtvor"></p>
<h5 id="执行"><a href="#执行" class="headerlink" title="执行"></a>执行</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm run build</span><br></pre></td></tr></table></figure>

<h5 id="此时如果生成了一个dist文件夹，并且内部含有main-js说明已经打包成功了"><a href="#此时如果生成了一个dist文件夹，并且内部含有main-js说明已经打包成功了" class="headerlink" title="此时如果生成了一个dist文件夹，并且内部含有main.js说明已经打包成功了"></a>此时如果生成了一个dist文件夹，并且内部含有main.js说明已经打包成功了</h5><h3 id="1-2开始我们自己的配置"><a href="#1-2开始我们自己的配置" class="headerlink" title="1.2开始我们自己的配置"></a>1.2开始我们自己的配置</h3><h5 id="上面一个简单的例子只是webpack自己默认的配置，下面我们要实现更加丰富的自定义配置，新建一个build文件夹-里面新建一个webpack-config-js"><a href="#上面一个简单的例子只是webpack自己默认的配置，下面我们要实现更加丰富的自定义配置，新建一个build文件夹-里面新建一个webpack-config-js" class="headerlink" title="上面一个简单的例子只是webpack自己默认的配置，下面我们要实现更加丰富的自定义配置，新建一个build文件夹,里面新建一个webpack.config.js"></a>上面一个简单的例子只是webpack自己默认的配置，下面我们要实现更加丰富的自定义配置，新建一个<code>build</code>文件夹,里面新建一个<code>webpack.config.js</code></h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    mode:<span class="string">'development'</span>, <span class="comment">// 开发模式</span></span><br><span class="line">    entry: path.resolve(__dirname,<span class="string">'../src/main.js'</span>),    <span class="comment">// 入口文件</span></span><br><span class="line">    output: &#123;</span><br><span class="line">        filename: <span class="string">'output.js'</span>,      <span class="comment">// 打包后的文件名称</span></span><br><span class="line">        path: path.resolve(__dirname,<span class="string">'../dist'</span>)  <span class="comment">// 打包后的目录</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="更改我们的打包命令"><a href="#更改我们的打包命令" class="headerlink" title="更改我们的打包命令"></a>更改我们的打包命令</h5><p><img src="https://raw.githubusercontent.com/hsonzhou95/blogImg/master/webpack/p2.png?token=AMCTPYZG7LPE7YFZCHEIW7K6AXELQ" alt="avtvor"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">执行 npm run build 会发现生成了以下目录（图片）</span><br><span class="line">其中dist文件夹中的main.js就是我们需要在浏览器中实际运行的文件</span><br><span class="line">当然实际运用中不会仅仅如此,下面让我们通过实际案例带你快速入手webpack</span><br></pre></td></tr></table></figure>

<h3 id="1-3配置HTML模板"><a href="#1-3配置HTML模板" class="headerlink" title="1.3配置HTML模板"></a>1.3配置HTML模板</h3><h5 id="js文件打包好了-但是我们不可能每次在html文件中手动引入打包好的js。"><a href="#js文件打包好了-但是我们不可能每次在html文件中手动引入打包好的js。" class="headerlink" title="js文件打包好了,但是我们不可能每次在html文件中手动引入打包好的js。"></a>js文件打包好了,但是我们不可能每次在<code>html</code>文件中手动引入打包好的js。</h5><blockquote>
<p>这里可能有的朋友会认为我们打包js文件名称不是一直是固定的嘛(output.js)？这样每次就不用改动引入文件名称了呀？实际上我们日常开发中往往会这样配置:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module.export=&#123;</span><br><span class="line">	//省略其他配置</span><br><span class="line">	output:&#123;</span><br><span class="line">		filename:&apos;[name].[hash:8].js&apos;  //打包后的文件名称</span><br><span class="line">		path:path.resolve(__dirname,&apos;../dist&apos;) //打包后的目录</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="这时候生成的dist目录文件-如下"><a href="#这时候生成的dist目录文件-如下" class="headerlink" title="这时候生成的dist目录文件 如下"></a>这时候生成的dist目录文件 如下</h5><p><img src="https://raw.githubusercontent.com/hsonzhou95/blogImg/master/webpack/p3.png?token=AMCTPY6WYOFTRLJAEKFRUY26AXEQ4" alt="avtvor"></p>
<h5 id="为了缓存，你会发现打包好的js文件的名称每次都不一样。webpack打包出来的js文件我们需要引入到html中，但是每次我们都手动修改js文件名显得很麻烦，因此我们需要一个插件来帮我们完成这件事情"><a href="#为了缓存，你会发现打包好的js文件的名称每次都不一样。webpack打包出来的js文件我们需要引入到html中，但是每次我们都手动修改js文件名显得很麻烦，因此我们需要一个插件来帮我们完成这件事情" class="headerlink" title="为了缓存，你会发现打包好的js文件的名称每次都不一样。webpack打包出来的js文件我们需要引入到html中，但是每次我们都手动修改js文件名显得很麻烦，因此我们需要一个插件来帮我们完成这件事情:"></a>为了缓存，你会发现打包好的js文件的名称每次都不一样。webpack打包出来的js文件我们需要引入到html中，但是每次我们都手动修改js文件名显得很麻烦，因此我们需要一个插件来帮我们完成这件事情:</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm i -D html-webpack-plugin</span><br></pre></td></tr></table></figure>

<h5 id="新建一个build同级的文件夹public，里面新建一个index-html，具体配置文件如下"><a href="#新建一个build同级的文件夹public，里面新建一个index-html，具体配置文件如下" class="headerlink" title="新建一个build同级的文件夹public，里面新建一个index.html，具体配置文件如下"></a>新建一个build同级的文件夹public，里面新建一个index.html，具体配置文件如下</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-plugin'</span>)</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    mode:<span class="string">'development'</span>, <span class="comment">// 开发模式</span></span><br><span class="line">    entry: path.resolve(__dirname,<span class="string">'../src/main.js'</span>),    <span class="comment">// 入口文件</span></span><br><span class="line">    output: &#123;</span><br><span class="line">      filename: <span class="string">'[name].[hash:8].js'</span>,      <span class="comment">// 打包后的文件名称</span></span><br><span class="line">      path: path.resolve(__dirname,<span class="string">'../dist'</span>)  <span class="comment">// 打包后的目录</span></span><br><span class="line">    &#125;,</span><br><span class="line">    plugins:[</span><br><span class="line">      <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">        template:path.resolve(__dirname,<span class="string">'../public/index.html'</span>)</span><br><span class="line">      &#125;)</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="生成目录如下："><a href="#生成目录如下：" class="headerlink" title="生成目录如下："></a>生成目录如下：</h5><p><img src="https://raw.githubusercontent.com/hsonzhou95/blogImg/master/webpack/p4.png?token=AMCTPY6VZEPGCF6XEU5QRUC6AXES4" alt="avtvor"></p>
<h5 id="可以发现打包生成的js文件已经被自动引入html文件中"><a href="#可以发现打包生成的js文件已经被自动引入html文件中" class="headerlink" title="可以发现打包生成的js文件已经被自动引入html文件中"></a>可以发现打包生成的js文件已经被自动引入html文件中</h5><h3 id="1-3-1多入口文件如何开发"><a href="#1-3-1多入口文件如何开发" class="headerlink" title="1.3.1多入口文件如何开发"></a>1.3.1多入口文件如何开发</h3><blockquote>
<p>生成多个html-webpack-plugin实例来解决这个问题</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-plugin'</span>)</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    mode:<span class="string">'development'</span>, <span class="comment">// 开发模式</span></span><br><span class="line">    entry: &#123;</span><br><span class="line">      main:path.resolve(__dirname,<span class="string">'../src/main.js'</span>),</span><br><span class="line">      header:path.resolve(__dirname,<span class="string">'../src/header.js'</span>)</span><br><span class="line">  &#125;, </span><br><span class="line">    output: &#123;</span><br><span class="line">      filename: <span class="string">'[name].[hash:8].js'</span>,      <span class="comment">// 打包后的文件名称</span></span><br><span class="line">      path: path.resolve(__dirname,<span class="string">'../dist'</span>)  <span class="comment">// 打包后的目录</span></span><br><span class="line">    &#125;,</span><br><span class="line">    plugins:[</span><br><span class="line">      <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">        template:path.resolve(__dirname,<span class="string">'../public/index.html'</span>),</span><br><span class="line">        filename:<span class="string">'index.html'</span>,</span><br><span class="line">        chunks:[<span class="string">'main'</span>] <span class="comment">// 与入口文件对应的模块名</span></span><br><span class="line">      &#125;),</span><br><span class="line">      <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">        template:path.resolve(__dirname,<span class="string">'../public/header.html'</span>),</span><br><span class="line">        filename:<span class="string">'header.html'</span>,</span><br><span class="line">        chunks:[<span class="string">'header'</span>] <span class="comment">// 与入口文件对应的模块名</span></span><br><span class="line">      &#125;),</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="此时会发现生成以下目录"><a href="#此时会发现生成以下目录" class="headerlink" title="此时会发现生成以下目录"></a>此时会发现生成以下目录</h5><p><img src="https://raw.githubusercontent.com/hsonzhou95/blogImg/master/webpack/p5.png?token=AMCTPYZEV54EYSJL6CX6CNS6AXEUQ" alt="avtvor"></p>
<h3 id="1-3-2clean-webpack-plugin"><a href="#1-3-2clean-webpack-plugin" class="headerlink" title="1.3.2clean-webpack-plugin"></a>1.3.2clean-webpack-plugin</h3><blockquote>
<p>每次执行npm run build 会发现dist文件夹里会残留上次打包的文件，这里我们推荐一个plugin来帮我们在打包输出前清空文件夹clean-webpack-plugin</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123;CleanWebpackPlugin&#125; = <span class="built_in">require</span>(<span class="string">'clean-webpack-plugin'</span>)</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="comment">// ...省略其他配置</span></span><br><span class="line">    plugins:[<span class="keyword">new</span> CleanWebpackPlugin()]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-4引用CSS"><a href="#1-4引用CSS" class="headerlink" title="1.4引用CSS"></a>1.4引用CSS</h3><h5 id="我们的入口文件是js，所以我们在入口js中引入我们的css文件"><a href="#我们的入口文件是js，所以我们在入口js中引入我们的css文件" class="headerlink" title="我们的入口文件是js，所以我们在入口js中引入我们的css文件"></a>我们的入口文件是js，所以我们在入口js中引入我们的css文件</h5><p><img src="https://raw.githubusercontent.com/hsonzhou95/blogImg/master/webpack/p6.png?token=AMCTPY6FT65WFDECQJGX2LS6AXEZK" alt="avtvor"></p>
<h5 id="如果我们使用less来构建样式，则需要多安装两个"><a href="#如果我们使用less来构建样式，则需要多安装两个" class="headerlink" title="如果我们使用less来构建样式，则需要多安装两个"></a>如果我们使用less来构建样式，则需要多安装两个</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm i -D less less-loader</span><br></pre></td></tr></table></figure>

<h5 id="配置文件如下"><a href="#配置文件如下" class="headerlink" title="配置文件如下"></a>配置文件如下</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="comment">// ...省略其他配置</span></span><br><span class="line">    <span class="built_in">module</span>:&#123;</span><br><span class="line">      rules:[</span><br><span class="line">        &#123;</span><br><span class="line">          test:<span class="regexp">/\.css$/</span>,</span><br><span class="line">          use:[<span class="string">'style-loader'</span>,<span class="string">'css-loader'</span>] <span class="comment">// 从右向左解析原则</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          test:<span class="regexp">/\.less$/</span>,</span><br><span class="line">          use:[<span class="string">'style-loader'</span>,<span class="string">'css-loader'</span>,<span class="string">'less-loader'</span>] <span class="comment">// 从右向左解析原则</span></span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="浏览器打开html如下"><a href="#浏览器打开html如下" class="headerlink" title="浏览器打开html如下"></a>浏览器打开html如下</h5><p><img src="https://raw.githubusercontent.com/hsonzhou95/blogImg/master/webpack/p7.png?token=AMCTPY2EJZAP6REJEONFWGK6AXE3Y" alt="avtvor"></p>
<h3 id="1-4-1为css添加浏览器前缀"><a href="#1-4-1为css添加浏览器前缀" class="headerlink" title="1.4.1为css添加浏览器前缀"></a>1.4.1为css添加浏览器前缀</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm i -D postcss-loader autoprefixer</span><br></pre></td></tr></table></figure>

<h5 id="配置如下"><a href="#配置如下" class="headerlink" title="配置如下"></a>配置如下</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="built_in">module</span>:&#123;</span><br><span class="line">        rules:[</span><br><span class="line">            test/\.less$/,</span><br><span class="line">            use:[<span class="string">'style-loader'</span>,<span class="string">'css-loader'</span>,<span class="string">'postcss-loader'</span>,<span class="string">'less-loader'</span>] <span class="comment">// 从右向左解析原则</span></span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="接下来，我们还需要引入autoprefixer使其生效-这里有两种方式"><a href="#接下来，我们还需要引入autoprefixer使其生效-这里有两种方式" class="headerlink" title="接下来，我们还需要引入autoprefixer使其生效,这里有两种方式"></a>接下来，我们还需要引入<code>autoprefixer</code>使其生效,这里有两种方式</h5><h5 id="1、在项目根目录下创建一个postcss-config-js文件，配置如下："><a href="#1、在项目根目录下创建一个postcss-config-js文件，配置如下：" class="headerlink" title="1、在项目根目录下创建一个postcss.config.js文件，配置如下："></a>1、在项目根目录下创建一个postcss.config.js文件，配置如下：</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports=&#123;</span><br><span class="line">	plugins:[<span class="built_in">require</span>(<span class="string">'autoprefixer'</span>)] <span class="comment">//引用该插件即可了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2、直接在webpack-config-js里配置"><a href="#2、直接在webpack-config-js里配置" class="headerlink" title="2、直接在webpack.config.js里配置"></a>2、直接在webpack.config.js里配置</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="comment">//...省略其他配置</span></span><br><span class="line">    <span class="built_in">module</span>:&#123;</span><br><span class="line">        rules:[&#123;</span><br><span class="line">            test:<span class="regexp">/\.less$/</span>,</span><br><span class="line">            use:[<span class="string">'style-loader'</span>,<span class="string">'css-loader'</span>,&#123;</span><br><span class="line">                loader:<span class="string">'postcss-loader'</span>,</span><br><span class="line">                options:&#123;</span><br><span class="line">                    plugins:[<span class="built_in">require</span>(<span class="string">'autoprefixer'</span>)]</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,<span class="string">'less-loader'</span>] <span class="comment">// 从右向左解析原则</span></span><br><span class="line">        &#125;]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="这时候我们发现css通过style标签的方式添加到了html文件中，但是如果样式文件很多，全部添加到html中，难免显得混乱。这时候我们想用把css拆分出来用外链的形式引入css文件怎么做呢？这时候我们就需要借助插件来帮助我们"><a href="#这时候我们发现css通过style标签的方式添加到了html文件中，但是如果样式文件很多，全部添加到html中，难免显得混乱。这时候我们想用把css拆分出来用外链的形式引入css文件怎么做呢？这时候我们就需要借助插件来帮助我们" class="headerlink" title="这时候我们发现css通过style标签的方式添加到了html文件中，但是如果样式文件很多，全部添加到html中，难免显得混乱。这时候我们想用把css拆分出来用外链的形式引入css文件怎么做呢？这时候我们就需要借助插件来帮助我们"></a>这时候我们发现css通过style标签的方式添加到了html文件中，但是如果样式文件很多，全部添加到html中，难免显得混乱。这时候我们想用把css拆分出来用外链的形式引入css文件怎么做呢？这时候我们就需要借助插件来帮助我们</h5><h3 id="1-4-2拆分css"><a href="#1-4-2拆分css" class="headerlink" title="1.4.2拆分css"></a>1.4.2拆分css</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm i -D mini-css-extract-plugin</span><br></pre></td></tr></table></figure>

<blockquote>
<p>webpack 4.0以前，我们通过<code>extract-text-webpack-plugin</code>插件，把css样式从js文件中提取到单独的css文件中。webpack4.0以后，官方推荐使用<code>mini-css-extract-plugin</code>插件来打包css文件</p>
</blockquote>
<h5 id="配合文件如下"><a href="#配合文件如下" class="headerlink" title="配合文件如下"></a>配合文件如下</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> MiniCssExtractPlugin = <span class="built_in">require</span>(<span class="string">"mini-css-extract-plugin"</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">//...省略其他配置</span></span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.less$/</span>,</span><br><span class="line">        use: [</span><br><span class="line">           MiniCssExtractPlugin.loader,</span><br><span class="line">          <span class="string">'css-loader'</span>,</span><br><span class="line">          <span class="string">'less-loader'</span></span><br><span class="line">        ],</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> MiniCssExtractPlugin(&#123;</span><br><span class="line">        filename: <span class="string">"[name].[hash].css"</span>,</span><br><span class="line">        chunkFilename: <span class="string">"[id].css"</span>,</span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-4-3拆分多个css"><a href="#1-4-3拆分多个css" class="headerlink" title="1.4.3拆分多个css"></a>1.4.3拆分多个css</h3><blockquote>
<p>这里需要说的细一点,上面我们所用到的<code>mini-css-extract-plugin</code>会将所有的css样式合并为一个css文件。如果你想拆分为一一对应的多个css文件,我们需要使用到<code>extract-text-webpack-plugin</code>，而目前<code>mini-css-extract-plugin</code>还不支持此功能。我们需要安装@next版本的<code>extract-text-webpack-plugin</code></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm i -D extract-text-webpack-plugin@next</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> ExtractTextWebpackPlugin = <span class="built_in">require</span>(<span class="string">'extract-text-webpack-plugin'</span>)</span><br><span class="line"><span class="keyword">let</span> indexLess = <span class="keyword">new</span> ExtractTextWebpackPlugin(<span class="string">'index.less'</span>);</span><br><span class="line"><span class="keyword">let</span> indexCss = <span class="keyword">new</span> ExtractTextWebpackPlugin(<span class="string">'index.css'</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="built_in">module</span>:&#123;</span><br><span class="line">      rules:[</span><br><span class="line">        &#123;</span><br><span class="line">          test:<span class="regexp">/\.css$/</span>,</span><br><span class="line">          use: indexCss.extract(&#123;</span><br><span class="line">            use: [<span class="string">'css-loader'</span>]</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          test:<span class="regexp">/\.less$/</span>,</span><br><span class="line">          use: indexLess.extract(&#123;</span><br><span class="line">            use: [<span class="string">'css-loader'</span>,<span class="string">'less-loader'</span>]</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;,</span><br><span class="line">    plugins:[</span><br><span class="line">      indexLess,</span><br><span class="line">      indexCss</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-5打包-图片、字体、媒体、等文件"><a href="#1-5打包-图片、字体、媒体、等文件" class="headerlink" title="1.5打包 图片、字体、媒体、等文件"></a>1.5打包 图片、字体、媒体、等文件</h3><h5 id="file-loader就是将文件在进行一些处理后（主要是处理文件名和路径、解析文件url），并将文件移动到输出的目录中"><a href="#file-loader就是将文件在进行一些处理后（主要是处理文件名和路径、解析文件url），并将文件移动到输出的目录中" class="headerlink" title="file-loader就是将文件在进行一些处理后（主要是处理文件名和路径、解析文件url），并将文件移动到输出的目录中"></a><code>file-loader</code>就是将文件在进行一些处理后（主要是处理文件名和路径、解析文件url），并将文件移动到输出的目录中</h5><h5 id="url-loader-一般与file-loader搭配使用，功能与-file-loader-类似，如果文件小于限制的大小。则会返回-base64-编码，否则使用-file-loader-将文件移动到输出的目录中"><a href="#url-loader-一般与file-loader搭配使用，功能与-file-loader-类似，如果文件小于限制的大小。则会返回-base64-编码，否则使用-file-loader-将文件移动到输出的目录中" class="headerlink" title="url-loader 一般与file-loader搭配使用，功能与 file-loader 类似，如果文件小于限制的大小。则会返回 base64 编码，否则使用 file-loader 将文件移动到输出的目录中"></a><code>url-loader</code> 一般与<code>file-loader</code>搭配使用，功能与 file-loader 类似，如果文件小于限制的大小。则会返回 base64 编码，否则使用 file-loader 将文件移动到输出的目录中</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// 省略其它配置 ...</span></span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.(jpe?g|png|gif)$/i</span>, <span class="comment">//图片文件</span></span><br><span class="line">        use: [</span><br><span class="line">          &#123;</span><br><span class="line">            loader: <span class="string">'url-loader'</span>,</span><br><span class="line">            options: &#123;</span><br><span class="line">              limit: <span class="number">10240</span>,</span><br><span class="line">              fallback: &#123;</span><br><span class="line">                loader: <span class="string">'file-loader'</span>,</span><br><span class="line">                options: &#123;</span><br><span class="line">                    name: <span class="string">'img/[name].[hash:8].[ext]'</span></span><br><span class="line">                &#125;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.(mp4|webm|ogg|mp3|wav|flac|aac)(\?.*)?$/</span>, <span class="comment">//媒体文件</span></span><br><span class="line">        use: [</span><br><span class="line">          &#123;</span><br><span class="line">            loader: <span class="string">'url-loader'</span>,</span><br><span class="line">            options: &#123;</span><br><span class="line">              limit: <span class="number">10240</span>,</span><br><span class="line">              fallback: &#123;</span><br><span class="line">                loader: <span class="string">'file-loader'</span>,</span><br><span class="line">                options: &#123;</span><br><span class="line">                  name: <span class="string">'media/[name].[hash:8].[ext]'</span></span><br><span class="line">                &#125;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.(woff2?|eot|ttf|otf)(\?.*)?$/i</span>, <span class="comment">// 字体</span></span><br><span class="line">        use: [</span><br><span class="line">          &#123;</span><br><span class="line">            loader: <span class="string">'url-loader'</span>,</span><br><span class="line">            options: &#123;</span><br><span class="line">              limit: <span class="number">10240</span>,</span><br><span class="line">              fallback: &#123;</span><br><span class="line">                loader: <span class="string">'file-loader'</span>,</span><br><span class="line">                options: &#123;</span><br><span class="line">                  name: <span class="string">'fonts/[name].[hash:8].[ext]'</span></span><br><span class="line">                &#125;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;,</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-6用babel转义js文件"><a href="#1-6用babel转义js文件" class="headerlink" title="1.6用babel转义js文件"></a>1.6用babel转义js文件</h3><h5 id="为了使我们的js代码兼容更多的环境我们需要安装依赖"><a href="#为了使我们的js代码兼容更多的环境我们需要安装依赖" class="headerlink" title="为了使我们的js代码兼容更多的环境我们需要安装依赖"></a>为了使我们的js代码兼容更多的环境我们需要安装依赖</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm i babel-loader @babel/preset-env @babel/core</span><br></pre></td></tr></table></figure>

<ul>
<li>注意babel-loader与babel-core的版本对应关系</li>
</ul>
<p>1、bbael-loader 8.x对应babel-core 7.x</p>
<p>2、babel-loader 7.x对应babel-core 6.x</p>
<h5 id="配置如下-1"><a href="#配置如下-1" class="headerlink" title="配置如下"></a>配置如下</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="comment">// 省略其它配置 ...</span></span><br><span class="line">    <span class="built_in">module</span>:&#123;</span><br><span class="line">        rules:[</span><br><span class="line">          &#123;</span><br><span class="line">            test:<span class="regexp">/\.js$/</span>,</span><br><span class="line">            use:&#123;</span><br><span class="line">              loader:<span class="string">'babel-loader'</span>,</span><br><span class="line">              options:&#123;</span><br><span class="line">                presets:[<span class="string">'@babel/preset-env'</span>]</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            exclude:<span class="regexp">/node_modules/</span></span><br><span class="line">          &#125;,</span><br><span class="line">       ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="上面的babel-loader只会将-ES6-7-8语法转换为ES5语法，但是对新api并不会转换-例如-promise、Generator、Set、Maps、Proxy等-此时我们需要借助babel-polyfill来帮助我们转换"><a href="#上面的babel-loader只会将-ES6-7-8语法转换为ES5语法，但是对新api并不会转换-例如-promise、Generator、Set、Maps、Proxy等-此时我们需要借助babel-polyfill来帮助我们转换" class="headerlink" title="上面的babel-loader只会将 ES6/7/8语法转换为ES5语法，但是对新api并不会转换 例如(promise、Generator、Set、Maps、Proxy等),此时我们需要借助babel-polyfill来帮助我们转换"></a>上面的<code>babel-loader</code>只会将 ES6/7/8语法转换为ES5语法，但是对新api并不会转换 例如(promise、Generator、Set、Maps、Proxy等),此时我们需要借助babel-polyfill来帮助我们转换</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm i @babel/polyfill</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    entry: [<span class="string">"@babel/polyfill,path.resolve(__dirname,'../src/index.js')"</span>],    <span class="comment">// 入口文件</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="搭建vue开发环境"><a href="#搭建vue开发环境" class="headerlink" title="搭建vue开发环境"></a>搭建vue开发环境</h2><h5 id="上面的小例子已经帮助而我们实现了打包css、图片、js、html等文件。但是我们还需要以下几种配置："><a href="#上面的小例子已经帮助而我们实现了打包css、图片、js、html等文件。但是我们还需要以下几种配置：" class="headerlink" title="上面的小例子已经帮助而我们实现了打包css、图片、js、html等文件。但是我们还需要以下几种配置："></a>上面的小例子已经帮助而我们实现了打包css、图片、js、html等文件。但是我们还需要以下几种配置：</h5><h3 id="2-1解析-vue文件"><a href="#2-1解析-vue文件" class="headerlink" title="2.1解析.vue文件"></a>2.1解析.vue文件</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm i -D vue-loader vue-template-compiler vue-style-loader</span><br><span class="line">npm i -S vue</span><br></pre></td></tr></table></figure>

<h5 id="vue-loader-用于解析-vue文件"><a href="#vue-loader-用于解析-vue文件" class="headerlink" title="vue-loader 用于解析.vue文件"></a>vue-loader 用于解析.vue文件</h5><h5 id="vue-template-compiler用于编译模板-配置如下"><a href="#vue-template-compiler用于编译模板-配置如下" class="headerlink" title="vue-template-compiler用于编译模板 配置如下"></a>vue-template-compiler用于编译模板 配置如下</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> vueLoaderPlugin = <span class="built_in">require</span>(<span class="string">'vue-loader/lib/plugin'</span>)</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="built_in">module</span>:&#123;</span><br><span class="line">        rules:[&#123;</span><br><span class="line">            test:<span class="regexp">/\.vue$/</span>,</span><br><span class="line">            use:[<span class="string">'vue-loader'</span>]</span><br><span class="line">        &#125;,]</span><br><span class="line">     &#125;,</span><br><span class="line">    resolve:&#123;</span><br><span class="line">        alias:&#123;</span><br><span class="line">          <span class="string">'vue$'</span>:<span class="string">'vue/dist/vue.runtime.esm.js'</span>,</span><br><span class="line">          <span class="string">' @'</span>:path.resolve(__dirname,<span class="string">'../src'</span>)</span><br><span class="line">        &#125;,</span><br><span class="line">        extensions:[<span class="string">'*'</span>,<span class="string">'.js'</span>,<span class="string">'.json'</span>,<span class="string">'.vue'</span>]</span><br><span class="line">   &#125;,</span><br><span class="line">   plugins:[</span><br><span class="line">        <span class="keyword">new</span> vueLoaderPlugin()</span><br><span class="line">   ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-2配置webpack-dev-server进行热更新"><a href="#2-2配置webpack-dev-server进行热更新" class="headerlink" title="2.2配置webpack-dev-server进行热更新"></a>2.2配置webpack-dev-server进行热更新</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm i -D webpack-dev-server</span><br></pre></td></tr></table></figure>

<h5 id="配置如下-2"><a href="#配置如下-2" class="headerlink" title="配置如下"></a>配置如下</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const Webpack = require(&apos;webpack&apos;)</span><br><span class="line">module.exports = &#123;</span><br><span class="line">  // ...省略其他配置</span><br><span class="line">  devServer:&#123;</span><br><span class="line">    port:3000,</span><br><span class="line">    hot:true,</span><br><span class="line">    contentBase:&apos;../dist&apos;</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins:[</span><br><span class="line">    new Webpack.HotModuleReplacementPlugin()</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="完整配置如下"><a href="#完整配置如下" class="headerlink" title="完整配置如下"></a>完整配置如下</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> &#123;CleanWebpackPlugin&#125; = <span class="built_in">require</span>(<span class="string">'clean-webpack-plugin'</span>)</span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-plugin'</span>)</span><br><span class="line"><span class="keyword">const</span> MiniCssExtractPlugin = <span class="built_in">require</span>(<span class="string">"mini-css-extract-plugin"</span>);</span><br><span class="line"><span class="keyword">const</span> ExtractTextWebpackPlugin = <span class="built_in">require</span>(<span class="string">'extract-text-webpack-plugin'</span>)</span><br><span class="line"><span class="keyword">const</span> vueLoaderPlugin = <span class="built_in">require</span>(<span class="string">'vue-loader/lib/plugin'</span>)</span><br><span class="line"><span class="keyword">const</span> Webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>)</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    mode:<span class="string">'development'</span>, <span class="comment">// 开发模式</span></span><br><span class="line">    entry: &#123;</span><br><span class="line">      main:path.resolve(__dirname,<span class="string">'../src/main.js'</span>),</span><br><span class="line">    &#125;, </span><br><span class="line">    output: &#123;</span><br><span class="line">      filename: <span class="string">'[name].[hash:8].js'</span>,      <span class="comment">// 打包后的文件名称</span></span><br><span class="line">      path: path.resolve(__dirname,<span class="string">'../dist'</span>)  <span class="comment">// 打包后的目录</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="built_in">module</span>:&#123;</span><br><span class="line">      rules:[</span><br><span class="line">        &#123;</span><br><span class="line">          test:<span class="regexp">/\.vue$/</span>,</span><br><span class="line">          use:[<span class="string">'vue-loader'</span>]</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          test:<span class="regexp">/\.js$/</span>,</span><br><span class="line">          use:&#123;</span><br><span class="line">            loader:<span class="string">'babel-loader'</span>,</span><br><span class="line">            options:&#123;</span><br><span class="line">              presets:[</span><br><span class="line">                [<span class="string">'@babel/preset-env'</span>]</span><br><span class="line">              ]</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          test:<span class="regexp">/\.css$/</span>,</span><br><span class="line">          use: [<span class="string">'vue-style-loader'</span>,<span class="string">'css-loader'</span>,&#123;</span><br><span class="line">            loader:<span class="string">'postcss-loader'</span>,</span><br><span class="line">            options:&#123;</span><br><span class="line">              plugins:[<span class="built_in">require</span>(<span class="string">'autoprefixer'</span>)]</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;]</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          test:<span class="regexp">/\.less$/</span>,</span><br><span class="line">          use: [<span class="string">'vue-style-loader'</span>,<span class="string">'css-loader'</span>,&#123;</span><br><span class="line">            loader:<span class="string">'postcss-loader'</span>,</span><br><span class="line">            options:&#123;</span><br><span class="line">              plugins:[<span class="built_in">require</span>(<span class="string">'autoprefixer'</span>)]</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;,<span class="string">'less-loader'</span>]</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;,</span><br><span class="line">    resolve:&#123;</span><br><span class="line">      alias:&#123;</span><br><span class="line">        <span class="string">'vue$'</span>:<span class="string">'vue/dist/vue.runtime.esm.js'</span>,</span><br><span class="line">        <span class="string">' @'</span>:path.resolve(__dirname,<span class="string">'../src'</span>)</span><br><span class="line">      &#125;,</span><br><span class="line">      extensions:[<span class="string">'*'</span>,<span class="string">'.js'</span>,<span class="string">'.json'</span>,<span class="string">'.vue'</span>]</span><br><span class="line">    &#125;,</span><br><span class="line">    devServer:&#123;</span><br><span class="line">      port:<span class="number">3000</span>,</span><br><span class="line">      hot:<span class="literal">true</span>,</span><br><span class="line">      contentBase:<span class="string">'../dist'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    plugins:[</span><br><span class="line">      <span class="keyword">new</span> CleanWebpackPlugin(),</span><br><span class="line">      <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">        template:path.resolve(__dirname,<span class="string">'../public/index.html'</span>),</span><br><span class="line">        filename:<span class="string">'index.html'</span></span><br><span class="line">      &#125;),</span><br><span class="line">      <span class="keyword">new</span> vueLoaderPlugin(),</span><br><span class="line">      <span class="keyword">new</span> Webpack.HotModuleReplacementPlugin()</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-3配置打包命令"><a href="#2-3配置打包命令" class="headerlink" title="2.3配置打包命令"></a>2.3配置打包命令</h3><p><img src="https://raw.githubusercontent.com/hsonzhou95/blogImg/master/webpack/w8.png?token=AMCTPY7W7IUQGJ3PKHDR43S6AXE7I" alt="avtvor"></p>
<h5 id="打包文件已经配置完毕，接下来让我们测试一下"><a href="#打包文件已经配置完毕，接下来让我们测试一下" class="headerlink" title="打包文件已经配置完毕，接下来让我们测试一下"></a>打包文件已经配置完毕，接下来让我们测试一下</h5><h5 id="首先在src新建一个main-js"><a href="#首先在src新建一个main-js" class="headerlink" title="首先在src新建一个main.js"></a>首先在src新建一个main.js</h5><p><img src="https://raw.githubusercontent.com/hsonzhou95/blogImg/master/webpack/w9.png?token=AMCTPY6Y7KI6DZ4ID7UVRCC6AXFBI" alt="avtvor"></p>
<h5 id="新建一个App-vue"><a href="#新建一个App-vue" class="headerlink" title="新建一个App.vue"></a>新建一个App.vue</h5><p><img src="https://raw.githubusercontent.com/hsonzhou95/blogImg/master/webpack/w10.png?token=AMCTPY44LBWK7FQ2OGDCDN26AXFCO" alt="avtvor"></p>
<h5 id="新建一个public文件夹，里面新建一个index-html"><a href="#新建一个public文件夹，里面新建一个index-html" class="headerlink" title="新建一个public文件夹，里面新建一个index.html"></a>新建一个public文件夹，里面新建一个index.html</h5><p><img src="https://raw.githubusercontent.com/hsonzhou95/blogImg/master/webpack/w11.png?token=AMCTPY3IAKWOWSS75TBQK2C6AXFFS" alt="avtvor"></p>
<h5 id="执行npm-run-dev这时候如果浏览器出现Vue开发环境运行成功，那么恭喜你，已经成功迈出了第一步！"><a href="#执行npm-run-dev这时候如果浏览器出现Vue开发环境运行成功，那么恭喜你，已经成功迈出了第一步！" class="headerlink" title="执行npm run dev这时候如果浏览器出现Vue开发环境运行成功，那么恭喜你，已经成功迈出了第一步！"></a>执行<code>npm run dev</code>这时候如果浏览器出现Vue开发环境运行成功，那么恭喜你，已经成功迈出了第一步！</h5><h3 id="2-4区分开发环境与生产环境"><a href="#2-4区分开发环境与生产环境" class="headerlink" title="2.4区分开发环境与生产环境"></a>2.4区分开发环境与生产环境</h3><h5 id="实际应用到项目中，我们需要区分开发环境与生产环境，我们在原来webpack-config-js的基础上再新增两个文件"><a href="#实际应用到项目中，我们需要区分开发环境与生产环境，我们在原来webpack-config-js的基础上再新增两个文件" class="headerlink" title="实际应用到项目中，我们需要区分开发环境与生产环境，我们在原来webpack.config.js的基础上再新增两个文件"></a>实际应用到项目中，我们需要区分开发环境与生产环境，我们在原来webpack.config.js的基础上再新增两个文件</h5><ul>
<li><p>webpack.dev.js 开发环境配置文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">开发环境主要实现的是热更新，不要压缩代码，完整的sourceMap</span><br></pre></td></tr></table></figure>
</li>
<li><p>webpack.prod.js生产环境配置文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">生产环境主要实现的是压缩代码、提取css文件、合理的sourceMap、分割代码</span><br><span class="line">需要安装以下模块:</span><br><span class="line">npm i -D  webpack-merge copy-webpack-plugin optimize-css-assets-webpack-plugin uglifyjs-webpack-plugin</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>webpack-merge</code> 合并配置</p>
</li>
<li><p><code>copy-webpack-plugin</code> 拷贝静态资源</p>
</li>
<li><p><code>optimize-css-assets-webpack-plugin</code> 压缩css</p>
</li>
<li><p><code>uglifyjs-webpack-plugin</code> 压缩js</p>
</li>
</ul>
<blockquote>
<p><code>webpack mode</code>设置<code>production</code>的时候会自动压缩js代码。原则上不需要引入<code>uglifyjs-webpack-plugin</code>进行重复工作。但是<code>optimize-css-assets-webpack-plugin</code>压缩css的同时会破坏原有的js压缩，所以这里我们引入<code>uglifyjs</code>进行压缩</p>
</blockquote>
<h3 id="2-4-1webpack-config-js"><a href="#2-4-1webpack-config-js" class="headerlink" title="2.4.1webpack.config.js"></a>2.4.1webpack.config.js</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"><span class="keyword">const</span> &#123;CleanWebpackPlugin&#125; = <span class="built_in">require</span>(<span class="string">'clean-webpack-plugin'</span>)</span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-plugin'</span>)</span><br><span class="line"><span class="keyword">const</span> vueLoaderPlugin = <span class="built_in">require</span>(<span class="string">'vue-loader/lib/plugin'</span>)</span><br><span class="line"><span class="keyword">const</span> MiniCssExtractPlugin = <span class="built_in">require</span>(<span class="string">"mini-css-extract-plugin"</span>)</span><br><span class="line"><span class="keyword">const</span> devMode = process.argv.indexOf(<span class="string">'--mode=production'</span>) === <span class="number">-1</span>;</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry:&#123;</span><br><span class="line">    main:path.resolve(__dirname,<span class="string">'../src/main.js'</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  output:&#123;</span><br><span class="line">    path:path.resolve(__dirname,<span class="string">'../dist'</span>),</span><br><span class="line">    filename:<span class="string">'js/[name].[hash:8].js'</span>,</span><br><span class="line">    chunkFilename:<span class="string">'js/[name].[hash:8].js'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="built_in">module</span>:&#123;</span><br><span class="line">    rules:[</span><br><span class="line">      &#123;</span><br><span class="line">        test:<span class="regexp">/\.js$/</span>,</span><br><span class="line">        use:&#123;</span><br><span class="line">          loader:<span class="string">'babel-loader'</span>,</span><br><span class="line">          options:&#123;</span><br><span class="line">            presets:[<span class="string">'@babel/preset-env'</span>]</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        exclude:<span class="regexp">/node_modules/</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        test:<span class="regexp">/\.vue$/</span>,</span><br><span class="line">        use:[<span class="string">'cache-loader'</span>,<span class="string">'thread-loader'</span>,&#123;</span><br><span class="line">          loader:<span class="string">'vue-loader'</span>,</span><br><span class="line">          options:&#123;</span><br><span class="line">            compilerOptions:&#123;</span><br><span class="line">              preserveWhitespace:<span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;]</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        test:<span class="regexp">/\.css$/</span>,</span><br><span class="line">        use:[&#123;</span><br><span class="line">          loader: devMode ? <span class="string">'vue-style-loader'</span> : MiniCssExtractPlugin.loader,</span><br><span class="line">          options:&#123;</span><br><span class="line">            publicPath:<span class="string">"../dist/css/"</span>,</span><br><span class="line">            hmr:devMode</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,<span class="string">'css-loader'</span>,&#123;</span><br><span class="line">          loader:<span class="string">'postcss-loader'</span>,</span><br><span class="line">          options:&#123;</span><br><span class="line">            plugins:[<span class="built_in">require</span>(<span class="string">'autoprefixer'</span>)]</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;]</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        test:<span class="regexp">/\.less$/</span>,</span><br><span class="line">        use:[&#123;</span><br><span class="line">          loader:devMode ? <span class="string">'vue-style-loader'</span> : MiniCssExtractPlugin.loader,</span><br><span class="line">          options:&#123;</span><br><span class="line">            publicPath:<span class="string">"../dist/css/"</span>,</span><br><span class="line">            hmr:devMode</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,<span class="string">'css-loader'</span>,<span class="string">'less-loader'</span>,&#123;</span><br><span class="line">          loader:<span class="string">'postcss-loader'</span>,</span><br><span class="line">          options:&#123;</span><br><span class="line">            plugins:[<span class="built_in">require</span>(<span class="string">'autoprefixer'</span>)]</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;]</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        test:<span class="regexp">/\.(jep?g|png|gif)$/</span>,</span><br><span class="line">        use:&#123;</span><br><span class="line">          loader:<span class="string">'url-loader'</span>,</span><br><span class="line">          options:&#123;</span><br><span class="line">            limit:<span class="number">10240</span>,</span><br><span class="line">            fallback:&#123;</span><br><span class="line">              loader:<span class="string">'file-loader'</span>,</span><br><span class="line">              options:&#123;</span><br><span class="line">                name:<span class="string">'img/[name].[hash:8].[ext]'</span></span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        test:<span class="regexp">/\.(mp4|webm|ogg|mp3|wav|flac|aac)(\?.*)?$/</span>,</span><br><span class="line">        use:&#123;</span><br><span class="line">          loader:<span class="string">'url-loader'</span>,</span><br><span class="line">          options:&#123;</span><br><span class="line">            limit:<span class="number">10240</span>,</span><br><span class="line">            fallback:&#123;</span><br><span class="line">              loader:<span class="string">'file-loader'</span>,</span><br><span class="line">              options:&#123;</span><br><span class="line">                name:<span class="string">'media/[name].[hash:8].[ext]'</span></span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        test:<span class="regexp">/\.(woff2?|eot|ttf|otf)(\?.*)?$/i</span>,</span><br><span class="line">        use:&#123;</span><br><span class="line">          loader:<span class="string">'url-loader'</span>,</span><br><span class="line">          options:&#123;</span><br><span class="line">            limit:<span class="number">10240</span>,</span><br><span class="line">            fallback:&#123;</span><br><span class="line">              loader:<span class="string">'file-loader'</span>,</span><br><span class="line">              options:&#123;</span><br><span class="line">                name:<span class="string">'media/[name].[hash:8].[ext]'</span></span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  resolve:&#123;</span><br><span class="line">    alias:&#123;</span><br><span class="line">      <span class="string">'vue$'</span>:<span class="string">'vue/dist/vue.runtime.esm.js'</span>,</span><br><span class="line">      <span class="string">' @'</span>:path.resolve(__dirname,<span class="string">'../src'</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    extensions:[<span class="string">'*'</span>,<span class="string">'.js'</span>,<span class="string">'.json'</span>,<span class="string">'.vue'</span>]</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins:[</span><br><span class="line">    <span class="keyword">new</span> CleanWebpackPlugin(),</span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">      template:path.resolve(__dirname,<span class="string">'../public/index.html'</span>)</span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="keyword">new</span> vueLoaderPlugin(),</span><br><span class="line">    <span class="keyword">new</span> MiniCssExtractPlugin(&#123;</span><br><span class="line">      filename: devMode ? <span class="string">'[name].css'</span> : <span class="string">'[name].[hash].css'</span>,</span><br><span class="line">      chunkFilename: devMode ? <span class="string">'[id].css'</span> : <span class="string">'[id].[hash].css'</span></span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-4-2webpack-dev-js"><a href="#2-4-2webpack-dev-js" class="headerlink" title="2.4.2webpack.dev.js"></a>2.4.2webpack.dev.js</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>)</span><br><span class="line"><span class="keyword">const</span> webpackConfig = <span class="built_in">require</span>(<span class="string">'./webpack.config.js'</span>)</span><br><span class="line"><span class="keyword">const</span> WebpackMerge = <span class="built_in">require</span>(<span class="string">'webpack-merge'</span>)</span><br><span class="line"><span class="built_in">module</span>.exports = WebpackMerge(webpackConfig,&#123;</span><br><span class="line">  mode:<span class="string">'development'</span>,</span><br><span class="line">  devtool:<span class="string">'cheap-module-eval-source-map'</span>,</span><br><span class="line">  devServer:&#123;</span><br><span class="line">    port:<span class="number">3000</span>,</span><br><span class="line">    hot:<span class="literal">true</span>,</span><br><span class="line">    contentBase:<span class="string">'../dist'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  plugins:[</span><br><span class="line">    <span class="keyword">new</span> Webpack.HotModuleReplacementPlugin()</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="2-4-3webpack-prod-js"><a href="#2-4-3webpack-prod-js" class="headerlink" title="2.4.3webpack.prod.js"></a>2.4.3webpack.prod.js</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"><span class="keyword">const</span> webpackConfig = <span class="built_in">require</span>(<span class="string">'./webpack.config.js'</span>)</span><br><span class="line"><span class="keyword">const</span> WebpackMerge = <span class="built_in">require</span>(<span class="string">'webpack-merge'</span>)</span><br><span class="line"><span class="keyword">const</span> CopyWebpackPlugin = <span class="built_in">require</span>(<span class="string">'copy-webpack-plugin'</span>)</span><br><span class="line"><span class="keyword">const</span> OptimizeCssAssetsPlugin = <span class="built_in">require</span>(<span class="string">'optimize-css-assets-webpack-plugin'</span>)</span><br><span class="line"><span class="keyword">const</span> UglifyJsPlugin = <span class="built_in">require</span>(<span class="string">'uglifyjs-webpack-plugin'</span>)</span><br><span class="line"><span class="built_in">module</span>.exports = WebpackMerge(webpackConfig,&#123;</span><br><span class="line">  mode:<span class="string">'production'</span>,</span><br><span class="line">  devtool:<span class="string">'cheap-module-source-map'</span>,</span><br><span class="line">  plugins:[</span><br><span class="line">    <span class="keyword">new</span> CopyWebpackPlugin([&#123;</span><br><span class="line">      <span class="keyword">from</span>:path.resolve(__dirname,<span class="string">'../public'</span>),</span><br><span class="line">      to:path.resolve(__dirname,<span class="string">'../dist'</span>)</span><br><span class="line">    &#125;]),</span><br><span class="line">  ],</span><br><span class="line">  optimization:&#123;</span><br><span class="line">    minimizer:[</span><br><span class="line">      <span class="keyword">new</span> UglifyJsPlugin(&#123;<span class="comment">//压缩js</span></span><br><span class="line">        cache:<span class="literal">true</span>,</span><br><span class="line">        parallel:<span class="literal">true</span>,</span><br><span class="line">        sourceMap:<span class="literal">true</span></span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="keyword">new</span> OptimizeCssAssetsPlugin(&#123;&#125;)</span><br><span class="line">    ],</span><br><span class="line">    splitChunks:&#123;</span><br><span class="line">      chunks:<span class="string">'all'</span>,</span><br><span class="line">      cacheGroups:&#123;</span><br><span class="line">        libs: &#123;</span><br><span class="line">          name: <span class="string">"chunk-libs"</span>,</span><br><span class="line">          test: <span class="regexp">/[\\/]node_modules[\\/]/</span>,</span><br><span class="line">          priority: <span class="number">10</span>,</span><br><span class="line">          chunks: <span class="string">"initial"</span> <span class="comment">// 只打包初始时依赖的第三方</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="2-5优化webpack配置"><a href="#2-5优化webpack配置" class="headerlink" title="2.5优化webpack配置"></a>2.5优化webpack配置</h3><h5 id="优化配置对我们来说非常有实际意义，这实际关系到你打包出来文件的大小，打包的速度等。-具体优化可以分为以下几点："><a href="#优化配置对我们来说非常有实际意义，这实际关系到你打包出来文件的大小，打包的速度等。-具体优化可以分为以下几点：" class="headerlink" title="优化配置对我们来说非常有实际意义，这实际关系到你打包出来文件的大小，打包的速度等。 具体优化可以分为以下几点："></a>优化配置对我们来说非常有实际意义，这实际关系到你打包出来文件的大小，打包的速度等。 具体优化可以分为以下几点：</h5><h3 id="2-5-1优化打包速度"><a href="#2-5-1优化打包速度" class="headerlink" title="2.5.1优化打包速度"></a>2.5.1优化打包速度</h3><blockquote>
<p>构建速度指的是我们每次修改代码后热更新的速度以及发布前打包文件的速度。</p>
</blockquote>
<h3 id="2-5-1-1合理的配置mode参数与devtool参数"><a href="#2-5-1-1合理的配置mode参数与devtool参数" class="headerlink" title="2.5.1.1合理的配置mode参数与devtool参数"></a>2.5.1.1合理的配置mode参数与devtool参数</h3><p><code>mode</code>可设置<code>development`` production</code>两个参数<br> 如果没有设置，<code>webpack4</code> 会将 <code>mode</code> 的默认值设置为 <code>production</code><br> <code>production</code>模式下会进行<code>tree shaking</code>(去除无用代码)和<code>uglifyjs</code>(代码压缩混淆)</p>
<h3 id="2-5-1-2缩小文件的搜索范围（配置include-exclude-alias-noParse-extensions）"><a href="#2-5-1-2缩小文件的搜索范围（配置include-exclude-alias-noParse-extensions）" class="headerlink" title="2.5.1.2缩小文件的搜索范围（配置include exclude alias noParse extensions）"></a>2.5.1.2缩小文件的搜索范围（配置include exclude alias noParse extensions）</h3><ul>
<li><code>alias</code>: 当我们代码中出现 <code>import &#39;vue&#39;</code>时， webpack会采用向上递归搜索的方式去<code>node_modules</code> 目录下找。为了减少搜索范围我们可以直接告诉webpack去哪个路径下查找。也就是别名(<code>alias</code>)的配置。</li>
<li><code>include exclude</code> 同样配置<code>include exclude</code>也可以减少<code>webpack loader</code>的搜索转换时间。</li>
<li><code>noParse</code> 当我们代码中使用到<code>import jq from &#39;jquery&#39;</code>时，<code>webpack</code>会去解析jq这个库是否有依赖其他的包。但是我们对类似<code>jquery</code>这类依赖库，一般会认为不会引用其他的包(特殊除外,自行判断)。增加<code>noParse</code>属性,告诉<code>webpack</code>不必解析，以此增加打包速度。</li>
<li><code>extensions ``webpack</code>会根据<code>extensions</code>定义的后缀查找文件(频率较高的文件类型优先写在前面)</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hsonzhou95/blogImg/master/webpack/carbon-2.png?token=AMCTPY6ONNVCSFA4DVFHLLS6AXFIE" alt="avtvor"></p>
<h3 id="2-5-1-3使用HappyPack开启多进程Loader转换"><a href="#2-5-1-3使用HappyPack开启多进程Loader转换" class="headerlink" title="2.5.1.3使用HappyPack开启多进程Loader转换"></a>2.5.1.3使用HappyPack开启多进程Loader转换</h3><blockquote>
<p>在webpack构建过程中，实际上耗费时间大多数用在loader解析转换以及代码的压缩中。日常开发中我们需要使用Loader对js，css，图片，字体等文件做转换操作，并且转换的文件数据量也是非常大。由于js单线程的特性使得这些转换操作不能并发处理文件，而是需要一个个文件进行处理。HappyPack的基本原理是将这部分任务分解到多个子进程中去并行处理，子进程处理完成后把结果发送到主进程中，从而减少总的构建时间</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm i -D happypack</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/hsonzhou95/blogImg/master/webpack/carbon-3.png?token=AMCTPY5QB3UBYVSOU4Q7RCK6AXFJE" alt="avtvor"></p>
<h3 id="2-5-1-4使用webpack-parallel-uglify-plugin增强代码压缩"><a href="#2-5-1-4使用webpack-parallel-uglify-plugin增强代码压缩" class="headerlink" title="2.5.1.4使用webpack-parallel-uglify-plugin增强代码压缩"></a>2.5.1.4使用webpack-parallel-uglify-plugin增强代码压缩</h3><blockquote>
<p>上面对于loader转换已经做优化，那么下面还有另一个难点就是优化代码的压缩时间。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm i -D webpack-parallel-uglify-plugin</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/hsonzhou95/blogImg/master/webpack/carbon-4.png?token=AMCTPY5KDI7PHB26LMRZ35K6AXFLK" alt="avtvor"></p>
<h3 id="2-5-1-5抽离第三方模块"><a href="#2-5-1-5抽离第三方模块" class="headerlink" title="2.5.1.5抽离第三方模块"></a>2.5.1.5抽离第三方模块</h3><blockquote>
<p>对于开发项目中不经常会变更的静态依赖文件。类似于我们的<code>elementUi、vue</code>全家桶等等。因为很少会变更，所以我们不希望这些依赖要被集成到每一次的构建逻辑中去。 这样做的好处是每次更改我本地代码的文件的时候，<code>webpack</code>只需要打包我项目本身的文件代码，而不会再去编译第三方库。以后只要我们不升级第三方包的时候，那么<code>webpack</code>就不会对这些库去打包，这样可以快速的提高打包的速度。</p>
</blockquote>
<h5 id="这里我们使用webpack内置的DllPlugin-DllReferencePlugin进行抽离在与webpack配置文件同级目录下新建webpack-dll-config-js-代码如下"><a href="#这里我们使用webpack内置的DllPlugin-DllReferencePlugin进行抽离在与webpack配置文件同级目录下新建webpack-dll-config-js-代码如下" class="headerlink" title="这里我们使用webpack内置的DllPlugin DllReferencePlugin进行抽离在与webpack配置文件同级目录下新建webpack.dll.config.js 代码如下"></a>这里我们使用<code>webpack</code>内置的<code>DllPlugin DllReferencePlugin</code>进行抽离在与<code>webpack</code>配置文件同级目录下新建<code>webpack.dll.config.js</code> 代码如下</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.dll.config.js</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">"path"</span>);</span><br><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">"webpack"</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// 你想要打包的模块的数组</span></span><br><span class="line">  entry: &#123;</span><br><span class="line">    vendor: [<span class="string">'vue'</span>,<span class="string">'element-ui'</span>] </span><br><span class="line">  &#125;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">'static/js'</span>), <span class="comment">// 打包后文件输出的位置</span></span><br><span class="line">    filename: <span class="string">'[name].dll.js'</span>,</span><br><span class="line">    library: <span class="string">'[name]_library'</span> </span><br><span class="line">     <span class="comment">// 这里需要和webpack.DllPlugin中的`name: '[name]_library',`保持一致。</span></span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> webpack.DllPlugin(&#123;</span><br><span class="line">      path: path.resolve(__dirname, <span class="string">'[name]-manifest.json'</span>),</span><br><span class="line">      name: <span class="string">'[name]_library'</span>, </span><br><span class="line">      context: __dirname</span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="在package-json中配置如下命令"><a href="#在package-json中配置如下命令" class="headerlink" title="在package.json中配置如下命令"></a>在package.json中配置如下命令</h5><figure class="highlight"><table><tr><td class="code"><pre><span class="line">"dll":"webpack --config build/webpack.dll.config.js"</span><br></pre></td></tr></table></figure>

<h5 id="接下来在我们的webpack-config-js中增加以下代码"><a href="#接下来在我们的webpack-config-js中增加以下代码" class="headerlink" title="接下来在我们的webpack.config.js中增加以下代码"></a>接下来在我们的webpack.config.js中增加以下代码</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> webpack.DllReferencePlugin(&#123;</span><br><span class="line">      context: __dirname,</span><br><span class="line">      manifest: <span class="built_in">require</span>(<span class="string">'./vendor-manifest.json'</span>)</span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="keyword">new</span> CopyWebpackPlugin([ <span class="comment">// 拷贝生成的文件到dist目录 这样每次不必手动去cv</span></span><br><span class="line">      &#123;<span class="attr">from</span>: <span class="string">'static'</span>, <span class="attr">to</span>:<span class="string">'static'</span>&#125;</span><br><span class="line">    ]),</span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>执行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm run dll</span><br></pre></td></tr></table></figure>

<h5 id="会发现生成了我们需要的集合第三地方-代码的vendor-dll-js-我们需要在html文件中手动引入这个js文件"><a href="#会发现生成了我们需要的集合第三地方-代码的vendor-dll-js-我们需要在html文件中手动引入这个js文件" class="headerlink" title="会发现生成了我们需要的集合第三地方 代码的vendor.dll.js 我们需要在html文件中手动引入这个js文件"></a>会发现生成了我们需要的集合第三地方 代码的<code>vendor.dll.js</code> 我们需要在<code>html</code>文件中手动引入这个<code>js</code>文件</h5><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>hello webpack<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"static/js/vendor.dll.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="这样如果我们没有更新第三方依赖包，就不必npm-run-dll。直接执行npm-run-dev-npm-run-build的时候会发现我们的打包速度明显有所提升。因为我们已经通过dllPlugin将第三方依赖包抽离出来了"><a href="#这样如果我们没有更新第三方依赖包，就不必npm-run-dll。直接执行npm-run-dev-npm-run-build的时候会发现我们的打包速度明显有所提升。因为我们已经通过dllPlugin将第三方依赖包抽离出来了" class="headerlink" title="这样如果我们没有更新第三方依赖包，就不必npm run dll。直接执行npm run dev npm run build的时候会发现我们的打包速度明显有所提升。因为我们已经通过dllPlugin将第三方依赖包抽离出来了"></a>这样如果我们没有更新第三方依赖包，就不必<code>npm run dll</code>。直接执行<code>npm run dev npm run build</code>的时候会发现我们的打包速度明显有所提升。因为我们已经通过<code>dllPlugin</code>将第三方依赖包抽离出来了</h5><h3 id="2-5-1-6配置缓存"><a href="#2-5-1-6配置缓存" class="headerlink" title="2.5.1.6配置缓存"></a>2.5.1.6配置缓存</h3><blockquote>
<p>我们每次执行构建都会把所有的文件都重复编译一遍，这样的重复工作是否可以被缓存下来呢，答案是可以的，目前大部分 <code>loader</code> 都提供了<code>cache</code> 配置项。比如在 <code>babel-loader</code> 中，可以通过设置<code>cacheDirectory</code> 来开启缓存，<code>babel-loader?cacheDirectory=true</code> 就会将每次的编译结果写进硬盘文件（默认是在项目根目录下的<code>node_modules/.cache/babel-loader</code>目录内，当然你也可以自定义）</p>
</blockquote>
<h5 id="但如果-loader-不支持缓存呢？我们也有方法-我们可以通过cache-loader-，它所做的事情很简单，就是-babel-loader-开启-cache后做的事情，将-loader-的编译结果写入硬盘缓存。再次构建会先比较一下，如果文件较之前的没有发生变化则会直接使用缓存。使用方法如官方-demo-所示，在一些性能开销较大的-loader-之前添加此-loader即可"><a href="#但如果-loader-不支持缓存呢？我们也有方法-我们可以通过cache-loader-，它所做的事情很简单，就是-babel-loader-开启-cache后做的事情，将-loader-的编译结果写入硬盘缓存。再次构建会先比较一下，如果文件较之前的没有发生变化则会直接使用缓存。使用方法如官方-demo-所示，在一些性能开销较大的-loader-之前添加此-loader即可" class="headerlink" title="但如果 loader 不支持缓存呢？我们也有方法,我们可以通过cache-loader ，它所做的事情很简单，就是 babel-loader 开启 cache后做的事情，将 loader 的编译结果写入硬盘缓存。再次构建会先比较一下，如果文件较之前的没有发生变化则会直接使用缓存。使用方法如官方 demo 所示，在一些性能开销较大的 loader 之前添加此 loader即可"></a>但如果 <code>loader</code> 不支持缓存呢？我们也有方法,我们可以通过<code>cache-loader</code> ，它所做的事情很简单，就是 <code>babel-loader</code> 开启 <code>cache</code>后做的事情，将 <code>loader</code> 的编译结果写入硬盘缓存。再次构建会先比较一下，如果文件较之前的没有发生变化则会直接使用缓存。使用方法如官方 demo 所示，在一些性能开销较大的 loader 之前添加此 loader即可</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm i -D cache-loader</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/hsonzhou95/blogImg/master/webpack/carbon-5.png?token=AMCTPY345PGYFDVH4ZM4BZ26AXFR4" alt="avtvor"></p>
<h3 id="2-5-2优化打包文件体积"><a href="#2-5-2优化打包文件体积" class="headerlink" title="2.5.2优化打包文件体积"></a>2.5.2优化打包文件体积</h3><blockquote>
<p>打包的速度我们是进行优化，但是打包后的文件体积确实十分大，造成了页面加载缓慢，浪费流量等，接下来我们从文件体积上继续优化</p>
</blockquote>
<h3 id="2-5-2-1引入webpack-bundle-analyzer分析打包后的文件"><a href="#2-5-2-1引入webpack-bundle-analyzer分析打包后的文件" class="headerlink" title="2.5.2.1引入webpack-bundle-analyzer分析打包后的文件"></a>2.5.2.1引入webpack-bundle-analyzer分析打包后的文件</h3><h5 id="webpack-bundle-analyzer将打包后的内容束展示为方便交互的直观树状图，让我们知道我们所构建包中真正引入的内容"><a href="#webpack-bundle-analyzer将打包后的内容束展示为方便交互的直观树状图，让我们知道我们所构建包中真正引入的内容" class="headerlink" title="webpack-bundle-analyzer将打包后的内容束展示为方便交互的直观树状图，让我们知道我们所构建包中真正引入的内容"></a>webpack-bundle-analyzer将打包后的内容束展示为方便交互的直观树状图，让我们知道我们所构建包中真正引入的内容</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm i -D webpack-bunble-analyzer</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/hsonzhou95/blogImg/master/webpack/carbon-6.png?token=AMCTPY7JQYAYZ76Y4J7UWAC6AXFUI" alt="avtvor"></p>
<h5 id="接下来在package-json里配置启动命令"><a href="#接下来在package-json里配置启动命令" class="headerlink" title="接下来在package.json里配置启动命令"></a>接下来在package.json里配置启动命令</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;analyz&quot;: &quot;NODE_ENV=production npm_config_report=true npm run build&quot;</span><br></pre></td></tr></table></figure>

<h5 id="windows请安装npm-i-D-cross-env"><a href="#windows请安装npm-i-D-cross-env" class="headerlink" title="windows请安装npm i -D cross-env"></a>windows请安装npm i -D cross-env</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;analyz&quot;: &quot;cross-env NODE_ENV=production npm_config_report=true npm run build&quot;</span><br></pre></td></tr></table></figure>

<h5 id="接下来npm-run-analyz浏览器会自动打开文件依赖图的网页"><a href="#接下来npm-run-analyz浏览器会自动打开文件依赖图的网页" class="headerlink" title="接下来npm run analyz浏览器会自动打开文件依赖图的网页"></a>接下来npm run analyz浏览器会自动打开文件依赖图的网页</h5><h5 id="2-5-2-3externals"><a href="#2-5-2-3externals" class="headerlink" title="2.5.2.3externals"></a>2.5.2.3externals</h5><blockquote>
<p>按照官方文档的解释，如果我们想引用一个库，但是又不想让<code>webpack</code>打包，并且又不影响我们在程序中以<code>CMD、AMD</code>或者<code>window/global</code>全局等方式进行使用，那就可以通过配置<code>Externals</code>。这个功能主要是用在创建一个库的时候用的，但是也可以在我们项目开发中充分使用 <code>Externals</code>的方式，我们将这些不需要打包的静态资源从构建逻辑中剔除出去，而使用 <code>CDN</code> 的方式，去引用它们。</p>
</blockquote>
<h5 id="有时我们希望我们通过script引入的库，如用CDN的方式引入的jquery，我们在使用时，依旧用require的方式来使用，但是却不希望webpack将它又编译进文件中。这里官网案例已经足够清晰明了，大家有兴趣可以点击了解"><a href="#有时我们希望我们通过script引入的库，如用CDN的方式引入的jquery，我们在使用时，依旧用require的方式来使用，但是却不希望webpack将它又编译进文件中。这里官网案例已经足够清晰明了，大家有兴趣可以点击了解" class="headerlink" title="有时我们希望我们通过script引入的库，如用CDN的方式引入的jquery，我们在使用时，依旧用require的方式来使用，但是却不希望webpack将它又编译进文件中。这里官网案例已经足够清晰明了，大家有兴趣可以点击了解"></a>有时我们希望我们通过<code>script</code>引入的库，如用CDN的方式引入的<code>jquery</code>，我们在使用时，依旧用<code>require</code>的方式来使用，但是却不希望<code>webpack</code>将它又编译进文件中。这里官网案例已经足够清晰明了，大家有兴趣可以点击了解</h5><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span></span></span><br><span class="line"><span class="tag">  <span class="attr">src</span>=<span class="string">"https://code.jquery.com/jquery-3.1.0.js"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">integrity</span>=<span class="string">"sha256-slogkvB1K3VOkzAI8QITxV3VzpOnkeNVsKvtkYLMjfk="</span></span></span><br><span class="line"><span class="tag">  <span class="attr">crossorigin</span>=<span class="string">"anonymous"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  externals: &#123;</span><br><span class="line">    jquery: <span class="string">'jQuery'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import $ from &apos;jquery&apos;;</span><br><span class="line">$(&apos;.my-element&apos;).animate(/* ... */);</span><br></pre></td></tr></table></figure>

<h3 id="2-5-2-3-Tree-shaking"><a href="#2-5-2-3-Tree-shaking" class="headerlink" title="2.5.2.3 Tree-shaking"></a>2.5.2.3 Tree-shaking</h3><blockquote>
<p>这里单独提一下<code>tree-shaking</code>,是因为这里有个坑。<code>tree-shaking</code>的主要作用是用来清除代码中无用的部分。目前在<code>webpack4</code> 我们设置<code>mode</code>为<code>production</code>的时候已经自动开启了<code>tree-shaking</code>。但是要想使其生效，生成的代码必须是ES6模块。不能使用其它类型的模块如<code>CommonJS</code>之流。如果使用<code>Babel</code>的话，这里有一个小问题，因为<code>Babel</code>的预案（preset）默认会将任何模块类型都转译成<code>CommonJS</code>类型。修正这个问题也很简单，在<code>.babelrc</code>文件或在<code>webpack.config.js</code>文件中设置<code>modules： false</code>就好了</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// .babelrc</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"presets"</span>: [</span><br><span class="line">    [<span class="string">"@babel/preset-env"</span>,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="string">"modules"</span>: <span class="literal">false</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="或者"><a href="#或者" class="headerlink" title="或者"></a>或者</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">        &#123;</span><br><span class="line">            test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">            use: &#123;</span><br><span class="line">                loader: <span class="string">'babel-loader'</span>,</span><br><span class="line">                options: &#123;</span><br><span class="line">                    presets: [<span class="string">'@babel/preset-env'</span>, &#123; <span class="attr">modules</span>: <span class="literal">false</span> &#125;]</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;，</span><br><span class="line">            exclude: <span class="regexp">/(node_modules)/</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3手写webpack系列"><a href="#3手写webpack系列" class="headerlink" title="3手写webpack系列"></a>3手写webpack系列</h3><blockquote>
<p>经历过上面两个部分，我们已经可以熟练的运用相关的loader和plugin对我们的代码进行转换、解析。接下来我们自己手动实现loader与plugin，使其在平时的开发中获得更多的乐趣。</p>
</blockquote>
<h3 id="3-1手写webpack-loader"><a href="#3-1手写webpack-loader" class="headerlink" title="3.1手写webpack loader"></a>3.1手写webpack loader</h3><blockquote>
<p><code>loader</code>从本质上来说其实就是一个<code>node</code>模块。相当于一台榨汁机<code>(loader)</code>将相关类型的文件代码<code>(code)</code>给它。根据我们设置的规则，经过它的一系列加工后还给我们加工好的果汁<code>(code)</code>。</p>
</blockquote>
<h5 id="loader编写原则"><a href="#loader编写原则" class="headerlink" title="loader编写原则"></a>loader编写原则</h5><ul>
<li>单一原则: 每个 <code>Loader</code> 只做一件事；</li>
<li>链式调用: <code>Webpack</code> 会按顺序链式调用每个 <code>Loader</code>；</li>
<li>统一原则: 遵循 <code>Webpack</code> 制定的设计规则和结构，输入与输出均为字符串，各个 <code>Loader</code> 完全独立，即插即用；</li>
</ul>
<h5 id="在日常开发环境中，为了方便调试我们往往会加入许多console打印。但是我们不希望在生产环境中存在打印的值。那么这里我们自己实现一个loader去除代码中的console"><a href="#在日常开发环境中，为了方便调试我们往往会加入许多console打印。但是我们不希望在生产环境中存在打印的值。那么这里我们自己实现一个loader去除代码中的console" class="headerlink" title="在日常开发环境中，为了方便调试我们往往会加入许多console打印。但是我们不希望在生产环境中存在打印的值。那么这里我们自己实现一个loader去除代码中的console"></a>在日常开发环境中，为了方便调试我们往往会加入许多<code>console</code>打印。但是我们不希望在生产环境中存在打印的值。那么这里我们自己实现一个<code>loader</code>去除代码中的<code>console</code></h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">知识点普及之AST。AST通俗的来说，假设我们有一个文件a.js,我们对a.js里面的1000行进行一些操作处理,比如为所有的await 增加try catch,以及其他操作，但是a.js里面的代码本质上来说就是一堆字符串。那我们怎么办呢，那就是转换为带标记信息的对象(抽象语法树)我们方便进行增删改查。这个带标记的对象(抽象语法树)就是AST。这里推荐一篇不错的AST文章 AST快速入门</span><br><span class="line">https://segmentfault.com/a/1190000016231512</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm i -D @babel/parser @babel/traverse @babel/generator @babel/types</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@babel/parser` 将源代码解析成 `AST</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>@babel/traverse</code> 对<code>AST</code>节点进行递归遍历，生成一个便于操作、转换的<code>path</code>对象</p>
</li>
<li><p><code>@babel/generator</code> 将<code>AST</code>解码生成<code>js</code>代码</p>
</li>
<li><p><code>@babel/types</code>通过该模块对具体的<code>AST</code>节点进行进行增、删、改、查</p>
</li>
</ul>
<h5 id="新建drop-console-js"><a href="#新建drop-console-js" class="headerlink" title="新建drop-console.js"></a>新建drop-console.js</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> parser = <span class="built_in">require</span>(<span class="string">'@babel/parser'</span>)</span><br><span class="line"><span class="keyword">const</span> traverse = <span class="built_in">require</span>(<span class="string">'@babel/traverse'</span>).default</span><br><span class="line"><span class="keyword">const</span> generator = <span class="built_in">require</span>(<span class="string">'@babel/generator'</span>).default</span><br><span class="line"><span class="keyword">const</span> t = <span class="built_in">require</span>(<span class="string">'@babel/types'</span>)</span><br><span class="line"><span class="built_in">module</span>.exports=<span class="function"><span class="keyword">function</span>(<span class="params">source</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">const</span> ast = parser.parse(source,&#123; <span class="attr">sourceType</span>: <span class="string">'module'</span>&#125;)</span><br><span class="line">  traverse(ast,&#123;</span><br><span class="line">    CallExpression(path)&#123; </span><br><span class="line">      <span class="keyword">if</span>(t.isMemberExpression(path.node.callee) &amp;&amp; t.isIdentifier(path.node.callee.object, &#123;<span class="attr">name</span>: <span class="string">"console"</span>&#125;))&#123;</span><br><span class="line">        path.remove()</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">const</span> output = generator(ast, &#123;&#125;, source);</span><br><span class="line">  <span class="keyword">return</span> output.code</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  mode:<span class="string">'development'</span>,</span><br><span class="line">  entry:path.resolve(__dirname,<span class="string">'index.js'</span>),</span><br><span class="line">  output:&#123;</span><br><span class="line">    filename:<span class="string">'[name].[contenthash].js'</span>,</span><br><span class="line">    path:path.resolve(__dirname,<span class="string">'dist'</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="built_in">module</span>:&#123;</span><br><span class="line">    rules:[&#123;</span><br><span class="line">      test:<span class="regexp">/\.js$/</span>,</span><br><span class="line">      use:path.resolve(__dirname,<span class="string">'drop-console.js'</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>实际上在<code>webpack4</code>中已经集成了去除<code>console</code>功能，在<code>minimizer</code>中可配置 <a href="https://webpack.js.org/plugins/terser-webpack-plugin/#root" target="_blank" rel="noopener">去除console</a></p>
</blockquote>
<h5 id="附上官网-如何编写一个loader"><a href="#附上官网-如何编写一个loader" class="headerlink" title="附上官网 如何编写一个loader"></a>附上官网 <a href="https://webpack.docschina.org/contribute/writing-a-loader/" target="_blank" rel="noopener">如何编写一个loader</a></h5><h3 id="3-2手写webpack-plugin"><a href="#3-2手写webpack-plugin" class="headerlink" title="3.2手写webpack plugin"></a>3.2手写webpack plugin</h3><blockquote>
<p>在 <code>Webpack</code> 运行的生命周期中会广播出许多事件，<code>Plugin</code> 可以监听这些事件，在合适的时机通过<code>Webpack</code>提供的<code>API</code>改变输出结果。通俗来说：一盘美味的 <a href="https://www.meishij.net/zuofa/yandouchaojidan.html" target="_blank" rel="noopener">盐豆炒鸡蛋</a> 需要经历烧油 炒制 调味到最后的装盘等过程，而<code>plugin</code>相当于可以监控每个环节并进行操作，比如可以写一个少放胡椒粉<code>plugin</code>,监控<code>webpack</code>暴露出的生命周期事件(调味)，在调味的时候执行少放胡椒粉操作。那么它与<code>loader</code>的区别是什么呢？上面我们也提到了<code>loader</code>的单一原则,<code>loader</code>只能一件事，比如说<code>less-loader</code>,只能解析<code>less</code>文件，<code>plugin</code>则是针对整个流程执行广泛的任务。</p>
</blockquote>
<h5 id="一个基本的plugin插件结构如下"><a href="#一个基本的plugin插件结构如下" class="headerlink" title="一个基本的plugin插件结构如下"></a>一个基本的plugin插件结构如下</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">firstPlugin</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> (options) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'firstPlugin options'</span>, options)</span><br><span class="line">  &#125;</span><br><span class="line">  apply (compiler) &#123;</span><br><span class="line">    compiler.plugin(<span class="string">'done'</span>, compilation =&gt; &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'firstPlugin'</span>)</span><br><span class="line">    ))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = firstPlugin</span><br></pre></td></tr></table></figure>

<blockquote>
<p>compiler/compilation是什么？</p>
</blockquote>
<ul>
<li><code>compiler</code> 对象包含了<code>Webpack</code> 环境所有的的配置信息。这个对象在启动 <code>webpack</code> 时被一次性建立，并配置好所有可操作的设置，包括 <code>options</code>，<code>loader</code> 和 <code>plugin</code>。当在 <code>webpack</code> 环境中应用一个插件时，插件将收到此 <code>compiler</code> 对象的引用。可以使用它来访问 <code>webpack</code> 的主环境。</li>
<li><code>compilation</code>对象包含了当前的模块资源、编译生成资源、变化的文件等。当运行<code>webpack</code> 开发环境中间件时，每当检测到一个文件变化，就会创建一个新的 <code>compilation</code>，从而生成一组新的编译资源。<code>compilation</code> 对象也提供了很多关键时机的回调，以供插件做自定义处理时选择使用。</li>
</ul>
<h4 id="compiler和-compilation的区别在于"><a href="#compiler和-compilation的区别在于" class="headerlink" title="compiler和 compilation的区别在于"></a><strong>compiler和 compilation的区别在于</strong></h4><ul>
<li>compiler代表了整个webpack从启动到关闭的生命周期，而compilation 只是代表了一次新的编译过程</li>
<li>compiler和compilation暴露出许多钩子，我们可以根据实际需求的场景进行自定义处理</li>
</ul>
<h5 id="compiler钩子文档"><a href="#compiler钩子文档" class="headerlink" title="compiler钩子文档"></a><a href="https://www.webpackjs.com/api/compiler-hooks/" target="_blank" rel="noopener">compiler钩子文档</a></h5><h5 id="compilation钩子文档"><a href="#compilation钩子文档" class="headerlink" title="compilation钩子文档"></a><a href="https://www.webpackjs.com/api/compilation-hooks/" target="_blank" rel="noopener">compilation钩子文档</a></h5><h5 id="下面我们手动开发一个简单的需求-在生成打包文件之前自动生成一个关于打包出文件的大小信息"><a href="#下面我们手动开发一个简单的需求-在生成打包文件之前自动生成一个关于打包出文件的大小信息" class="headerlink" title="下面我们手动开发一个简单的需求,在生成打包文件之前自动生成一个关于打包出文件的大小信息"></a>下面我们手动开发一个简单的需求,在生成打包文件之前自动生成一个关于打包出文件的大小信息</h5><h5 id="新建一个webpack-firstPlugin-js"><a href="#新建一个webpack-firstPlugin-js" class="headerlink" title="新建一个webpack-firstPlugin.js"></a>新建一个<code>webpack-firstPlugin.js</code></h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">firstPlugin</span></span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(options)&#123;</span><br><span class="line">    <span class="keyword">this</span>.options = options</span><br><span class="line">  &#125;</span><br><span class="line">  apply(compiler)&#123;</span><br><span class="line">    compiler.plugin(<span class="string">'emit'</span>,(compilation,callback)=&gt;&#123;</span><br><span class="line">      <span class="keyword">let</span> str = <span class="string">''</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> filename <span class="keyword">in</span> compilation.assets)&#123;</span><br><span class="line">        str += <span class="string">`文件:<span class="subst">$&#123;filename&#125;</span>  大小<span class="subst">$&#123;compilation.assets[filename][<span class="string">'size'</span>]()&#125;</span>\n`</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 通过compilation.assets可以获取打包后静态资源信息，同样也可以写入资源</span></span><br><span class="line">      compilation.assets[<span class="string">'fileSize.md'</span>] = &#123;</span><br><span class="line">        source:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">          <span class="keyword">return</span> str</span><br><span class="line">        &#125;,</span><br><span class="line">        size:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">          <span class="keyword">return</span> str.length</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      callback()</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = firstPlugin</span><br></pre></td></tr></table></figure>

<h5 id="如何使用-1"><a href="#如何使用-1" class="headerlink" title="如何使用"></a>如何使用</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const path = require(&apos;path&apos;)</span><br><span class="line">const firstPlugin = require(&apos;webpack-firstPlugin.js&apos;)</span><br><span class="line">module.exports = &#123;</span><br><span class="line">    // 省略其他代码</span><br><span class="line">    plugins:[</span><br><span class="line">        new firstPlugin()</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">执行 npm run build即可看到在dist文件夹中生成了一个包含打包文件信息的fileSize.md</span><br></pre></td></tr></table></figure>

<blockquote>
<p>上面两个<code>loader</code>与<code>plugin</code>案例只是一个引导，实际开发需求中的<code>loader</code>与<code>plugin</code>要考虑的方面很多，建议大家自己多动手尝试一下。</p>
</blockquote>
<h5 id="附上官网-如何编写一个plugin"><a href="#附上官网-如何编写一个plugin" class="headerlink" title="附上官网 如何编写一个plugin"></a>附上官网 <a href="https://www.webpackjs.com/contribute/writing-a-plugin/" target="_blank" rel="noopener">如何编写一个plugin</a></h5><h3 id="原文链接：https-juejin-im-post-5de87444518825124c50cd36"><a href="#原文链接：https-juejin-im-post-5de87444518825124c50cd36" class="headerlink" title="原文链接：https://juejin.im/post/5de87444518825124c50cd36"></a>原文链接：<a href="https://juejin.im/post/5de87444518825124c50cd36" target="_blank" rel="noopener">https://juejin.im/post/5de87444518825124c50cd36</a></h3><h3 id="参考文献：https-www-webpackjs-com"><a href="#参考文献：https-www-webpackjs-com" class="headerlink" title="参考文献：https://www.webpackjs.com/"></a>参考文献：<a href="https://www.webpackjs.com/" target="_blank" rel="noopener">https://www.webpackjs.com/</a></h3>]]></content>
      <categories>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>响应式</tag>
        <tag>样式</tag>
      </tags>
  </entry>
  <entry>
    <title>一行CSS代码搞定响应式布局</title>
    <url>/2019/12/24/%E4%B8%80%E8%A1%8CCSS%E4%BB%A3%E7%A0%81%E6%90%9E%E5%AE%9A%E5%93%8D%E5%BA%94%E5%BC%8F%E5%B8%83%E5%B1%80/</url>
    <content><![CDATA[<h2 id="一行CSS代码搞定响应式布局"><a href="#一行CSS代码搞定响应式布局" class="headerlink" title="一行CSS代码搞定响应式布局"></a>一行CSS代码搞定响应式布局</h2><h4 id="在这篇文章中，我将教你如何使用-CSS-Grid-来创建一个超酷的图像网格图，它将根据屏幕的宽度来改变列的数量。最精彩的地方在于：所有的响应特性被添加到了一行-css-代码中。这意味着我们不必将-HTML-与丑陋的类名-如col-sm-4-col-md-8-混杂在一起，也不必为每个屏幕创建媒体查询。"><a href="#在这篇文章中，我将教你如何使用-CSS-Grid-来创建一个超酷的图像网格图，它将根据屏幕的宽度来改变列的数量。最精彩的地方在于：所有的响应特性被添加到了一行-css-代码中。这意味着我们不必将-HTML-与丑陋的类名-如col-sm-4-col-md-8-混杂在一起，也不必为每个屏幕创建媒体查询。" class="headerlink" title="在这篇文章中，我将教你如何使用 CSS Grid 来创建一个超酷的图像网格图，它将根据屏幕的宽度来改变列的数量。最精彩的地方在于：所有的响应特性被添加到了一行 css 代码中。这意味着我们不必将 HTML 与丑陋的类名(如col-sm-4, col-md-8)混杂在一起，也不必为每个屏幕创建媒体查询。"></a>在这篇文章中，我将教你如何使用 CSS Grid 来创建一个超酷的图像网格图，它将根据屏幕的宽度来改变列的数量。最精彩的地方在于：所有的响应特性被添加到了一行 css 代码中。这意味着我们不必将 HTML 与丑陋的类名(如col-sm-4, col-md-8)混杂在一起，也不必为每个屏幕创建媒体查询。</h4><a id="more"></a>
<h3 id="下面是我们初始化网格的外观："><a href="#下面是我们初始化网格的外观：" class="headerlink" title="下面是我们初始化网格的外观："></a>下面是我们初始化网格的外观：</h3><p><img src="https://raw.githubusercontent.com/hsonzhou95/blogImg/master/responseType/initCss1.png?token=AMCTPY2FVPFKQUKNA4QKILS57HAYS" alt="avator"></p>
<h3 id="HTML代码："><a href="#HTML代码：" class="headerlink" title="HTML代码："></a>HTML代码：</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"item1"</span>&gt;</span>1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"item2"</span>&gt;</span>2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"item3"</span>&gt;</span>3<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"item4"</span>&gt;</span>4<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"item5"</span>&gt;</span>5<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"item6"</span>&gt;</span>6<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="CSS代码"><a href="#CSS代码" class="headerlink" title="CSS代码"></a>CSS代码</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: grid;</span><br><span class="line">    <span class="attribute">grid-template-columns</span>: <span class="number">100px</span> <span class="number">100px</span> <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">grid-template-rows</span>: <span class="number">50px</span> <span class="number">50px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.item1</span> &#123;</span><br><span class="line">    <span class="attribute">background</span>: darkblue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.item2</span> &#123;</span><br><span class="line">    <span class="attribute">background</span>: darkgoldenrod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.item3</span> &#123;</span><br><span class="line">    <span class="attribute">background</span>: darkmagenta;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.item4</span> &#123;</span><br><span class="line">    <span class="attribute">background</span>: darkorange;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.item5</span> &#123;</span><br><span class="line">    <span class="attribute">background</span>: deeppink;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.item6</span> &#123;</span><br><span class="line">    <span class="attribute">background</span>: forestgreen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="如果这段代码让你感到困惑，我建议你去好好这篇文章https-www-freecodecamp-org-news-learn-css-grid-in-5-minutes-f582e87b1228-教程，其中就详细的解释了布局的基础知识，让我们让列开始具有自适应特性吧。"><a href="#如果这段代码让你感到困惑，我建议你去好好这篇文章https-www-freecodecamp-org-news-learn-css-grid-in-5-minutes-f582e87b1228-教程，其中就详细的解释了布局的基础知识，让我们让列开始具有自适应特性吧。" class="headerlink" title="如果这段代码让你感到困惑，我建议你去好好这篇文章https://www.freecodecamp.org/news/learn-css-grid-in-5-minutes-f582e87b1228/教程，其中就详细的解释了布局的基础知识，让我们让列开始具有自适应特性吧。"></a>如果这段代码让你感到困惑，我建议你去好好这篇文章<a href="https://www.freecodecamp.org/news/learn-css-grid-in-5-minutes-f582e87b1228/教程，其中就详细的解释了布局的基础知识，让我们让列开始具有自适应特性吧。" target="_blank" rel="noopener">https://www.freecodecamp.org/news/learn-css-grid-in-5-minutes-f582e87b1228/教程，其中就详细的解释了布局的基础知识，让我们让列开始具有自适应特性吧。</a></h5><h3 id="基础响应单位：fraction"><a href="#基础响应单位：fraction" class="headerlink" title="基础响应单位：fraction"></a>基础响应单位：fraction</h3><blockquote>
<p>CSS栅格布局带来了一个全新的值：fraction单位，fraction单位通常简写为fr,他允许你根据需要将容器拆分为多个块。</p>
</blockquote>
<h5 id="让我们将每一列更改为一个fraction单位宽："><a href="#让我们将每一列更改为一个fraction单位宽：" class="headerlink" title="让我们将每一列更改为一个fraction单位宽："></a>让我们将每一列更改为一个fraction单位宽：</h5><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: grid;</span><br><span class="line">    <span class="attribute">grid-template-columns</span>: <span class="number">1</span>fr <span class="number">1</span>fr <span class="number">1</span>fr;</span><br><span class="line">    <span class="attribute">grid-template-rows</span>: <span class="number">50px</span> <span class="number">50px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="结果是栅格布局将会把整个宽度分为三个fraction-每列占据一个fraction单位，效果如下："><a href="#结果是栅格布局将会把整个宽度分为三个fraction-每列占据一个fraction单位，效果如下：" class="headerlink" title="结果是栅格布局将会把整个宽度分为三个fraction,每列占据一个fraction单位，效果如下："></a>结果是栅格布局将会把整个宽度分为三个fraction,每列占据一个fraction单位，效果如下：</h5><p><img src="https://raw.githubusercontent.com/hsonzhou95/blogImg/master/responseType/initCss2.png?token=AMCTPYYBWEAU4YFLDSAVXGC57HAFC" alt="avator"></p>
<h5 id="如果我们将grid-template-columns的值更改为1fr-2fr-1fr-，第二列的宽度将会是其它两列的两倍。总宽现在是四个-fraction-单位，第二列占据两个-fraction-单位，其它列各占一个-fraction。效果如下："><a href="#如果我们将grid-template-columns的值更改为1fr-2fr-1fr-，第二列的宽度将会是其它两列的两倍。总宽现在是四个-fraction-单位，第二列占据两个-fraction-单位，其它列各占一个-fraction。效果如下：" class="headerlink" title="如果我们将grid-template-columns的值更改为1fr 2fr 1fr,，第二列的宽度将会是其它两列的两倍。总宽现在是四个 fraction 单位，第二列占据两个 fraction 单位，其它列各占一个 fraction。效果如下："></a>如果我们将grid-template-columns的值更改为1fr 2fr 1fr,，第二列的宽度将会是其它两列的两倍。总宽现在是四个 fraction 单位，第二列占据两个 fraction 单位，其它列各占一个 fraction。效果如下：</h5><p>![avator](<a href="https://raw.githubusercontent.com/hsonzhou95/blogImg/master/responseType/initCss3.png?token=AMCTPYYIQIMVBBBMDW4OPWC57HAHW&quot;" target="_blank" rel="noopener">https://raw.githubusercontent.com/hsonzhou95/blogImg/master/responseType/initCss3.png?token=AMCTPYYIQIMVBBBMDW4OPWC57HAHW&quot;</a> alt=”avator”)</p>
<h5 id="总的来说，fraction单位值将使你可以很容易的更改列的宽度"><a href="#总的来说，fraction单位值将使你可以很容易的更改列的宽度" class="headerlink" title="总的来说，fraction单位值将使你可以很容易的更改列的宽度"></a>总的来说，fraction单位值将使你可以很容易的更改列的宽度</h5><h3 id="高级响应"><a href="#高级响应" class="headerlink" title="高级响应"></a>高级响应</h3><h5 id="然而，上面列子并没有给出我们想要的响应性，因为网格总是三列宽。我们希望网格能根据容器的宽度改变列的数量。要做到这一点，你必须学习如下三个概念："><a href="#然而，上面列子并没有给出我们想要的响应性，因为网格总是三列宽。我们希望网格能根据容器的宽度改变列的数量。要做到这一点，你必须学习如下三个概念：" class="headerlink" title="然而，上面列子并没有给出我们想要的响应性，因为网格总是三列宽。我们希望网格能根据容器的宽度改变列的数量。要做到这一点，你必须学习如下三个概念："></a>然而，上面列子并没有给出我们想要的响应性，因为网格总是三列宽。我们希望网格能根据容器的宽度改变列的数量。要做到这一点，你必须学习如下三个概念：</h5><h4 id="repeat"><a href="#repeat" class="headerlink" title="repeat()"></a>repeat()</h4><h5 id="首先我们学校repeat-函数。这是一个强大的指定列和行的方法。让我们使用repeat-函数来更改网格："><a href="#首先我们学校repeat-函数。这是一个强大的指定列和行的方法。让我们使用repeat-函数来更改网格：" class="headerlink" title="首先我们学校repeat()函数。这是一个强大的指定列和行的方法。让我们使用repeat()函数来更改网格："></a>首先我们学校repeat()函数。这是一个强大的指定列和行的方法。让我们使用repeat()函数来更改网格：</h5><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: grid;</span><br><span class="line">    <span class="attribute">grid-template-columns</span>: <span class="built_in">repeat</span>(3, 100px);</span><br><span class="line">    <span class="attribute">grid-template-rows</span>: <span class="built_in">repeat</span>(2, 50px);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="在上面代码中，repeat-3-100px-等于100px-100px-100px。第一个参数指定行与列的数量，第二个参数指定它们的宽度，因此它将为我们提供与开始时完全相同的布局："><a href="#在上面代码中，repeat-3-100px-等于100px-100px-100px。第一个参数指定行与列的数量，第二个参数指定它们的宽度，因此它将为我们提供与开始时完全相同的布局：" class="headerlink" title="在上面代码中，repeat(3, 100px)等于100px 100px 100px。第一个参数指定行与列的数量，第二个参数指定它们的宽度，因此它将为我们提供与开始时完全相同的布局："></a>在上面代码中，repeat(3, 100px)等于100px 100px 100px。第一个参数指定行与列的数量，第二个参数指定它们的宽度，因此它将为我们提供与开始时完全相同的布局：</h5><img src="https://raw.githubusercontent.com/hsonzhou95/blogImg/master/responseType/initCss4.png?token=AMCTPY6M4IIU2XMAJL5H4T257HAL6" />

<h4 id="auto-fit"><a href="#auto-fit" class="headerlink" title="auto-fit"></a>auto-fit</h4><h5 id="然后是auto-fit。让我们跳过固定数量的列，将3替换为自适应数量："><a href="#然后是auto-fit。让我们跳过固定数量的列，将3替换为自适应数量：" class="headerlink" title="然后是auto-fit。让我们跳过固定数量的列，将3替换为自适应数量："></a>然后是auto-fit。让我们跳过固定数量的列，将3替换为自适应数量：</h5><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: grid;</span><br><span class="line">    <span class="attribute">grid-gap</span>: <span class="number">5px</span>;</span><br><span class="line">    <span class="attribute">grid-template-columns</span>: <span class="built_in">repeat</span>(auto-fit, 100px);</span><br><span class="line">    <span class="attribute">grid-template-rows</span>: <span class="built_in">repeat</span>(2, 100px);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="效果如下："><a href="#效果如下：" class="headerlink" title="效果如下："></a>效果如下：</h5><p><img src="https://raw.githubusercontent.com/hsonzhou95/blogImg/master/responseType/initCss5.png?token=AMCTPY6WRDICC4GA4N4XWTK57HAOG" alt="avator"></p>
<h5 id="现在，栅格将会根据容器的宽度调整其数量。它会尝试在容器中容纳尽可能多的-100px-宽的列。但如果我们将所有列硬写为-100px，我们将永远没法获得所需的弹性，因为它们很难填充整个宽度。正如你在上图看到的，网格通常在右侧留有空白。"><a href="#现在，栅格将会根据容器的宽度调整其数量。它会尝试在容器中容纳尽可能多的-100px-宽的列。但如果我们将所有列硬写为-100px，我们将永远没法获得所需的弹性，因为它们很难填充整个宽度。正如你在上图看到的，网格通常在右侧留有空白。" class="headerlink" title="现在，栅格将会根据容器的宽度调整其数量。它会尝试在容器中容纳尽可能多的 100px 宽的列。但如果我们将所有列硬写为 100px，我们将永远没法获得所需的弹性，因为它们很难填充整个宽度。正如你在上图看到的，网格通常在右侧留有空白。"></a>现在，栅格将会根据容器的宽度调整其数量。它会尝试在容器中容纳尽可能多的 100px 宽的列。但如果我们将所有列硬写为 100px，我们将永远没法获得所需的弹性，因为它们很难填充整个宽度。正如你在上图看到的，网格通常在右侧留有空白。</h5><h4 id="minmax"><a href="#minmax" class="headerlink" title="minmax()"></a>minmax()</h4><h5 id="为了解决上述问题，我们需要minmax-。我们将100px替换为minmax-100px-1fr-，代码如下："><a href="#为了解决上述问题，我们需要minmax-。我们将100px替换为minmax-100px-1fr-，代码如下：" class="headerlink" title="为了解决上述问题，我们需要minmax()。我们将100px替换为minmax(100px,1fr)，代码如下："></a>为了解决上述问题，我们需要minmax()。我们将100px替换为minmax(100px,1fr)，代码如下：</h5><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: grid;</span><br><span class="line">    <span class="attribute">grid-gap</span>: <span class="number">5px</span>;</span><br><span class="line">    <span class="attribute">grid-template-columns</span>: <span class="built_in">repeat</span>(auto-fit, minmax(100px, 1fr));</span><br><span class="line">    <span class="attribute">grid-template-rows</span>: <span class="built_in">repeat</span>(2, 100px);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>请注意，所以响应都发生在一行css代码中</p>
</blockquote>
<h5 id="效果如下：-1"><a href="#效果如下：-1" class="headerlink" title="效果如下："></a>效果如下：</h5><p><img src="https://raw.githubusercontent.com/hsonzhou95/blogImg/master/responseType/initCss6.png?token=AMCTPY33OBW6CTDFAT555AC57HAP2" alt="avator"></p>
<h5 id="正如你所见，效果完美，minmax-函数定义的范围大于或等于min，小于或等于max。"><a href="#正如你所见，效果完美，minmax-函数定义的范围大于或等于min，小于或等于max。" class="headerlink" title="正如你所见，效果完美，minmax()函数定义的范围大于或等于min，小于或等于max。"></a>正如你所见，效果完美，minmax()函数定义的范围大于或等于min，小于或等于max。</h5><h5 id="因此，现在每列将至少为100px。但如果有更多的可用空间，栅格布局将简单地将其均分给每列，因为这些列变成了-fraction-单位，而不是-100px。"><a href="#因此，现在每列将至少为100px。但如果有更多的可用空间，栅格布局将简单地将其均分给每列，因为这些列变成了-fraction-单位，而不是-100px。" class="headerlink" title="因此，现在每列将至少为100px。但如果有更多的可用空间，栅格布局将简单地将其均分给每列，因为这些列变成了 fraction 单位，而不是 100px。"></a>因此，现在每列将至少为100px。但如果有更多的可用空间，栅格布局将简单地将其均分给每列，因为这些列变成了 fraction 单位，而不是 100px。</h5><h5 id="到这里，我们就已经实现了响应式的布局，我们还可以在盒子里面添加你任何想要随之改变的内容，这里就不做过多的演示了。"><a href="#到这里，我们就已经实现了响应式的布局，我们还可以在盒子里面添加你任何想要随之改变的内容，这里就不做过多的演示了。" class="headerlink" title="到这里，我们就已经实现了响应式的布局，我们还可以在盒子里面添加你任何想要随之改变的内容，这里就不做过多的演示了。"></a>到这里，我们就已经实现了响应式的布局，我们还可以在盒子里面添加你任何想要随之改变的内容，这里就不做过多的演示了。</h5><h3 id="浏览器兼容性"><a href="#浏览器兼容性" class="headerlink" title="浏览器兼容性"></a>浏览器兼容性</h3><h5 id="在结束本文前，我提下浏览器支持情况，全球77-的网站将支持-CSS-Grid，而且比例还在逐步攀升。"><a href="#在结束本文前，我提下浏览器支持情况，全球77-的网站将支持-CSS-Grid，而且比例还在逐步攀升。" class="headerlink" title="在结束本文前，我提下浏览器支持情况，全球77%的网站将支持 CSS Grid，而且比例还在逐步攀升。"></a>在结束本文前，我提下浏览器支持情况，全球77%的网站将支持 CSS Grid，而且比例还在逐步攀升。</h5><h5 id="2018将是CSSS网格布局的元年。它将获得突破，并成为前端开发者的必备技能，像过去几年CSS-Flexbox布局发生的情况一样。"><a href="#2018将是CSSS网格布局的元年。它将获得突破，并成为前端开发者的必备技能，像过去几年CSS-Flexbox布局发生的情况一样。" class="headerlink" title="2018将是CSSS网格布局的元年。它将获得突破，并成为前端开发者的必备技能，像过去几年CSS Flexbox布局发生的情况一样。"></a>2018将是CSSS网格布局的元年。它将获得突破，并成为前端开发者的必备技能，像过去几年CSS Flexbox布局发生的情况一样。</h5><h3 id="来自：知乎，作者：icepy"><a href="#来自：知乎，作者：icepy" class="headerlink" title="来自：知乎，作者：icepy"></a>来自：知乎，作者：icepy</h3><h3 id="链接：https-zhuanlan-zhihu-com-p-69809343"><a href="#链接：https-zhuanlan-zhihu-com-p-69809343" class="headerlink" title="链接：https://zhuanlan.zhihu.com/p/69809343"></a>链接：<a href="https://zhuanlan.zhihu.com/p/69809343" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/69809343</a></h3><h3 id="原文作者：Per-Harald-Borgen"><a href="#原文作者：Per-Harald-Borgen" class="headerlink" title="原文作者：Per Harald Borgen"></a>原文作者：Per Harald Borgen</h3><h3 id="原文链接：https-medium-com-free-code-camp-how-to-make-your-html-responsive-by-adding-a-single-line-of-css-2a62de81e431"><a href="#原文链接：https-medium-com-free-code-camp-how-to-make-your-html-responsive-by-adding-a-single-line-of-css-2a62de81e431" class="headerlink" title="原文链接：https://medium.com/free-code-camp/how-to-make-your-html-responsive-by-adding-a-single-line-of-css-2a62de81e431"></a>原文链接：<a href="https://medium.com/free-code-camp/how-to-make-your-html-responsive-by-adding-a-single-line-of-css-2a62de81e431" target="_blank" rel="noopener">https://medium.com/free-code-camp/how-to-make-your-html-responsive-by-adding-a-single-line-of-css-2a62de81e431</a></h3>]]></content>
      <categories>
        <category>HTML5、CSS3</category>
      </categories>
      <tags>
        <tag>响应式</tag>
        <tag>样式</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue组件常见的六种通信方式</title>
    <url>/2019/12/14/Vue%E7%BB%84%E4%BB%B6%E5%B8%B8%E8%A7%81%E7%9A%84%E5%85%AD%E7%A7%8D%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="Vue组件常见的六种通信方式"><a href="#Vue组件常见的六种通信方式" class="headerlink" title="Vue组件常见的六种通信方式"></a>Vue组件常见的六种通信方式</h1><a id="more"></a>
<blockquote>
<p>Vue.js 组件实例的作用域是相互独立的，不同组件之间的数据不能互相访问，组件有父级组件、子级组件、兄弟组件，如何选择组件之间的通信方式？针对常用的 props、$emit/$on、vuex、$parent/$children、$attrs/$listeners、provide/inject 进行讲解，对比各自的区别以及使用场景。 </p>
</blockquote>
<h2 id="1-props"><a href="#1-props" class="headerlink" title="1.props"></a>1.props</h2><blockquote>
<p>子组件使用props 接收父组件传递的值，子组件通过 $emit ，让父组件接收事件，改变父组件的data里面的值； </p>
</blockquote>
<p>代码示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!--父组件--&gt;</span><br><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;title :title=&apos;title&apos; @change=&apos;changeHandle&apos;&gt;&lt;/title&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">	export default</span><br><span class="line">&#123;</span><br><span class="line">    data()&#123;</span><br><span class="line">        return&#123;</span><br><span class="line">            title:&apos;Hello&apos;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;,</span><br><span class="line">    components:&#123;</span><br><span class="line">        title</span><br><span class="line">    &#125;,</span><br><span class="line">    methods:&#123;</span><br><span class="line">        changeHandle(val)&#123;</span><br><span class="line">            this.title = val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;!--子组件--&gt;</span><br><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div @click=&apos;changeHandle&apos;&gt;&#123;&#123;title&#125;&#125;&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default</span><br><span class="line"> &#123;</span><br><span class="line">    props: &#123;        </span><br><span class="line">    title:String   </span><br><span class="line">&#125;,</span><br><span class="line">    methods:&#123;</span><br><span class="line">        changeHandle()&#123;</span><br><span class="line">            this.$emit(&apos;change&apos;, &apos;Hello Vue&apos;);        </span><br><span class="line">            &#125; </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>子组件通过事件向父组件传递值，父组件更改自己的数据，子组件接收更改后的值； </li>
</ul>
<h2 id="2-emit-on"><a href="#2-emit-on" class="headerlink" title="2. $emit/$on"></a>2. $emit/$on</h2><blockquote>
<p>通过Vue 的实例触发事件和监听事件，实现了跨级组件的通信； </p>
</blockquote>
<p>代码示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!--在Vue的原型链上添加$bus 属性，赋值为Vue实例--&gt;</span><br><span class="line">const EventBus = new Vue();</span><br><span class="line">Object.defineProperties(Vue.prototype, &#123;</span><br><span class="line">    $bus: &#123;</span><br><span class="line">        get() &#123;</span><br><span class="line">            return EventBus;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">window.globalVue = EventBus;</span><br><span class="line"></span><br><span class="line">&lt;!--使用--&gt;</span><br><span class="line">// 组件A</span><br><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div @click=&apos;changeHandle&apos;&gt;触发事件&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default </span><br><span class="line">&#123;</span><br><span class="line">    methods: </span><br><span class="line">	&#123;</span><br><span class="line">        changeHandle()&#123;</span><br><span class="line">            window.globalVue.$emit(&apos;change&apos;, &apos;456&apos;);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">// 组件 B</span><br><span class="line">&lt;template&gt;    </span><br><span class="line">	&lt;div&gt;监听事件&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default </span><br><span class="line">&#123;</span><br><span class="line">    mounted()&#123;</span><br><span class="line">        window.globalVue.$on(&apos;change&apos;, str =&gt; &#123; console.log(str);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>在组件B中监听固定的事件名，当A组件触发change事件后，监听到事件触发，触发事件时机不确定，一般在created 或 mounted 中监听事件； </li>
</ul>
<h2 id="3-Vuex"><a href="#3-Vuex" class="headerlink" title="3.Vuex"></a>3.Vuex</h2><blockquote>
<p>Vuex 是一个单向的数据流的状态管理模式，state 存放数据，当需要改变state 的数据时，只能通过 mutation 更改，如果有异步操作，可以使用 action，最终action 还是通过mutation 更改state 的数据 </p>
</blockquote>
<ul>
<li>Vue Components：Vue 组件，可以执行dispatch 方法触发action；</li>
<li>dispatch：组件触发action 的方法；</li>
<li>actions：负责接收组件触发的行为，可以在这里面调用commit()方法更改state中的数据；</li>
<li>commit：执行mutation的方法，commit(‘mutation 名称’)；</li>
<li>mutations：更改 state 数据的方法，只能进行同步操作；</li>
<li>state：存储数据的容器对象,即初始状态树；</li>
</ul>
<p>代码演示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;&#123;&#123;title&#125;&#125;&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">import &#123;mapState&#125; from &apos;vuex&apos;;</span><br><span class="line">export default </span><br><span class="line">&#123;</span><br><span class="line">    computed: &#123;        </span><br><span class="line">    ...mapState(&#123;</span><br><span class="line">    	title: state =&gt; state.title</span><br><span class="line">    	&#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h2 id="4-parent-children"><a href="#4-parent-children" class="headerlink" title="4. $parent/$children"></a>4. $parent/$children</h2><blockquote>
<p>$parent/$children 可以访问到父组件或子组件的实例，通过 $ref 也可以获取到子组件实例，可以访问子组件属性和方法； </p>
</blockquote>
<p>代码示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!--父组件A--&gt;</span><br><span class="line">&lt;template&gt;  </span><br><span class="line">    &lt;h1&gt;父组件&lt;/h1&gt;    </span><br><span class="line">    &lt;child ref=&apos;child&apos;&gt;&lt;/child&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default </span><br><span class="line">&#123;</span><br><span class="line">    components: &#123;</span><br><span class="line">        child    </span><br><span class="line">        &#125;,</span><br><span class="line">    mounted()&#123;</span><br><span class="line">        console.log(this.$children);</span><br><span class="line"> // 子组件实例数组</span><br><span class="line">        console.log(this.$refs.child);</span><br><span class="line"> // 子组件child实例</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;!--子组件child--&gt;</span><br><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;h1&gt;子组件&lt;/h1&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default</span><br><span class="line"> &#123;</span><br><span class="line">    mounted()&#123;</span><br><span class="line">        console.log(this.$parent); </span><br><span class="line">	// 父组件实例</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h2 id="5-attrs-listeners"><a href="#5-attrs-listeners" class="headerlink" title="5. $attrs/$listeners"></a>5. $attrs/$listeners</h2><blockquote>
<p>this.$attrs 包含了父作用域中不作为prop被识别的特性绑定(class和style除外)，解释就是，父组件传递了props ，但是子组件没有全部使用props 接收，没被子组件接收的那些props，在$attrs中就可以获取到；$listeners 即是包含了父作用域中的(不含.native修饰器的)v-on 事件监听器，可以使用 v-on=’$listeners’传入到内部组件；在跨级组件中传递属性和事件非常有用 </p>
</blockquote>
<p>代码示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!--顶级组件A--&gt;</span><br><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;h1&gt;顶级组件A&lt;/h1&gt;</span><br><span class="line">    &lt;!--子级组件B--&gt;</span><br><span class="line">    &lt;componentb data1=&apos;data1&apos;</span><br><span class="line">                data2=&apos;data2&apos; </span><br><span class="line">                @event1=&apos;handleEvent1&apos;</span><br><span class="line">                @event2=&apos;handleEvent2&apos;&gt;</span><br><span class="line">    &lt;/componentb&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default&#123;</span><br><span class="line">    data()&#123;</span><br><span class="line">    return&#123;</span><br><span class="line">            data1:&apos;data1&apos;,</span><br><span class="line">            data2:&apos;data2,</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;,</span><br><span class="line">    components:&#123;</span><br><span class="line">        componentb</span><br><span class="line">        </span><br><span class="line">    &#125;,</span><br><span class="line">    mounted() &#123;</span><br><span class="line">        handleEvent1()&#123;</span><br><span class="line">        console.log(&apos;子级组件触发的事件&apos;);</span><br><span class="line">        &#125;,</span><br><span class="line">        handleEvent2()&#123;</span><br><span class="line">           console.log(&apos;孙子级组件触发的事件&apos;);</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;!--子组件B--&gt;</span><br><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;h1&gt;子组件B&lt;/h1&gt;</span><br><span class="line">    data1的值：&#123;&#123;data1&#125;&#125;</span><br><span class="line">    &lt;componentc v-bind=&apos;$attrs&apos;</span><br><span class="line">                b-on=&apos;$listeners&apos;&gt;</span><br><span class="line">    &lt;/componentc&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default&#123;</span><br><span class="line">    props:&#123;</span><br><span class="line">        data1 </span><br><span class="line">// 这里只获取了父级传递的props 的data1属性</span><br><span class="line">&#125;,</span><br><span class="line">    components:&#123;</span><br><span class="line">        componentc</span><br><span class="line">        </span><br><span class="line">    &#125;,</span><br><span class="line">    mounted()&#123;</span><br><span class="line">        console.log(this.$attrs);</span><br><span class="line"> // 打印 &apos;data2&apos;&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--孙子组件c--&gt;</span><br><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;h1&gt;孙子组件c&lt;/h1&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default&#123;</span><br><span class="line">    props:&#123;</span><br><span class="line">    &apos;data2&apos;</span><br><span class="line">    &#125;,</span><br><span class="line">    mounted()&#123;</span><br><span class="line">    this.$emit(&apos;event2&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<h2 id="6-provide-inject"><a href="#6-provide-inject" class="headerlink" title="6. provide/inject"></a>6. provide/inject</h2><blockquote>
<p>祖先组件通过 provide 向子孙级组件提供一个对象或返回一个对象的函数，该对象包含可以注入子孙组件的属性。</p>
</blockquote>
<h3 id="Vue-不建议直接应用于程序代码中，主要是为高阶插件-组件库提供使用"><a href="#Vue-不建议直接应用于程序代码中，主要是为高阶插件-组件库提供使用" class="headerlink" title="Vue 不建议直接应用于程序代码中，主要是为高阶插件/组件库提供使用"></a>Vue 不建议直接应用于程序代码中，主要是为高阶插件/组件库提供使用</h3><p>代码示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!--祖先组件A--&gt;</span><br><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;h1&gt;祖先组件A&lt;/h1&gt;</span><br><span class="line">    &lt;componenta&gt;&lt;/componenta&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default&#123;</span><br><span class="line">    data()&#123;</span><br><span class="line">    return&#123;</span><br><span class="line">            name:&apos;祖先组件A&apos;</span><br><span class="line">        </span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    &#125;,</span><br><span class="line">    components:&#123;</span><br><span class="line">        componenta</span><br><span class="line">    &#125;,</span><br><span class="line">    provide()&#123;</span><br><span class="line">        return&#123;</span><br><span class="line">            &apos;father&apos;:this</span><br><span class="line">            </span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--子级组件A--&gt;</span><br><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;h1&gt;子级组件A&lt;/h1&gt;</span><br><span class="line">    &lt;componentb&gt;&lt;/componentb&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default&#123;</span><br><span class="line">    data()&#123;</span><br><span class="line">        return&#123;           </span><br><span class="line">            name:&apos;子级组件A&apos;</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">    &#125;,</span><br><span class="line">    components:&#123;</span><br><span class="line">        componentb</span><br><span class="line">    &#125;,</span><br><span class="line">    inject:[&apos;father&apos;],</span><br><span class="line">    mounted()&#123;</span><br><span class="line">        console.log(this.father.name);</span><br><span class="line"> // &apos;祖先组件A&apos;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--子孙级组件B--&gt;</span><br><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;h1&gt;子孙级组件B&lt;/h1&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default&#123;</span><br><span class="line">    data()&#123;</span><br><span class="line">        return&#123;</span><br><span class="line">            name:&apos;子孙级组件B&apos;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;,</span><br><span class="line">    inject:[&apos;father&apos;],</span><br><span class="line">    mounted()&#123;</span><br><span class="line">        console.log(this.father.name);</span><br><span class="line"> // &apos;祖先组件A&apos;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>需要注意的是 provide 和 inject 绑定并不是可响应的;这是刻意为之的。然而，如果你传入了一个可监听的对象，那么其对象的属性还是可响应的。</li>
</ul>
<p>比如下面这个例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!--祖先组件A--&gt;</span><br><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;h1 @clidk=&apos;changeName&apos;&gt;祖先组件A&lt;/h1&gt;</span><br><span class="line">    &lt;componenta&gt;&lt;/componenta&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default&#123;</span><br><span class="line">    data()&#123;</span><br><span class="line">        return&#123;</span><br><span class="line">            name:&apos;祖先组件A&apos;</span><br><span class="line">        &#125;;</span><br><span class="line">&#125;,</span><br><span class="line">    components:&#123;</span><br><span class="line">        componenta</span><br><span class="line">    &#125;,</span><br><span class="line">    provide()&#123;</span><br><span class="line">        return&#123;</span><br><span class="line">            father:&#123;</span><br><span class="line">                name:this.name</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;,</span><br><span class="line">    method:&#123;</span><br><span class="line">        changeName()&#123;</span><br><span class="line">            this.name =&apos;祖先组件A改变了值了&apos;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;!--子级组件A--&gt;</span><br><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;h1&gt;子级组件A&lt;/h1&gt;</span><br><span class="line">    父级组件name值：&#123;&#123;father.name&#125;&#125;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default&#123;</span><br><span class="line">    data()&#123;</span><br><span class="line">        return&#123;</span><br><span class="line">            name:&apos;子级组件A&apos;</span><br><span class="line">        &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">    components:</span><br><span class="line"> &#123;</span><br><span class="line">        componentb</span><br><span class="line">    &#125;,</span><br><span class="line">    inject:[&apos;father&apos;],</span><br><span class="line">    mounted()&#123;</span><br><span class="line">        console.log(this.father.name);</span><br><span class="line"> // &apos;祖先组件A&apos;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<h3 id="当父级组件触发了点击事件，将-name-值改变后，子级组件渲染的值并不会变化；"><a href="#当父级组件触发了点击事件，将-name-值改变后，子级组件渲染的值并不会变化；" class="headerlink" title="当父级组件触发了点击事件，将 name 值改变后，子级组件渲染的值并不会变化；"></a>当父级组件触发了点击事件，将 name 值改变后，子级组件渲染的值并不会变化；</h3><p>解决办法：</p>
<ul>
<li>祖先级组件提供子级的实例，在子孙级组件注入依赖，这样子孙级组件就可以访问到祖先级组件的属性，缺点是这个提供的实例挂了很多无用的属性和方法；</li>
<li>使用 Vue2.6 的Vue.observable 方法；</li>
</ul>
<p>代码示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!--祖先组件A--&gt;</span><br><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;h1 @clidk=&apos;changeName&apos;&gt;祖先组件A&lt;/h1&gt;</span><br><span class="line">    &lt;componenta&gt;&lt;/componenta&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default&#123;</span><br><span class="line">    data()&#123;</span><br><span class="line">        return&#123;</span><br><span class="line">            name:&apos;&apos;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;,</span><br><span class="line">    components:&#123;</span><br><span class="line">        componenta</span><br><span class="line">    &#125;,</span><br><span class="line">    provide()&#123;</span><br><span class="line">        return&#123;</span><br><span class="line">            father:&#123;</span><br><span class="line">                name:Vue.observable(&#123;</span><br><span class="line">                    name:&apos;祖先组件A&apos;</span><br><span class="line">                &#125;)</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;,</span><br><span class="line">    method:&#123;</span><br><span class="line">        changeName()&#123;</span><br><span class="line">            this.name =&apos;祖先组件A改变了值了&apos;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;!--子级组件A--&gt;</span><br><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;h1&gt;子级组件A&lt;/h1&gt;</span><br><span class="line">    父级组件name值：&#123;&#123;father.name&#125;&#125;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default&#123;</span><br><span class="line">    data()&#123;</span><br><span class="line">        return&#123;</span><br><span class="line">            name:&apos;子级组件A&apos;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;,</span><br><span class="line">    components:&#123;</span><br><span class="line">        componentb</span><br><span class="line">    &#125;,</span><br><span class="line">    inject:[&apos;father&apos;],</span><br><span class="line">    mounted()&#123;</span><br><span class="line">        console.log(this.father.name);</span><br><span class="line"> // &apos;祖先组件A&apos;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>当祖先级组件改变data值，子孙级组件就能获取数据更新值，重新渲染新值；</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>父子级通信推荐使用：props/$emit、$parent/$children/$refs、$attrs/$listeners</li>
<li>兄弟组件通信推荐使用：$emit/$on、Vuex</li>
<li>跨级组件通信推荐使用：provide/inject、$emit/$on、Vuex、$attrs/$listeners</li>
</ul>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>兄弟通信</tag>
        <tag>父子通信</tag>
        <tag>孙子通信</tag>
      </tags>
  </entry>
  <entry>
    <title>基于Vue+Ueditor搭建富文本编辑器</title>
    <url>/2019/11/30/%E5%9F%BA%E4%BA%8EVue-Ueditor%E6%90%AD%E5%BB%BA%E5%AF%8C%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%99%A8/</url>
    <content><![CDATA[<h2 id="一、下载Ueditor并将它放在Vue项目中的static目录当中"><a href="#一、下载Ueditor并将它放在Vue项目中的static目录当中" class="headerlink" title="一、下载Ueditor并将它放在Vue项目中的static目录当中"></a>一、下载Ueditor并将它放在Vue项目中的static目录当中</h2><a id="more"></a>

<p><img src="https://raw.githubusercontent.com/hsonzhou95/blogImg/master/lg.png?token=AMCTPY3XNRSRPNHILMW4CJ254C3EG" alt="avator"></p>
<h2 id="二、创建Editor编辑界面"><a href="#二、创建Editor编辑界面" class="headerlink" title="二、创建Editor编辑界面"></a>二、创建Editor编辑界面</h2><h4 id="基于Vue组件式的写法"><a href="#基于Vue组件式的写法" class="headerlink" title="基于Vue组件式的写法"></a>基于Vue组件式的写法</h4><h5 id="component组件代码"><a href="#component组件代码" class="headerlink" title="component组件代码"></a>component组件代码</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line"></span><br><span class="line">        &lt;div ref=&quot;editorId&quot; :style=&quot;&#123;width: 100+&apos;%&apos;,height:height+&apos;px&apos;&#125;&quot;&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    export default &#123;</span><br><span class="line">        name: &quot;EditorView&quot;,</span><br><span class="line">        data() &#123;</span><br><span class="line">            return &#123;</span><br><span class="line">                editor: null,</span><br><span class="line">                id: &apos;editor&apos; + new Date().getTime()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        props: &#123;</span><br><span class="line">            value: &#123;</span><br><span class="line">                type: String,</span><br><span class="line">                default: null,</span><br><span class="line">            &#125;,</span><br><span class="line">            height: &#123;</span><br><span class="line">                type:Number,</span><br><span class="line">                default:null,</span><br><span class="line">            &#125;,</span><br><span class="line">            config: &#123;</span><br><span class="line">                type: Object,</span><br><span class="line">                default: ()=&gt;&#123;&#125;,</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        watch: &#123;</span><br><span class="line">            &apos;value&apos;: function (val) &#123;</span><br><span class="line">                this.editor.setContent(val)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        mounted() &#123;</span><br><span class="line">            this.$nextTick(function f1() &#123;</span><br><span class="line">                this.$refs.editorId.id = this.id //创建动态id,由于封装的是拖拉拽的富文本编辑器，</span><br><span class="line">                所以会用到动态的id进行操作</span><br><span class="line">                this.editor = UE.getEditor(this.id,this.config)</span><br><span class="line">                // 保证 this.$el 已经插入文档</span><br><span class="line">                this.editor.ready(function f2() &#123;</span><br><span class="line">                    this.editor.setContent(this.value || &apos;&apos;)</span><br><span class="line">                    this.editor.addListener(&quot;contentChange&quot;, function () &#123;</span><br><span class="line">                        const wordCount = this.editor.getContentLength(true)</span><br><span class="line">                        const content = this.editor.getContent()</span><br><span class="line">                        const plainTxt = this.editor.getPlainTxt()</span><br><span class="line">                        const htmlCont = this.editor.getAllHtml()</span><br><span class="line">                        // 编辑器内容有变动,通知父组件</span><br><span class="line">                        this.$emit(&apos;input&apos;,content);</span><br><span class="line">                    &#125;.bind(this))</span><br><span class="line">                    // editor初始化后操作</span><br><span class="line">                    this.$emit(&apos;ready&apos;, this.editor)</span><br><span class="line">                &#125;.bind(this))</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;,</span><br><span class="line">        methods:&#123;</span><br><span class="line">            /**</span><br><span class="line">             * 保存</span><br><span class="line">             */</span><br><span class="line">            save () &#123;</span><br><span class="line">                const content = this.editor.getContent();</span><br><span class="line">                this.$emit(&apos;input&apos;,content);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h5 id="在父组件中进行调用"><a href="#在父组件中进行调用" class="headerlink" title="在父组件中进行调用"></a>在父组件中进行调用</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import EditorView from &quot;你的component路径&quot;</span><br></pre></td></tr></table></figure>

<h4 id="使用代码"><a href="#使用代码" class="headerlink" title="使用代码"></a>使用代码</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">	&lt;edior-view   v-model=&quot;&quot;</span><br><span class="line">                  :config=&quot;config&quot;</span><br><span class="line">                  :height=&quot;200&quot;&gt;</span><br><span class="line">    &lt;/edior-view&gt;</span><br><span class="line">&lt;template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    import EdiorView from &quot;./EdiorView&quot;;</span><br><span class="line">    export default &#123;</span><br><span class="line">        components:&#123;</span><br><span class="line">            EdiorView</span><br><span class="line">        &#125;,</span><br><span class="line">        name: &quot;Ueditor&quot;,</span><br><span class="line">        data() &#123;</span><br><span class="line">            return &#123;</span><br><span class="line">                zIndex:2000, //可以提供富文本编辑器的层级，可写可不写</span><br><span class="line">                elementPathEnabled : false,//去除底部左下角的元素路径提示，可写可不写</span><br><span class="line">                config:&#123; //编辑栏配置项</span><br><span class="line">                    toolbars: [</span><br><span class="line">                        [ &apos;source&apos;, //源代码</span><br><span class="line">                            &apos;undo&apos;, //撤销</span><br><span class="line">                            &apos;redo&apos;, //重做</span><br><span class="line">                            &apos;bold&apos;, //加粗</span><br><span class="line">                            &apos;indent&apos;, //首行缩进</span><br><span class="line">                            &apos;italic&apos;, //斜体</span><br><span class="line">                            &apos;underline&apos;, //下划线</span><br><span class="line">                            &apos;strikethrough&apos;, //删除线</span><br><span class="line">                            &apos;fontborder&apos;, //字符边框</span><br><span class="line">                            &apos;formatmatch&apos;, //格式刷</span><br><span class="line">                            &apos;horizontal&apos;, //分隔线</span><br><span class="line">                            &apos;removeformat&apos;, //清除格式</span><br><span class="line">                            &apos;inserttitle&apos;, //插入标题</span><br><span class="line">                            &apos;mergecells&apos;, //合并多个单元格</span><br><span class="line">                            &apos;cleardoc&apos;, //清空文档</span><br><span class="line">                            &apos;justifyleft&apos;, //居左对齐</span><br><span class="line">                            &apos;justifyright&apos;, //居右对齐</span><br><span class="line">                            &apos;justifycenter&apos;, //居中对齐</span><br><span class="line">                            &apos;justifyjustify&apos;, //两端对齐</span><br><span class="line">                            &apos;simpleupload&apos;, //单图上传</span><br><span class="line">                            &apos;insertimage&apos;, //多图上传</span><br><span class="line">                            &apos;fontfamily&apos;, //字体</span><br><span class="line">                            &apos;fontsize&apos;, //字号</span><br><span class="line">                            &apos;customstyle&apos;, //自定义标题</span><br><span class="line">                            &apos;paragraph&apos;, //段落格式</span><br><span class="line">                            &apos;emotion&apos;, //表情</span><br><span class="line">                            &apos;spechars&apos;, //特殊字符</span><br><span class="line">                            &apos;forecolor&apos;, //字体颜色</span><br><span class="line">                            &apos;directionalityltr&apos;, //从左向右输入</span><br><span class="line">                            &apos;directionalityrtl&apos;, //从右向左输入</span><br><span class="line">                            &apos;imagenone&apos;, //默认</span><br><span class="line">                            &apos;imageleft&apos;, //左浮动</span><br><span class="line">                            &apos;imageright&apos;, //右浮动</span><br><span class="line">                            &apos;imagecenter&apos;, //居中</span><br><span class="line">                            &apos;lineheight&apos;, //行间距</span><br><span class="line">                            &apos;edittip &apos;, //编辑提示</span><br><span class="line">                        ]</span><br><span class="line">                    ]</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        watch: &#123;</span><br><span class="line"></span><br><span class="line">        &#125;,</span><br><span class="line">        mounted() &#123;</span><br><span class="line"></span><br><span class="line">        &#125;,</span><br><span class="line">        methods: &#123;</span><br><span class="line"></span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line"></span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>

<h4 id="这样就可以封装一个基于Vue-Ueditor的富文本编辑器"><a href="#这样就可以封装一个基于Vue-Ueditor的富文本编辑器" class="headerlink" title="这样就可以封装一个基于Vue+Ueditor的富文本编辑器"></a>这样就可以封装一个基于Vue+Ueditor的富文本编辑器</h4><h2 id="参考文献1：-http-fex-baidu-com-ueditor"><a href="#参考文献1：-http-fex-baidu-com-ueditor" class="headerlink" title="参考文献1： http://fex.baidu.com/ueditor/"></a>参考文献1： <a href="http://fex.baidu.com/ueditor/" target="_blank" rel="noopener">http://fex.baidu.com/ueditor/</a></h2><h2 id="参考文献2："><a href="#参考文献2：" class="headerlink" title="参考文献2："></a>参考文献2：</h2><h2 id="https-www-cnblogs-com-xiaoyaoxingchen-p-9082666-html"><a href="#https-www-cnblogs-com-xiaoyaoxingchen-p-9082666-html" class="headerlink" title="https://www.cnblogs.com/xiaoyaoxingchen/p/9082666.html"></a><a href="https://www.cnblogs.com/xiaoyaoxingchen/p/9082666.html" target="_blank" rel="noopener">https://www.cnblogs.com/xiaoyaoxingchen/p/9082666.html</a></h2>]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Ueditor</tag>
      </tags>
  </entry>
  <entry>
    <title>Typescirpt教程详解</title>
    <url>/2019/11/24/Typescirpt%E6%95%99%E7%A8%8B%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h1 id="Typescript"><a href="#Typescript" class="headerlink" title="Typescript"></a>Typescript</h1><h4 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h4><p> <a href="http://www.typescriptlang.org/" target="_blank" rel="noopener">TypeScript</a> 是 JavaScript 的一个超集，主要提供了<strong>类型系统</strong>和<strong>对 ES6 的支持</strong>， </p>
<a id="more"></a>


<h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><h1 id="excerpt-link-more"><a href="#excerpt-link-more" class="headerlink" title="excerpt_link: more"></a>excerpt_link: more</h1><h4 id="原始数据类型"><a href="#原始数据类型" class="headerlink" title="原始数据类型"></a>原始数据类型</h4><h4 id="布尔值"><a href="#布尔值" class="headerlink" title="布尔值"></a>布尔值</h4><blockquote>
<p> 布尔值是最基础的数据类型，在 TypeScript 中，使用 <code>boolean</code> 定义布尔值类型： </p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> isDone: boolean = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译通过</span></span><br><span class="line"><span class="comment">// 后面约定，未强调编译错误的代码片段，默认为编译通过</span></span><br></pre></td></tr></table></figure>

<h4 id="数值"><a href="#数值" class="headerlink" title="数值"></a>数值</h4><blockquote>
<p>使用 <code>number</code> 定义数值类型： </p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> decLiteral: number = <span class="number">6</span>;</span><br><span class="line"><span class="keyword">let</span> hexLiteral: number = <span class="number">0xf00d</span>;</span><br><span class="line"><span class="comment">// ES6 中的二进制表示法</span></span><br><span class="line"><span class="keyword">let</span> binaryLiteral: number = <span class="number">0b1010</span>;</span><br><span class="line"><span class="comment">// ES6 中的八进制表示法</span></span><br><span class="line"><span class="keyword">let</span> octalLiteral: number = <span class="number">0o744</span>;</span><br><span class="line"><span class="keyword">let</span> notANumber: number = <span class="literal">NaN</span>;</span><br><span class="line"><span class="keyword">let</span> infinityNumber: number = <span class="literal">Infinity</span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>编译结果</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> decLiteral = <span class="number">6</span>;</span><br><span class="line"><span class="keyword">var</span> hexLiteral = <span class="number">0xf00d</span>;</span><br><span class="line"><span class="comment">// ES6 中的二进制表示法</span></span><br><span class="line"><span class="keyword">var</span> binaryLiteral = <span class="number">10</span>;</span><br><span class="line"><span class="comment">// ES6 中的八进制表示法</span></span><br><span class="line"><span class="keyword">var</span> octalLiteral = <span class="number">484</span>;</span><br><span class="line"><span class="keyword">var</span> notANumber = <span class="literal">NaN</span>;</span><br><span class="line"><span class="keyword">var</span> infinityNumber = <span class="literal">Infinity</span>;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><blockquote>
<p>使用 <code>string</code> 定义字符串类型： </p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> myName: string = <span class="string">'Tom'</span>;</span><br><span class="line"><span class="keyword">let</span> myAge: number = <span class="number">25</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模板字符串</span></span><br><span class="line"><span class="keyword">let</span> sentence: string = <span class="string">`Hello, my name is <span class="subst">$&#123;myName&#125;</span>.</span></span><br><span class="line"><span class="string">I'll be <span class="subst">$&#123;myAge + <span class="number">1</span>&#125;</span> years old next month.`</span>;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="空值"><a href="#空值" class="headerlink" title="空值"></a>空值</h4><blockquote>
<p>JavaScript 没有空值（Void）的概念，在 TypeScript 中，可以用 <code>void</code> 表示没有任何返回值的函数： </p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">alertName</span>(<span class="params"></span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">    alert(<span class="string">'My name is Tom'</span>);</span><br><span class="line">&#125;</span><br><span class="line">声明一个 <span class="keyword">void</span> 类型的变量没有什么用，因为你只能将它赋值为 <span class="literal">undefined</span> 和 <span class="literal">null</span>：</span><br><span class="line"><span class="keyword">let</span> unusable: <span class="keyword">void</span> = <span class="literal">undefined</span>;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="null和undefined"><a href="#null和undefined" class="headerlink" title="null和undefined"></a>null和undefined</h4><blockquote>
<p>在 TypeScript 中，可以使用 <code>null</code> 和 <code>undefined</code> 来定义这两个原始数据类型： </p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> u: <span class="literal">undefined</span> = <span class="literal">undefined</span>;</span><br><span class="line"><span class="keyword">let</span> n: <span class="literal">null</span> = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">与 <span class="keyword">void</span> 的区别是，<span class="literal">undefined</span> 和 <span class="literal">null</span> 是所有类型的子类型。也就是说 <span class="literal">undefined</span> 类型的变量，可以赋值给 number：</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这样不会报错</span></span><br><span class="line"><span class="keyword">let</span> num: number = <span class="literal">undefined</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这样也不会报错</span></span><br><span class="line"><span class="keyword">let</span> u: <span class="literal">undefined</span>;</span><br><span class="line"><span class="keyword">let</span> num: number = u;</span><br><span class="line"></span><br><span class="line">而 <span class="keyword">void</span> 类型的变量不能赋值给 number 类型的变量</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> u: <span class="keyword">void</span>;</span><br><span class="line"><span class="keyword">let</span> num: number = u;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Type 'void' is not assignable to type 'number'.</span></span><br></pre></td></tr></table></figure>

<hr>
<h4 id="任意值"><a href="#任意值" class="headerlink" title="任意值"></a>任意值</h4><blockquote>
<p>任意值（Any）用来表示允许赋值为任意类型。</p>
</blockquote>
<h5 id="什么是任意类型的值"><a href="#什么是任意类型的值" class="headerlink" title="什么是任意类型的值"></a>什么是任意类型的值</h5><ul>
<li>如果是一个普通类型，在赋值过程中改变类型是不被允许的：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> myFavoriteNumber: string = <span class="string">'seven'</span>;</span><br><span class="line">myFavoriteNumber = <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.ts(2,1): error TS2322: Type 'number' is not assignable to type 'string'.</span></span><br></pre></td></tr></table></figure>

<ul>
<li>但如果是 <code>any</code> 类型，则允许被赋值为任意类型。 </li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> myFavoriteNumber: any = <span class="string">'seven'</span>;</span><br><span class="line">myFavoriteNumber = <span class="number">7</span>;</span><br></pre></td></tr></table></figure>

<h5 id="任意值的属性和方法"><a href="#任意值的属性和方法" class="headerlink" title="任意值的属性和方法"></a>任意值的属性和方法</h5><blockquote>
<p>在任意值上访问任何属性都是允许的： </p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> anyThing: any = <span class="string">'hello'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(anyThing.myName);</span><br><span class="line"><span class="built_in">console</span>.log(anyThing.myName.firstName);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>也允许调用任何方法</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> anyThing: any = <span class="string">'Tom'</span>;</span><br><span class="line">anyThing.setName(<span class="string">'Jerry'</span>);</span><br><span class="line">anyThing.setName(<span class="string">'Jerry'</span>).sayHello();</span><br><span class="line">anyThing.myName.setFirstName(<span class="string">'Cat'</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>可以认为，<strong>声明一个变量为任意值之后，对它的任何操作，返回的内容的类型都是任意值</strong>。 </li>
</ul>
<h5 id="未声明类型的变量"><a href="#未声明类型的变量" class="headerlink" title="未声明类型的变量"></a>未声明类型的变量</h5><blockquote>
<p>变量如果在声明的时候，未指定其类型，那么它会被识别为任意值类型 </p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> something;</span><br><span class="line">something = <span class="string">'seven'</span>;</span><br><span class="line">something = <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">something.setName(<span class="string">'Tom'</span>);</span><br><span class="line"></span><br><span class="line">等价于</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> something: any;</span><br><span class="line">something = <span class="string">'seven'</span>;</span><br><span class="line">something = <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">something.setName(<span class="string">'Tom'</span>);</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="类型推论"><a href="#类型推论" class="headerlink" title="类型推论"></a>类型推论</h4><blockquote>
<p>如果没有明确的指定类型，那么Typescript会依照类型推论 （Type Inference） 的规则推断出一个类型。</p>
</blockquote>
<h5 id="什么是类型推论"><a href="#什么是类型推论" class="headerlink" title="什么是类型推论"></a>什么是类型推论</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">以下代码虽然没有指定类型，但是会在编译的时候报错：</span><br><span class="line"><span class="keyword">let</span> myFavoriteNumber = <span class="string">'seven'</span>;</span><br><span class="line">myFavoriteNumber = <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.ts(2,1): error TS2322: Type 'number' is not assignable to type 'string'.</span></span><br><span class="line"></span><br><span class="line">等价于</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myFavoriteNumber: string = <span class="string">'seven'</span>;</span><br><span class="line">myFavoriteNumber = <span class="number">7</span>;</span><br><span class="line"><span class="comment">// index.ts(2,1): error TS2322: Type 'number' is not assignable to type 'string'.</span></span><br></pre></td></tr></table></figure>

<ul>
<li>TypeScript 会在没有明确的指定类型的时候推测出一个类型，这就是类型推论。</li>
</ul>
<h6 id="如果定义的时候没有赋值，不管之后有没有赋值，都会被推断成-any-类型而完全不被类型检查："><a href="#如果定义的时候没有赋值，不管之后有没有赋值，都会被推断成-any-类型而完全不被类型检查：" class="headerlink" title="如果定义的时候没有赋值，不管之后有没有赋值，都会被推断成 any 类型而完全不被类型检查："></a><strong>如果定义的时候没有赋值，不管之后有没有赋值，都会被推断成</strong> <code>any</code> <strong>类型而完全不被类型检查</strong>：</h6><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> myFavoriteNumber;</span><br><span class="line">myFavoriteNumber = <span class="string">'seven'</span>;</span><br><span class="line">myFavoriteNumber = <span class="number">7</span>;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="联合类型"><a href="#联合类型" class="headerlink" title="联合类型"></a>联合类型</h4><blockquote>
<p>联合类型（Union Types）表示取值可以为多种类型中的一种。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> myFavoriteNumber: string | number;</span><br><span class="line">myFavoriteNumber = <span class="string">'seven'</span>;</span><br><span class="line">myFavoriteNumber = <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">联合类型使用 | 分隔每个类型。</span><br></pre></td></tr></table></figure>

<ul>
<li>这里的 <code>let myFavoriteNumber: string | number</code> 的含义是，允许 <code>myFavoriteNumber</code> 的类型是 <code>string</code> 或者 <code>number</code>，但是不能是其他类型。 </li>
</ul>
<h5 id="访问联合类型的属性和方法"><a href="#访问联合类型的属性和方法" class="headerlink" title="访问联合类型的属性和方法"></a>访问联合类型的属性和方法</h5><blockquote>
<p>当 TypeScript 不确定一个联合类型的变量到底是哪个类型的时候，我们<strong>只能访问此联合类型的所有类型里共有的属性或方法</strong>： </p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getLength</span>(<span class="params">something: string | number</span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> something.length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.ts(2,22): error TS2339: Property 'length' does not exist on type 'string | number'.</span></span><br><span class="line"><span class="comment">//   Property 'length' does not exist on type 'number'.</span></span><br><span class="line"></span><br><span class="line">上例中，length 不是 string 和 number 的共有属性，所以会报错。</span><br></pre></td></tr></table></figure>

<blockquote>
<p>访问 <code>string</code> 和 <code>number</code> 的共有属性是没问题的： </p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getString</span>(<span class="params">something: string | number</span>): <span class="title">string</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> something.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>联合类型的变量在被赋值的时候，会根据类型推论的规则推断出一个类型： </p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> myFavoriteNumber: string | number;</span><br><span class="line">myFavoriteNumber = <span class="string">'seven'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(myFavoriteNumber.length); <span class="comment">// 5</span></span><br><span class="line">myFavoriteNumber = <span class="number">7</span>;</span><br><span class="line"><span class="built_in">console</span>.log(myFavoriteNumber.length); <span class="comment">// 编译时报错</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// index.ts(5,30): error TS2339: Property 'length' does not exist on type 'number'.</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>上例中，第二行的 <code>myFavoriteNumber</code> 被推断成了 <code>string</code>，访问它的 <code>length</code> 属性不会报错。</p>
<p>而第四行的 <code>myFavoriteNumber</code> 被推断成了 <code>number</code>，访问它的 <code>length</code> 属性时就报错了。</p>
</li>
</ul>
<h4 id="对象的类型-接口"><a href="#对象的类型-接口" class="headerlink" title="对象的类型-接口"></a>对象的类型-接口</h4><hr>
<blockquote>
<p>在 TypeScript 中，我们使用接口（Interfaces）来定义对象的类型。 </p>
</blockquote>
<h5 id="什么是接口"><a href="#什么是接口" class="headerlink" title="什么是接口"></a>什么是接口</h5><ul>
<li><p>在面向对象语言中，接口（Interfaces）是一个很重要的概念，它是对行为的抽象，而具体如何行动需要由类（classes）去实现（implement）。</p>
<p>TypeScript 中的接口是一个非常灵活的概念，除了可用于<a href="">对类的一部分行为进行抽象</a>以外，也常用于对「对象的形状（Shape）」进行描述。</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">interface Person &#123;</span><br><span class="line">    name: string;</span><br><span class="line">    age: number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> tom: Person = &#123;</span><br><span class="line">    name: <span class="string">'Tom'</span>,</span><br><span class="line">    age: <span class="number">25</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>定义的变量比接口少了一些属性是不允许的： </li>
</ul>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">    name: <span class="built_in">string</span>;</span><br><span class="line">    age: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> tom: Person = &#123;</span><br><span class="line">    name: <span class="string">'Tom'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.ts(6,5): error TS2322: Type '&#123; name: string; &#125;' is not assignable to type 'Person'.</span></span><br><span class="line"><span class="comment">//   Property 'age' is missing in type '&#123; name: string; &#125;'.</span></span><br></pre></td></tr></table></figure>

<ul>
<li>可见，<strong>赋值的时候，变量的形状必须和接口的形状保持一致</strong>。 </li>
</ul>
<h5 id="可选属性"><a href="#可选属性" class="headerlink" title="可选属性"></a>可选属性</h5><blockquote>
<p>有时我们希望不要完全匹配一个形状，那么可以用可选属性：</p>
</blockquote>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">    name: <span class="built_in">string</span>;</span><br><span class="line">    age?: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> tom: Person = &#123;</span><br><span class="line">    name: <span class="string">'Tom'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">    name: <span class="built_in">string</span>;</span><br><span class="line">    age?: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> tom: Person = &#123;</span><br><span class="line">    name: <span class="string">'Tom'</span>,</span><br><span class="line">    age: <span class="number">25</span></span><br><span class="line">&#125;;</span><br><span class="line">可选属性的含义是该属性可以不存在。</span><br><span class="line"></span><br><span class="line">这时仍然不允许添加未定义的属性：</span><br><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">    name: <span class="built_in">string</span>;</span><br><span class="line">    age?: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> tom: Person = &#123;</span><br><span class="line">    name: <span class="string">'Tom'</span>,</span><br><span class="line">    age: <span class="number">25</span>,</span><br><span class="line">    gender: <span class="string">'male'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// examples/playground/index.ts(9,5): error TS2322: Type '&#123; name: string; age: number; gender: string; &#125;' is not assignable to type 'Person'.</span></span><br><span class="line"><span class="comment">//   Object literal may only specify known properties, and 'gender' does not exist in type 'Person'.</span></span><br></pre></td></tr></table></figure>

<h5 id="任意属性"><a href="#任意属性" class="headerlink" title="任意属性"></a>任意属性</h5><blockquote>
<p>有时候我们希望一个接口允许有任意的属性，可以使用如下方式：</p>
</blockquote>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">    name: <span class="built_in">string</span>;</span><br><span class="line">    age?: <span class="built_in">number</span>;</span><br><span class="line">    [propName: <span class="built_in">string</span>]: <span class="built_in">any</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> tom: Person = &#123;</span><br><span class="line">    name: <span class="string">'Tom'</span>,</span><br><span class="line">    gender: <span class="string">'male'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">使用 [propName: <span class="built_in">string</span>] 定义了任意属性取 <span class="built_in">string</span> 类型的值。</span><br></pre></td></tr></table></figure>

<ul>
<li>需要注意的是，<strong>一旦定义了任意属性，那么确定属性和可选属性的类型都必须是它的类型的子集</strong> :</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">    name: <span class="built_in">string</span>;</span><br><span class="line">    age?: <span class="built_in">number</span>;</span><br><span class="line">    [propName: <span class="built_in">string</span>]: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> tom: Person = &#123;</span><br><span class="line">    name: <span class="string">'Tom'</span>,</span><br><span class="line">    age: <span class="number">25</span>,</span><br><span class="line">    gender: <span class="string">'male'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.ts(3,5): error TS2411: Property 'age' of type 'number' is not assignable to string index type 'string'.</span></span><br><span class="line"><span class="comment">// index.ts(7,5): error TS2322: Type '&#123; [x: string]: string | number; name: string; age: number; gender: string; &#125;' is not assignable to type 'Person'.</span></span><br><span class="line"><span class="comment">//   Index signatures are incompatible.</span></span><br><span class="line"><span class="comment">//     Type 'string | number' is not assignable to type 'string'.</span></span><br><span class="line"><span class="comment">//       Type 'number' is not assignable to type 'string'.</span></span><br></pre></td></tr></table></figure>

<ul>
<li>上例中，任意属性的值允许是 <code>string</code>，但是可选属性 <code>age</code> 的值却是 <code>number</code>，<code>number</code> 不是 <code>string</code> 的子属性，所以报错了。</li>
</ul>
<h5 id="只读属性"><a href="#只读属性" class="headerlink" title="只读属性"></a>只读属性</h5><blockquote>
<p>有时候我们希望对象中的一些字段只能在创建的时候被赋值，那么可以用 ** <code>readonly</code> ** 定义只读属性：</p>
</blockquote>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">    readonly id: <span class="built_in">number</span>;</span><br><span class="line">    name: <span class="built_in">string</span>;</span><br><span class="line">    age?: <span class="built_in">number</span>;</span><br><span class="line">    [propName: <span class="built_in">string</span>]: <span class="built_in">any</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> tom: Person = &#123;</span><br><span class="line">    id: <span class="number">89757</span>,</span><br><span class="line">    name: <span class="string">'Tom'</span>,</span><br><span class="line">    gender: <span class="string">'male'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">tom.id = <span class="number">9527</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.ts(14,5): error TS2540: Cannot assign to 'id' because it is a constant or a read-only property.</span></span><br><span class="line">上例中，使用 readonly 定义的属性 id 初始化后，又被赋值了，所以报错了。</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>注意，只读的约束存在于第一次给对象赋值的时候，而不是第一次给只读属性赋值的时候</strong>： </li>
</ul>
<h4 id="数组的类型"><a href="#数组的类型" class="headerlink" title="数组的类型"></a>数组的类型</h4><hr>
<blockquote>
<p>在 TypeScript 中，数组类型有多种定义方式，比较灵活。</p>
</blockquote>
<h5 id="「类型-方括号」表示法"><a href="#「类型-方括号」表示法" class="headerlink" title="「类型 + 方括号」表示法"></a>「类型 + 方括号」表示法</h5><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>/最简单的方法是使用「类型 + 方括号」来表示数组：</span><br><span class="line"><span class="keyword">let</span> a:<span class="built_in">number</span>=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>/数组的项中不允许出现其他的类型：</span><br><span class="line"><span class="keyword">let</span> fibonacci: <span class="built_in">number</span>[] = [<span class="number">1</span>, <span class="string">'1'</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// Type 'string' is not assignable to type 'number'.</span></span><br><span class="line"></span><br><span class="line"><span class="number">3</span>/数组的一些方法的参数也会根据数组在定义时约定的类型进行限制：</span><br><span class="line"><span class="keyword">let</span> fibonacci: <span class="built_in">number</span>[] = [<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>];</span><br><span class="line">fibonacci.push(<span class="string">'8'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Argument of type '"8"' is not assignable to parameter of type 'number'.</span></span><br></pre></td></tr></table></figure>

<ul>
<li>上例中，<code>push</code> 方法只允许传入 <code>number</code> 类型的参数，但是却传了一个 <code>&quot;8&quot;</code> 类型的参数，所以报错了。这里 <code>&quot;8&quot;</code> 是一个字符串字面量类型，会在后续章节中详细介绍。 </li>
</ul>
<h5 id="数组的泛型"><a href="#数组的泛型" class="headerlink" title="数组的泛型"></a>数组的泛型</h5><blockquote>
<p>我们也可以使用数组泛型（Array Generic） <code>Array</code> 来表示数组：</p>
</blockquote>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> fibonacci: <span class="built_in">Array</span>&lt;<span class="built_in">number</span>&gt; = [<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>];</span><br></pre></td></tr></table></figure>

<h5 id="用接口表示数组"><a href="#用接口表示数组" class="headerlink" title="用接口表示数组"></a>用接口表示数组</h5><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">接口也可以用来描述数组：</span><br><span class="line"><span class="keyword">interface</span> NumberArray &#123;</span><br><span class="line">    [index: <span class="built_in">number</span>]: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> fibonacci: NumberArray = [<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>];</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>NumberArray</code> 表示：只要索引的类型是数字时，那么值的类型必须是数字。(虽然接口也可以用来描述数组，但是我们一般不会这么做，因为这种方式比前两种方式复杂多了。)</p>
</li>
<li><p>不过有一种情况例外，那就是它常用来表示类数组。</p>
</li>
</ul>
<h5 id="类数组"><a href="#类数组" class="headerlink" title="类数组"></a>类数组</h5><blockquote>
<p>类数组（Array-like Object）不是数组类型，比如 <code>arguments</code>：</p>
</blockquote>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> args: <span class="built_in">number</span>[] = <span class="built_in">arguments</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Type 'IArguments' is missing the following properties from type 'number[]': pop, push, concat, join, and 24 more</span></span><br></pre></td></tr></table></figure>

<ul>
<li>上例中，<code>arguments</code> 实际上是一个类数组，不能用普通的数组的方式来描述，而应该用接口：</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> args: &#123;</span><br><span class="line">        [index: <span class="built_in">number</span>]: <span class="built_in">number</span>;</span><br><span class="line">        length: <span class="built_in">number</span>;</span><br><span class="line">        callee: <span class="built_in">Function</span>;</span><br><span class="line">    &#125; = <span class="built_in">arguments</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>在这个例子中，我们除了约束当索引的类型是数字时，值的类型必须是数字之外，也约束了它还有 <code>length</code> 和 <code>callee</code> 两个属性。</p>
<p>事实上常用的类数组都有自己的接口定义，如 <code>IArguments</code>, <code>NodeList</code>, <code>HTMLCollection</code> 等：</p>
</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> args: IArguments = <span class="built_in">arguments</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>其中 <code>IArguments</code> 是 TypeScript 中定义好了的类型，它实际上就是：</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> IArguments &#123;</span><br><span class="line">    [index: <span class="built_in">number</span>]: <span class="built_in">any</span>;</span><br><span class="line">    length: <span class="built_in">number</span>;</span><br><span class="line">    callee: <span class="built_in">Function</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="any在数组中的应用"><a href="#any在数组中的应用" class="headerlink" title="any在数组中的应用"></a>any在数组中的应用</h4><ul>
<li>一个比较常见的做法是，用 <code>any</code> 表示数组中允许出现任意类型：</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> list: <span class="built_in">any</span>[] = [<span class="string">'xcatliu'</span>, <span class="number">25</span>, &#123; website: <span class="string">'http://xcatliu.com'</span> &#125;];</span><br></pre></td></tr></table></figure>

<h4 id="函数的类型"><a href="#函数的类型" class="headerlink" title="函数的类型"></a>函数的类型</h4><hr>
<blockquote>
<p><a href="https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/ch2.html" target="_blank" rel="noopener">函数是 JavaScript 中的一等公民</a></p>
</blockquote>
<h5 id="函数的声明"><a href="#函数的声明" class="headerlink" title="函数的声明"></a>函数的声明</h5><blockquote>
<p>在 JavaScript 中，有两种常见的定义函数的方式——函数声明（Function Declaration）和函数表达式（Function Expression）：</p>
</blockquote>
<ul>
<li>一个函数有输入和输出，要在 TypeScript 中对其进行约束，需要把输入和输出都考虑到，其中函数声明的类型定义较简单：</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，<strong>输入多余的（或者少于要求的）参数，是不被允许的</strong>：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line">sum(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.ts(4,1): error TS2346: Supplied parameters do not match any signature of call target.</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line">sum(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.ts(4,1): error TS2346: Supplied parameters do not match any signature of call target</span></span><br></pre></td></tr></table></figure>

<h5 id="函数表达式"><a href="#函数表达式" class="headerlink" title="函数表达式"></a>函数表达式</h5><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">如果要我们现在写一个对函数表达式（<span class="built_in">Function</span> Expression）的定义，可能会写成这样：</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> mySum = <span class="function"><span class="keyword">function</span> (<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">这是可以通过编译的，不过事实上，上面的代码只对等号右侧的匿名函数进行了类型定义，而等号左边的 mySum，是通过赋值操作进行类型推论而推断出来的。如果需要我们手动给 mySum 添加类型，则应该是这样：</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> mySum: <span class="function">(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">number</span> = <span class="function"><span class="keyword">function</span> (<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>注意不要混淆了 TypeScript 中的 <code>=&gt;</code> 和 ES6 中的 <code>=&gt;</code>。 </li>
</ul>
<h5 id="用接口定义函数的形状"><a href="#用接口定义函数的形状" class="headerlink" title="用接口定义函数的形状"></a>用接口定义函数的形状</h5><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">我们也可以使用接口的方式来定义一个函数需要符合的形状：</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> SearchFunc &#123;</span><br><span class="line">    (source: <span class="built_in">string</span>, subString: <span class="built_in">string</span>): <span class="built_in">boolean</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> mySearch: SearchFunc;</span><br><span class="line">mySearch = <span class="function"><span class="keyword">function</span>(<span class="params">source: <span class="built_in">string</span>, subString: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> source.search(subString) !== <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="可选参数"><a href="#可选参数" class="headerlink" title="可选参数"></a>可选参数</h5><blockquote>
<p>前面提到，输入多余的（或者少于要求的）参数，是不允许的。那么如何定义可选的参数呢？</p>
</blockquote>
<blockquote>
<p>与接口中的可选属性类似，我们用 <code>?</code> 表示可选的参数：</p>
</blockquote>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">buildName</span>(<span class="params">firstName: <span class="built_in">string</span>, lastName?: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (lastName) &#123;</span><br><span class="line">        <span class="keyword">return</span> firstName + <span class="string">' '</span> + lastName;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> firstName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> tomcat = buildName(<span class="string">'Tom'</span>, <span class="string">'Cat'</span>);</span><br><span class="line"><span class="keyword">let</span> tom = buildName(<span class="string">'Tom'</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>需要注意的是，可选参数必须接在必需参数后面。换句话说，<strong>可选参数后面不允许再出现必需参数了</strong>：</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">buildName</span>(<span class="params">firstName?: <span class="built_in">string</span>, lastName: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (firstName) &#123;</span><br><span class="line">        <span class="keyword">return</span> firstName + <span class="string">' '</span> + lastName;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> lastName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> tomcat = buildName(<span class="string">'Tom'</span>, <span class="string">'Cat'</span>);</span><br><span class="line"><span class="keyword">let</span> tom = buildName(<span class="literal">undefined</span>, <span class="string">'Tom'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.ts(1,40): error TS1016: A required parameter cannot follow an optional parameter.</span></span><br></pre></td></tr></table></figure>

<h5 id="参数默认值"><a href="#参数默认值" class="headerlink" title="参数默认值"></a>参数默认值</h5><blockquote>
<p>在 ES6 中，我们允许给函数的参数添加默认值，<strong>TypeScript 会将添加了默认值的参数识别为可选参数</strong>：</p>
</blockquote>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">buildName</span>(<span class="params">firstName: <span class="built_in">string</span>, lastName: <span class="built_in">string</span> = 'Cat'</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> firstName + <span class="string">' '</span> + lastName;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> tomcat = buildName(<span class="string">'Tom'</span>, <span class="string">'Cat'</span>);</span><br><span class="line"><span class="keyword">let</span> tom = buildName(<span class="string">'Tom'</span>);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>此时就不受「可选参数必须接在必需参数后面」的限制了：</p>
</blockquote>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">buildName</span>(<span class="params">firstName: <span class="built_in">string</span> = 'Tom', lastName: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> firstName + <span class="string">' '</span> + lastName;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> tomcat = buildName(<span class="string">'Tom'</span>, <span class="string">'Cat'</span>);</span><br><span class="line"><span class="keyword">let</span> cat = buildName(<span class="literal">undefined</span>, <span class="string">'Cat'</span>);</span><br></pre></td></tr></table></figure>

<h5 id="剩余参数"><a href="#剩余参数" class="headerlink" title="剩余参数"></a>剩余参数</h5><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">push</span>(<span class="params">array: <span class="built_in">any</span>[], ...items: <span class="built_in">any</span>[]</span>) </span>&#123;</span><br><span class="line">    items.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>) </span>&#123;</span><br><span class="line">        array.push(item);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = [];</span><br><span class="line">push(a, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>注意，rest 参数只能是最后一个参数，关于 rest 参数，可以参考 <a href="http://es6.ruanyifeng.com/#docs/function#rest参数" target="_blank" rel="noopener">ES6 中的 rest 参数</a>。 </li>
</ul>
<h5 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h5><ul>
<li><p>重载允许一个函数接受不同数量或类型的参数时，作出不同的处理。</p>
</li>
<li><p>比如，我们需要实现一个函数 <code>reverse</code>，输入数字 <code>123</code> 的时候，输出反转的数字 <code>321</code>，输入字符串 <code>&#39;hello&#39;</code> 的时候，输出反转的字符串 <code>&#39;olleh&#39;</code>。 </p>
</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">利用联合类型，我们可以这么实现：</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reverse</span>(<span class="params">x: <span class="built_in">number</span> | <span class="built_in">string</span></span>): <span class="title">number</span> | <span class="title">string</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> x === <span class="string">'number'</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Number</span>(x.toString().split(<span class="string">''</span>).reverse().join(<span class="string">''</span>));</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> x === <span class="string">'string'</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> x.split(<span class="string">''</span>).reverse().join(<span class="string">''</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">然而这样有一个缺点，就是不能够精确的表达，输入为数字的时候，输出也应该为数字，输入为字符串的时候，输出也应该为字符串。</span><br><span class="line">这时，我们可以使用重载定义多个 reverse 的函数类型：</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reverse</span>(<span class="params">x: <span class="built_in">number</span></span>): <span class="title">number</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reverse</span>(<span class="params">x: <span class="built_in">string</span></span>): <span class="title">string</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reverse</span>(<span class="params">x: <span class="built_in">number</span> | <span class="built_in">string</span></span>): <span class="title">number</span> | <span class="title">string</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> x === <span class="string">'number'</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Number</span>(x.toString().split(<span class="string">''</span>).reverse().join(<span class="string">''</span>));</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> x === <span class="string">'string'</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> x.split(<span class="string">''</span>).reverse().join(<span class="string">''</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">上例中，我们重复定义了多次函数 reverse，前几次都是函数定义，最后一次是函数实现。在编辑器的代码提示中，可以正确的看到前两个提示。</span><br><span class="line"></span><br><span class="line">注意，TypeScript 会优先从最前面的函数定义开始匹配，所以多个函数定义如果有包含关系，需要优先把精确的定义写在前面。</span><br></pre></td></tr></table></figure>

<h4 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h4><hr>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getLength</span>(<span class="params">something: <span class="built_in">string</span> | <span class="built_in">number</span></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((&lt;<span class="built_in">string</span>&gt;something).length) &#123;</span><br><span class="line">        <span class="keyword">return</span> (&lt;<span class="built_in">string</span>&gt;something).length;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> something.toString().length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>类型断言的用法如上，在需要断言的变量前加上<type> 即可。</li>
<li><strong>类型断言不是类型转换，断言成一个联合类型中不存在的类型是不允许的</strong>：</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">toBoolean</span>(<span class="params">something: <span class="built_in">string</span> | <span class="built_in">number</span></span>): <span class="title">boolean</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &lt;<span class="built_in">boolean</span>&gt;something;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.ts(2,10): error TS2352: Type 'string | number' cannot be converted to type 'boolean'.</span></span><br><span class="line"><span class="comment">//   Type 'number' is not comparable to type 'boolean'.</span></span><br></pre></td></tr></table></figure>

<h4 id="内置对象"><a href="#内置对象" class="headerlink" title="内置对象"></a>内置对象</h4><hr>
<blockquote>
<p>JavaScript 中有很多<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects" target="_blank" rel="noopener">内置对象</a>，它们可以直接在 TypeScript 中当做定义好了的类型。</p>
</blockquote>
<blockquote>
<p>内置对象是指根据标准在全局作用域（Global）上存在的对象。这里的标准是指 ECMAScript 和其他环境（比如 DOM）的标准。</p>
</blockquote>
<h5 id="ECMAscript的内置对象"><a href="#ECMAscript的内置对象" class="headerlink" title="ECMAscript的内置对象"></a>ECMAscript的内置对象</h5><ul>
<li>ECMAScript 标准提供的内置对象有：</li>
<li><code>Boolean</code>、<code>Error</code>、<code>Date</code>、<code>RegExp</code> 等。</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">我们可以在 TypeScript 中将变量定义为这些类型：</span><br><span class="line"><span class="keyword">let</span> b: <span class="built_in">Boolean</span> = <span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">let</span> e: <span class="built_in">Error</span> = <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Error occurred'</span>);</span><br><span class="line"><span class="keyword">let</span> d: <span class="built_in">Date</span> = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"><span class="keyword">let</span> r: <span class="built_in">RegExp</span> = <span class="regexp">/[a-z]/</span>;</span><br></pre></td></tr></table></figure>

<h5 id="DOM和BOM的内置对象"><a href="#DOM和BOM的内置对象" class="headerlink" title="DOM和BOM的内置对象"></a>DOM和BOM的内置对象</h5><ul>
<li>DOM 和 BOM 提供的内置对象有：</li>
<li><code>Document</code>、<code>HTMLElement</code>、<code>Event</code>、<code>NodeList</code> 等。</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">TypeScript 中会经常用到这些类型：</span><br><span class="line"><span class="keyword">let</span> body: HTMLElement = <span class="built_in">document</span>.body;</span><br><span class="line"><span class="keyword">let</span> allDiv: NodeList = <span class="built_in">document</span>.querySelectorAll(<span class="string">'div'</span>);</span><br><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e: MouseEvent</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Do something</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="声明文件"><a href="#声明文件" class="headerlink" title="声明文件"></a>声明文件</h4><hr>
<h3 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h3><hr>
<h4 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h4><blockquote>
<p>类型别名用来给一个类型起个新名字。</p>
</blockquote>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Name = <span class="built_in">string</span>;</span><br><span class="line"><span class="keyword">type</span> NameResolver = <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">string</span>;</span><br><span class="line"><span class="keyword">type</span> NameOrResolver = Name | NameResolver;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getName</span>(<span class="params">n: NameOrResolver</span>): <span class="title">Name</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> n === <span class="string">'string'</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> n();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">类型别名常用于联合类型。</span><br></pre></td></tr></table></figure>

<h4 id="字符串字面量类型"><a href="#字符串字面量类型" class="headerlink" title="字符串字面量类型"></a>字符串字面量类型</h4><hr>
<blockquote>
<p>字符串字面量类型用来约束取值只能是某几个字符串中的一个。</p>
</blockquote>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> EventNames = <span class="string">'click'</span> | <span class="string">'scroll'</span> | <span class="string">'mousemove'</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleEvent</span>(<span class="params">ele: Element, event: EventNames</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">handleEvent(<span class="built_in">document</span>.getElementById(<span class="string">'hello'</span>), <span class="string">'scroll'</span>);  <span class="comment">// 没问题</span></span><br><span class="line">handleEvent(<span class="built_in">document</span>.getElementById(<span class="string">'world'</span>), <span class="string">'dbclick'</span>); <span class="comment">// 报错，event 不能为 'dbclick'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// index.ts(7,47): error TS2345: Argument of type '"dbclick"' is not assignable to parameter of type 'EventNames'</span></span><br><span class="line">上例中，我们使用 <span class="keyword">type</span> 定了一个字符串字面量类型 EventNames，它只能取三种字符串中的一种。</span><br></pre></td></tr></table></figure>

<ul>
<li>注意，<strong>类型别名与字符串字面量类型都是使用</strong> <code>type</code> <strong>进行定义。</strong></li>
</ul>
<h4 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h4><hr>
<blockquote>
<p>数组合并了相同类型的对象，而元组（Tuple）合并了不同类型的对象</p>
<p>元组起源于函数编程语言，这些语言中会频繁使用元组。</p>
</blockquote>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">简单的例子</span><br><span class="line">定义一对值分别为 <span class="built_in">string</span> 和 <span class="built_in">number</span> 的元组：</span><br><span class="line"><span class="keyword">let</span> tom: [<span class="built_in">string</span>, <span class="built_in">number</span>] = [<span class="string">'Tom'</span>, <span class="number">25</span>];</span><br><span class="line">当赋值或访问一个已知索引的元素时，会得到正确的类型：</span><br><span class="line"><span class="keyword">let</span> tom: [<span class="built_in">string</span>, <span class="built_in">number</span>];</span><br><span class="line">tom[<span class="number">0</span>] = <span class="string">'Tom'</span>;</span><br><span class="line">tom[<span class="number">1</span>] = <span class="number">25</span>;</span><br><span class="line"></span><br><span class="line">tom[<span class="number">0</span>].slice(<span class="number">1</span>);</span><br><span class="line">tom[<span class="number">1</span>].toFixed(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">也可以只赋值其中一项：</span><br><span class="line"><span class="keyword">let</span> tom: [<span class="built_in">string</span>, <span class="built_in">number</span>];</span><br><span class="line">tom[<span class="number">0</span>] = <span class="string">'Tom'</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>但是当直接对元组类型的变量进行初始化或者赋值的时候，需要提供所有元组类型中指定的项。 </li>
</ul>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> tom: [<span class="built_in">string</span>, <span class="built_in">number</span>];</span><br><span class="line">tom = [<span class="string">'Tom'</span>, <span class="number">25</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> tom: [<span class="built_in">string</span>, <span class="built_in">number</span>];</span><br><span class="line">tom = [<span class="string">'Tom'</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// Property '1' is missing in type '[string]' but required in type '[string, number]'</span></span><br></pre></td></tr></table></figure>

<h5 id="越界的元素"><a href="#越界的元素" class="headerlink" title="越界的元素"></a>越界的元素</h5><blockquote>
<p>当添加越界的元素时，它的类型会被限制为元组中每个类型的联合类型：</p>
</blockquote>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> tom: [<span class="built_in">string</span>, <span class="built_in">number</span>];</span><br><span class="line">tom = [<span class="string">'Tom'</span>, <span class="number">25</span>];</span><br><span class="line">tom.push(<span class="string">'male'</span>);</span><br><span class="line">tom.push(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Argument of type 'true' is not assignable to parameter of type 'string | number'</span></span><br></pre></td></tr></table></figure>

<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><hr>
<blockquote>
<p>枚举（Enum）类型用于取值被限定在一定范围内的场景，比如一周只能有七天，颜色限定为红绿蓝等。</p>
</blockquote>
<h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><hr>
<ul>
<li><p>类(Class)：定义了一件事物的抽象特点，包含它的属性和方法</p>
</li>
<li><p>对象（Object）：类的实例，通过 <code>new</code> 生成</p>
</li>
<li><p>面向对象（OOP）的三大特性：封装、继承、多态</p>
</li>
<li><p>封装（Encapsulation）：将对数据的操作细节隐藏起来，只暴露对外的接口。外界调用端不需要（也不可能）知道细节，就能通过对外提供的接口来访问该对象，同时也保证了外界无法任意更改对象内部的数据</p>
</li>
<li><p>继承（Inheritance）：子类继承父类，子类除了拥有父类的所有特性外，还有一些更具体的特性</p>
</li>
<li><p>多态（Polymorphism）：由继承而产生了相关的不同的类，对同一个方法可以有不同的响应。比如 <code>Cat</code> 和 <code>Dog</code> 都继承自 <code>Animal</code>，但是分别实现了自己的 <code>eat</code> 方法。此时针对某一个实例，我们无需了解它是 <code>Cat</code> 还是 <code>Dog</code>，就可以直接调用 <code>eat</code> 方法，程序会自动判断出来应该如何执行 <code>eat</code></p>
</li>
<li><p>存取器（getter &amp; setter）：用以改变属性的读取和赋值行为</p>
</li>
<li><p>修饰符（Modifiers）：修饰符是一些关键字，用于限定成员或类型的性质。比如 <code>public</code> 表示公有属性或方法</p>
</li>
<li><p>抽象类（Abstract Class）：抽象类是供其他类继承的基类，抽象类不允许被实例化。抽象类中的抽象方法必须在子类中被实现</p>
</li>
<li><p>接口（Interfaces）：不同类之间公有的属性或方法，可以抽象成一个接口。接口可以被类实现（implements）。一个类只能继承自另一个类，但是可以实现多个接口</p>
</li>
</ul>
<h4 id="ES7-中类的用法"><a href="#ES7-中类的用法" class="headerlink" title="ES7 中类的用法"></a>ES7 中类的用法</h4><h5 id="实例属性"><a href="#实例属性" class="headerlink" title="实例属性 :"></a>实例属性 :</h5><blockquote>
<p>ES6 中实例的属性只能通过构造函数中的 <code>this.xxx</code> 来定义，ES7 提案中可以直接在类里面定义： </p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    name = <span class="string">'Jack'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> Animal();</span><br><span class="line"><span class="built_in">console</span>.log(a.name); <span class="comment">// Jack</span></span><br></pre></td></tr></table></figure>

<h5 id="静态属性"><a href="#静态属性" class="headerlink" title="静态属性"></a>静态属性</h5><blockquote>
<p>ES7 提案中，可以使用 <code>static</code> 定义一个静态属性： </p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> num = <span class="number">42</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(Animal.num); <span class="comment">// 42</span></span><br></pre></td></tr></table></figure>

<h4 id="TypeScript-中类的用法"><a href="#TypeScript-中类的用法" class="headerlink" title="TypeScript 中类的用法"></a>TypeScript 中类的用法</h4><h5 id="public-p’rivate和protected"><a href="#public-p’rivate和protected" class="headerlink" title="public/p’rivate和protected"></a>public/p’rivate和protected</h5><blockquote>
<p>TypeScript 可以使用三种访问修饰符（Access Modifiers），分别是 <code>public</code>、<code>private</code> 和 <code>protected</code>。 </p>
</blockquote>
<ul>
<li><p><code>public</code> 修饰的属性或方法是公有的，可以在任何地方被访问到，默认所有的属性和方法都是 <code>public</code> 的</p>
</li>
<li><p><code>private</code> 修饰的属性或方法是私有的，不能在声明它的类的外部访问</p>
</li>
<li><p><code>protected</code> 修饰的属性或方法是受保护的，它和 <code>private</code> 类似，区别是它在子类中也是允许被访问的</p>
</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Animal &#123;</span><br><span class="line">    <span class="keyword">public</span> name;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">constructor</span>(<span class="params">name</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> Animal(<span class="string">'Jack'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(a.name); <span class="comment">// Jack</span></span><br><span class="line">a.name = <span class="string">'Tom'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a.name); <span class="comment">// Tom</span></span><br><span class="line"></span><br><span class="line">上面的例子中，name 被设置为了 <span class="keyword">public</span>，所以直接访问实例的 name 属性是允许的。</span><br></pre></td></tr></table></figure>

<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">很多时候，我们希望有的属性是无法直接存取的，这时候就可以用 <span class="keyword">private</span> 了：</span><br><span class="line"><span class="keyword">class</span> Animal &#123;</span><br><span class="line">    <span class="keyword">private</span> name;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">constructor</span>(<span class="params">name</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> Animal(<span class="string">'Jack'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(a.name); <span class="comment">// Jack</span></span><br><span class="line">a.name = <span class="string">'Tom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.ts(9,13): error TS2341: Property 'name' is private and only accessible within class 'Animal'.</span></span><br><span class="line"><span class="comment">// index.ts(10,1): error TS2341: Property 'name' is private and only accessible within class 'Animal'.</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>使用 <code>private</code> 修饰的属性或方法，在子类中也是不允许访问的：</p>
</blockquote>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Animal &#123;</span><br><span class="line">    <span class="keyword">private</span> name;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">constructor</span>(<span class="params">name</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Cat <span class="keyword">extends</span> Animal &#123;</span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params">name</span>) &#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.ts(11,17): error TS2341: Property 'name' is private and only accessible within class 'Animal'.</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>而如果是用 <code>protected</code> 修饰，则允许在子类中访问： </p>
</blockquote>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Animal&#123;</span><br><span class="line">    <span class="keyword">protected</span> name;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">constructor</span>(<span class="params">name</span>)&#123;</span><br><span class="line">    	<span class="keyword">this</span>.name=name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> Cat <span class="keyword">extends</span> Animal&#123;</span><br><span class="line">	<span class="keyword">constructor</span>(<span class="params">name</span>)&#123;</span><br><span class="line">		<span class="keyword">super</span>(name)</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>当构造函数修饰为 <code>private</code> 时，该类不允许被继承或者实例化：</p>
</blockquote>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> Animal &#123;</span><br><span class="line">    <span class="keyword">public</span> name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">constructor</span> (<span class="params">name</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> Cat <span class="keyword">extends</span> Animal &#123;</span><br><span class="line">    <span class="keyword">constructor</span> (<span class="params">name</span>) &#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> Animal(<span class="string">'Jack'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.ts(7,19): TS2675: Cannot extend a class 'Animal'. Class constructor is marked as private.</span></span><br><span class="line"><span class="comment">// index.ts(13,9): TS2673: Constructor of class 'Animal' is private and only accessible within the class declaration.</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>当构造函数修饰为 <code>protected</code> 时，该类只允许被继承：</p>
</blockquote>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Animal &#123;</span><br><span class="line">    <span class="keyword">public</span> name;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">constructor</span> (<span class="params">name</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> Cat <span class="keyword">extends</span> Animal &#123;</span><br><span class="line">    <span class="keyword">constructor</span> (<span class="params">name</span>) &#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> Animal(<span class="string">'Jack'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.ts(13,9): TS2674: Constructor of class 'Animal' is protected and only accessible within the class declaration.</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>修饰符还可以使用在构造函数参数中，等同于类中定义该属性，使代码更简洁。</p>
</blockquote>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Animal &#123;</span><br><span class="line">    <span class="comment">// public name: string;</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">constructor</span> (<span class="params"><span class="keyword">public</span> name</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="readonly"><a href="#readonly" class="headerlink" title="readonly"></a>readonly</h5><blockquote>
<p>只读属性关键字，只允许出现在属性声明或索引签名中。</p>
</blockquote>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Animal &#123;</span><br><span class="line">    readonly name;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">constructor</span>(<span class="params">name</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> Animal(<span class="string">'Jack'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(a.name); <span class="comment">// Jack</span></span><br><span class="line">a.name = <span class="string">'Tom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.ts(10,3): TS2540: Cannot assign to 'name' because it is a read-only property.</span></span><br></pre></td></tr></table></figure>

<ul>
<li>注意如果 <code>readonly</code> 和其他访问修饰符同时存在的话，需要写在其后面。</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Animal &#123;</span><br><span class="line">    <span class="comment">// public readonly name;</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">constructor</span>(<span class="params"><span class="keyword">public</span> readonly name</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h5><p><code>abstract</code> 用于定义抽象类和其中的抽象方法。</p>
<ul>
<li>首先，抽象类是不允许被实例化的：</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> Animal &#123;</span><br><span class="line">    <span class="keyword">public</span> name;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">constructor</span>(<span class="params">name</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> sayHi();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> Animal(<span class="string">'Jack'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.ts(9,11): error TS2511: Cannot create an instance of the abstract class 'Animal'.</span></span><br></pre></td></tr></table></figure>

<ul>
<li>上面的例子中，我们定义了一个抽象类 <code>Animal</code>，并且定义了一个抽象方法 <code>sayHi</code>。在实例化抽象类的时候报错了。</li>
</ul>
<blockquote>
<p>其次，抽象类中的抽象方法必须被子类实现：</p>
</blockquote>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> Animal &#123;</span><br><span class="line">    <span class="keyword">public</span> name;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">constructor</span>(<span class="params">name</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> sayHi();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Cat <span class="keyword">extends</span> Animal &#123;</span><br><span class="line">    <span class="keyword">public</span> eat() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span> is eating.`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> cat = <span class="keyword">new</span> Cat(<span class="string">'Tom'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.ts(9,7): error TS2515: Non-abstract class 'Cat' does not implement inherited abstract member 'sayHi' from class 'Animal'.</span></span><br></pre></td></tr></table></figure>

<ul>
<li>上面的例子中，我们定义了一个类 <code>Cat</code> 继承了抽象类 <code>Animal</code>，但是没有实现抽象方法 <code>sayHi</code>，所以编译报错了。</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">下面是一个正确使用抽象类的例子：</span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> Animal &#123;</span><br><span class="line">    <span class="keyword">public</span> name;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">constructor</span>(<span class="params">name</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> sayHi();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Cat <span class="keyword">extends</span> Animal &#123;</span><br><span class="line">    <span class="keyword">public</span> sayHi() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`Meow, My name is <span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> cat = <span class="keyword">new</span> Cat(<span class="string">'Tom'</span>);</span><br></pre></td></tr></table></figure>

<h4 id="类的类型"><a href="#类的类型" class="headerlink" title="类的类型"></a>类的类型</h4><blockquote>
<p>给类加上 TypeScript 的类型很简单，与接口类似：</p>
</blockquote>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Animal &#123;</span><br><span class="line">    name: <span class="built_in">string</span>;</span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    sayHi(): <span class="built_in">string</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">`My name is <span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>`</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a: Animal = <span class="keyword">new</span> Animal(<span class="string">'Jack'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(a.sayHi()); <span class="comment">// My name is Jack</span></span><br></pre></td></tr></table></figure>

<h3 id="类与接口"><a href="#类与接口" class="headerlink" title="类与接口"></a>类与接口</h3><hr>
<h4 id="类实现接口"><a href="#类实现接口" class="headerlink" title="类实现接口"></a>类实现接口</h4><blockquote>
<p>实现（implements）是面向对象中的一个重要概念。一般来讲，一个类只能继承自另一个类，有时候不同类之间可以有一些共有的特性，这时候就可以把特性提取成接口（interfaces），用 <code>implements</code> 关键字来实现。这个特性大大提高了面向对象的灵活性。</p>
</blockquote>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Alarm &#123;</span><br><span class="line">    alert();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Door &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> SecurityDoor <span class="keyword">extends</span> Door <span class="keyword">implements</span> Alarm &#123;</span><br><span class="line">    alert() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'SecurityDoor alert'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Car <span class="keyword">implements</span> Alarm &#123;</span><br><span class="line">    alert() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'Car alert'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>一个类可以实现多个接口：</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> Alarm &#123;</span><br><span class="line">    alert();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Light &#123;</span><br><span class="line">    lightOn();</span><br><span class="line">    lightOff();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Car <span class="keyword">implements</span> Alarm, Light &#123;</span><br><span class="line">    alert() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'Car alert'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    lightOn() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'Car light on'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    lightOff() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'Car light off'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上例中，<code>Car</code> 实现了 <code>Alarm</code> 和 <code>Light</code> 接口，既能报警，也能开关车灯。</p>
<h4 id="接口继承接口"><a href="#接口继承接口" class="headerlink" title="接口继承接口"></a>接口继承接口</h4><ul>
<li>接口与接口之间可以是继承关系：</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> Alarm &#123;</span><br><span class="line">    alert();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> LightableAlarm <span class="keyword">extends</span> Alarm &#123;</span><br><span class="line">    lightOn();</span><br><span class="line">    lightOff();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>上例中，我们使用 <code>extends</code> 使 <code>LightableAlarm</code> 继承 <code>Alarm</code>。</li>
</ul>
<h4 id="接口继承类"><a href="#接口继承类" class="headerlink" title="接口继承类"></a>接口继承类</h4><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Point &#123;</span><br><span class="line">    x: <span class="built_in">number</span>;</span><br><span class="line">    y: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Point3d <span class="keyword">extends</span> Point &#123;</span><br><span class="line">    z: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> point3d: Point3d = &#123;x: <span class="number">1</span>, y: <span class="number">2</span>, z: <span class="number">3</span>&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="混合类型"><a href="#混合类型" class="headerlink" title="混合类型"></a>混合类型</h4><blockquote>
<p><a href="">之前学习过</a>，可以使用接口的方式来定义一个函数需要符合的形状：</p>
</blockquote>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> SearchFunc &#123;</span><br><span class="line">    (source: <span class="built_in">string</span>, subString: <span class="built_in">string</span>): <span class="built_in">boolean</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> mySearch: SearchFunc;</span><br><span class="line">mySearch = <span class="function"><span class="keyword">function</span>(<span class="params">source: <span class="built_in">string</span>, subString: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> source.search(subString) !== <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>有时候，一个函数还可以有自己的属性和方法：</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> Counter &#123;</span><br><span class="line">    (start: <span class="built_in">number</span>): <span class="built_in">string</span>;</span><br><span class="line">    interval: <span class="built_in">number</span>;</span><br><span class="line">    reset(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getCounter</span>(<span class="params"></span>): <span class="title">Counter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> counter = &lt;Counter&gt;<span class="function"><span class="keyword">function</span> (<span class="params">start: <span class="built_in">number</span></span>) </span>&#123; &#125;;</span><br><span class="line">    counter.interval = <span class="number">123</span>;</span><br><span class="line">    counter.reset = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; &#125;;</span><br><span class="line">    <span class="keyword">return</span> counter;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> c = getCounter();</span><br><span class="line">c(<span class="number">10</span>);</span><br><span class="line">c.reset();</span><br><span class="line">c.interval = <span class="number">5.0</span>;</span><br></pre></td></tr></table></figure>

<h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><hr>
<blockquote>
<p>泛型（Generics）是指在定义函数、接口或类的时候，不预先指定具体的类型，而在使用的时候再指定类型的一种特性。</p>
</blockquote>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createArray</span>&lt;<span class="title">T</span>&gt;(<span class="params">length: <span class="built_in">number</span>, value: T</span>): <span class="title">Array</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> result: T[] = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">        result[i] = value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">createArray&lt;<span class="built_in">string</span>&gt;(<span class="number">3</span>, <span class="string">'x'</span>); <span class="comment">// ['x', 'x', 'x']</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>上例中，我们在函数名后添加了 ``，其中 <code>T</code> 用来指代任意输入的类型，在后面的输入 <code>value: T</code> 和输出 <code>Array</code> 中即可使用了。 </p>
</li>
<li><p>接着在调用的时候，可以指定它具体的类型为 <code>string</code>。当然，也可以不手动指定，而让类型推论自动推算出来： </p>
</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createAarray</span>&lt;<span class="title">T</span>&gt;(<span class="params">length:<span class="built_in">number</span>,value:T</span>):<span class="title">Array</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> result:T[]=[];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;length;i++)&#123;</span><br><span class="line">        result[i]=value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">createArray(<span class="number">3</span>,<span class="string">'x'</span>);<span class="comment">//['x','x','x']</span></span><br></pre></td></tr></table></figure>

<h4 id="多个类型参数"><a href="#多个类型参数" class="headerlink" title="多个类型参数"></a>多个类型参数</h4><blockquote>
<p>定义泛型的时候，可以一次定义多个类型参数：</p>
</blockquote>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>&lt;<span class="title">T</span>,<span class="title">U</span>&gt;(<span class="params">a:[T,U]</span>):[<span class="title">T</span>,<span class="title">U</span>]</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> [a[<span class="number">1</span>],a[<span class="number">0</span>]];</span><br><span class="line">&#125;</span><br><span class="line">fn(<span class="number">7</span>,<span class="string">'seven'</span>);<span class="comment">//['seven',7]</span></span><br></pre></td></tr></table></figure>

<ul>
<li>上例中我们定义了一个fn函数，用来交换输入的元组。</li>
</ul>
<h4 id="泛型约束"><a href="#泛型约束" class="headerlink" title="泛型约束"></a>泛型约束</h4><blockquote>
<p>在函数内部使用泛型变量的时候，由于事先不知道他是哪种类型，所以不能随意的操作他的属性或方法。</p>
</blockquote>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loggingIdentity</span>&lt;<span class="title">T</span>&gt;(<span class="params">arg: T</span>): <span class="title">T</span> </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(arg.length);</span><br><span class="line">    <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.ts(2,19): error TS2339: Property 'length' does not exist on type 'T'.</span></span><br></pre></td></tr></table></figure>

<ul>
<li>上例中，泛型 <code>T</code> 不一定包含属性 <code>length</code>，所以编译的时候报错了。</li>
</ul>
<blockquote>
<p>这时，我们可以对泛型进行约束，只允许这个函数传入那些包含 <code>length</code> 属性的变量。这就是泛型约束：</p>
</blockquote>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> Lengthwise &#123;</span><br><span class="line">    length: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loggingIdentity</span>&lt;<span class="title">T</span> <span class="title">extends</span> <span class="title">Lengthwise</span>&gt;(<span class="params">arg: T</span>): <span class="title">T</span> </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(arg.length);</span><br><span class="line">    <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>上例中，我们使用了 <code>extends</code> 约束了泛型 <code>T</code> 必须符合接口 <code>Lengthwise</code> 的形状，也就是必须包含 <code>length</code> 属性。 </li>
</ul>
<blockquote>
<p>此时如果调用 <code>loggingIdentity</code> 的时候，传入的 <code>arg</code> 不包含 <code>length</code>，那么在编译阶段就会报错了：</p>
</blockquote>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> Lengthwise &#123;</span><br><span class="line">    length: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loggingIdentity</span>&lt;<span class="title">T</span> <span class="title">extends</span> <span class="title">Lengthwise</span>&gt;(<span class="params">arg: T</span>): <span class="title">T</span> </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(arg.length);</span><br><span class="line">    <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">loggingIdentity(<span class="number">7</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.ts(10,17): error TS2345: Argument of type '7' is not assignable to parameter of type 'Lengthwise'.</span></span><br></pre></td></tr></table></figure>

<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">多个类型参数之间也可以互相约束：</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">copyFields</span>&lt;<span class="title">T</span> <span class="title">extends</span> <span class="title">U</span>, <span class="title">U</span>&gt;(<span class="params">target: T, source: U</span>): <span class="title">T</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> id <span class="keyword">in</span> source) &#123;</span><br><span class="line">        target[id] = (&lt;T&gt;source)[id];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> x = &#123; a: <span class="number">1</span>, b: <span class="number">2</span>, c: <span class="number">3</span>, d: <span class="number">4</span> &#125;;</span><br><span class="line"></span><br><span class="line">copyFields(x, &#123; b: <span class="number">10</span>, d: <span class="number">20</span> &#125;);</span><br><span class="line"></span><br><span class="line">上例中，我们使用了两个类型参数，其中要求 T 继承 U，这样就保证了 U 上不会出现 T 中不存在的字段。</span><br></pre></td></tr></table></figure>

<h4 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h4><ul>
<li>当然也可以使用含有泛型的接口来定义函数的形状： </li>
</ul>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> CreateArrayFunc &#123;</span><br><span class="line">    &lt;T&gt;(length: <span class="built_in">number</span>, value: T): <span class="built_in">Array</span>&lt;T&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> createArray: CreateArrayFunc;</span><br><span class="line">createArray = <span class="function"><span class="keyword">function</span>&lt;<span class="title">T</span>&gt;(<span class="params">length: <span class="built_in">number</span>, value: T</span>): <span class="title">Array</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> result: T[] = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">        result[i] = value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">createArray(<span class="number">3</span>, <span class="string">'x'</span>); <span class="comment">// ['x', 'x', 'x']</span></span><br></pre></td></tr></table></figure>

<ul>
<li>进一步，我们可以把泛型参数提前到接口名上： </li>
</ul>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> CreateArrayFunc&lt;T&gt; &#123;</span><br><span class="line">    (length: <span class="built_in">number</span>, value: T): <span class="built_in">Array</span>&lt;T&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> createArray: CreateArrayFunc&lt;<span class="built_in">any</span>&gt;;</span><br><span class="line">createArray = <span class="function"><span class="keyword">function</span>&lt;<span class="title">T</span>&gt;(<span class="params">length: <span class="built_in">number</span>, value: T</span>): <span class="title">Array</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> result: T[] = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">        result[i] = value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">createArray(<span class="number">3</span>, <span class="string">'x'</span>); <span class="comment">// ['x', 'x', 'x']</span></span><br><span class="line">注意，此时在使用泛型接口的时候，需要定义泛型的类型。</span><br></pre></td></tr></table></figure>

<h4 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h4><blockquote>
<p>与泛型接口类似，泛型也可以用于类的类型定义中：</p>
</blockquote>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> GenericNumber&lt;T&gt; &#123;</span><br><span class="line">    zeroValue: T;</span><br><span class="line">    add: <span class="function">(<span class="params">x: T, y: T</span>) =&gt;</span> T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myGenericNumber = <span class="keyword">new</span> GenericNumber&lt;<span class="built_in">number</span>&gt;();</span><br><span class="line">myGenericNumber.zeroValue = <span class="number">0</span>;</span><br><span class="line">myGenericNumber.add = <span class="function"><span class="keyword">function</span>(<span class="params">x, y</span>) </span>&#123; <span class="keyword">return</span> x + y; &#125;;</span><br></pre></td></tr></table></figure>

<h4 id="泛型参数的默认类型"><a href="#泛型参数的默认类型" class="headerlink" title="泛型参数的默认类型"></a>泛型参数的默认类型</h4><blockquote>
<p>在 TypeScript 2.3 以后，我们可以为泛型中的类型参数指定默认类型。当使用泛型时没有在代码中直接指定类型参数，从实际值参数中也无法推测出时，这个默认类型就会起作用。 </p>
</blockquote>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createArray</span>&lt;<span class="title">T</span> = <span class="title">string</span>&gt;(<span class="params">length: <span class="built_in">number</span>, value: T</span>): <span class="title">Array</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> result: T[] = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">        result[i] = value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="声明合并"><a href="#声明合并" class="headerlink" title="声明合并"></a>声明合并</h3><hr>
<blockquote>
<p>如果定义了两个相同名字的函数、接口或类，那么它们会合并成一个类型：</p>
</blockquote>
<h4 id="函数的合并"><a href="#函数的合并" class="headerlink" title="函数的合并"></a>函数的合并</h4><blockquote>
<p><a href="">之前学习过</a>，我们可以使用重载定义多个函数类型：</p>
</blockquote>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reverse</span>(<span class="params">x: <span class="built_in">number</span></span>): <span class="title">number</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reverse</span>(<span class="params">x: <span class="built_in">string</span></span>): <span class="title">string</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reverse</span>(<span class="params">x: <span class="built_in">number</span> | <span class="built_in">string</span></span>): <span class="title">number</span> | <span class="title">string</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> x === <span class="string">'number'</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Number</span>(x.toString().split(<span class="string">''</span>).reverse().join(<span class="string">''</span>));</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> x === <span class="string">'string'</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> x.split(<span class="string">''</span>).reverse().join(<span class="string">''</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="接口的合并"><a href="#接口的合并" class="headerlink" title="接口的合并"></a>接口的合并</h4><blockquote>
<p>接口中的属性在合并时会简单的合并到一个接口中：</p>
</blockquote>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> Alarm &#123;</span><br><span class="line">    price: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> Alarm &#123;</span><br><span class="line">    weight: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line">相当于</span><br><span class="line"><span class="keyword">interface</span> Alarm &#123;</span><br><span class="line">    price: <span class="built_in">number</span>;</span><br><span class="line">    weight: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 注意，<strong>合并的属性的类型必须是唯一的</strong>： </p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> Alarm &#123;</span><br><span class="line">    price: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> Alarm &#123;</span><br><span class="line">    price: <span class="built_in">number</span>;  <span class="comment">// 虽然重复了，但是类型都是 `number`，所以不会报错</span></span><br><span class="line">    weight: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Alarm &#123;</span><br><span class="line">    price: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> Alarm &#123;</span><br><span class="line">    price: <span class="built_in">string</span>;  <span class="comment">// 类型不一致，会报错</span></span><br><span class="line">    weight: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.ts(5,3): error TS2403: Subsequent variable declarations must have the same type.  Variable 'price' must be of type 'number', but here has type 'string'.</span></span><br></pre></td></tr></table></figure>

<p> 接口中方法的合并，与函数的合并一样： </p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> Alarm &#123;</span><br><span class="line">    price: <span class="built_in">number</span>;</span><br><span class="line">    alert(s: <span class="built_in">string</span>): <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> Alarm &#123;</span><br><span class="line">    weight: <span class="built_in">number</span>;</span><br><span class="line">    alert(s: <span class="built_in">string</span>, n: <span class="built_in">number</span>): <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line">相当于：</span><br><span class="line"><span class="keyword">interface</span> Alarm &#123;</span><br><span class="line">    price: <span class="built_in">number</span>;</span><br><span class="line">    weight: <span class="built_in">number</span>;</span><br><span class="line">    alert(s: <span class="built_in">string</span>): <span class="built_in">string</span>;</span><br><span class="line">    alert(s: <span class="built_in">string</span>, n: <span class="built_in">number</span>): <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="类的合并"><a href="#类的合并" class="headerlink" title="类的合并"></a>类的合并</h4><p>类的合并与接口的合并规则一致。</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>Typescript中文教程：<a href="https://www.tslang.cn/docs/home.html" target="_blank" rel="noopener">https://www.tslang.cn/docs/home.html</a><br>阮一峰Typescript入门教程： <a href="https://ts.xcatliu.com/" target="_blank" rel="noopener">https://ts.xcatliu.com/</a></p>
]]></content>
      <categories>
        <category>Typescript</category>
      </categories>
      <tags>
        <tag>TS</tag>
        <tag>类型声明</tag>
        <tag>超集</tag>
      </tags>
  </entry>
  <entry>
    <title>HTML5、CSS3</title>
    <url>/2019/11/24/HTML5%E3%80%81CSS3/</url>
    <content><![CDATA[<h2 id="HTML基础"><a href="#HTML基础" class="headerlink" title="HTML基础"></a>HTML基础</h2><h3 id="HTML介绍"><a href="#HTML介绍" class="headerlink" title="HTML介绍"></a>HTML介绍</h3><blockquote>
<p>html 是一种规范，一种标准，它通过标记符号来标记要显示的网页中的各个部分。可以告诉浏览器如何显示其中的内容，他是一种由浏览器解释执行的语言。（如：文字如何处理，画面如何安排，图片如何显示等</p>
</blockquote>
<a id="more"></a>
<h1 id="excerpt-link-more"><a href="#excerpt-link-more" class="headerlink" title="excerpt_link: more"></a>excerpt_link: more</h1><p>html（hyper text markup language）超文本标记语言是一种规范，一种标准，它通过标记符号来标记要显示的网页中的各个部分。可以告诉浏览器如何显示其中的内容，他是一种由浏览器解释执行的语言。（如：文字如何处理，画面如何安排，图片如何显示等。</p>
<p>html是制作网页的标准语言，由蒂姆·伯纳斯里在1990年提出，其目的是方便地把一台电脑中的文本或图形，与另一台电脑中的文本或图形联系在一体，形成一个有机的整体。超文本，就是指图像、视频、动画、声音、表格、链接等多媒体的内容。</p>
<blockquote>
<p>注意：浏览器按顺序阅读网页文件，然后根据标记符解释和显示其标记的内容，对书写出错的标记将不指出其错误，且不停止其解释执行过程，编制者只能通过显示效果来分析出错原因和出错部位</p>
</blockquote>
<h4 id="HTML版本历史"><a href="#HTML版本历史" class="headerlink" title="HTML版本历史"></a>HTML版本历史</h4><blockquote>
<p>当前使用的HTML版本为 HTML5，2014年10月由万维网联盟（W3C）完成标准制定</p>
</blockquote>
<ul>
<li>超文本标记语言（第一版）——1993年6月作为互联网工程工作小组（IETF）工作草案发布（并非标准）</li>
<li>HTML 2.0——1995年11月作为IETF RFC 1866发布</li>
<li>HTML 3.2——1996年1月14日作为W3C推荐标准发布</li>
<li>HTML 4.0——1997年12月18日作为W3C推荐标准发布</li>
<li>HTML 4.01——1999年12月24日，W3C推荐标准</li>
<li>XHTML 1.0——2000年1月26日发布，是W3C推荐标准，后来经过修订于2002年8月1日重新发布</li>
<li>XHTML 1.1——2001年5月31日作为W3C推荐标准发布</li>
<li>HTML 5.0——2014年10月28日作为W3C推荐标准发布</li>
</ul>
<h4 id="HTML特性"><a href="#HTML特性" class="headerlink" title="HTML特性"></a>HTML特性</h4>]]></content>
      <categories>
        <category>HTML5、CSS3</category>
      </categories>
      <tags>
        <tag>标签</tag>
        <tag>页面</tag>
        <tag>布局</tag>
      </tags>
  </entry>
  <entry>
    <title>我的第一篇博客</title>
    <url>/2019/11/24/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><a id="more"></a>

<h3 id="建立这个个人博客的目的是为了帮助自己进行更加有效的学习，从事互联网行业涉及的技术技能过多，而不能清晰的记住每个知识点，所有我会把我认为重要的经常用到的或者忘记的一些知识点进行综合整理，形成博客来供大家进行参考，我是一名前端工程师，希望同是IT行业的你可以多关注一下我，进行技术的探讨与交流，如果看了我的文章感觉对自己今后的学习有帮助的话也可以打赏博主，谢谢大家！！！"><a href="#建立这个个人博客的目的是为了帮助自己进行更加有效的学习，从事互联网行业涉及的技术技能过多，而不能清晰的记住每个知识点，所有我会把我认为重要的经常用到的或者忘记的一些知识点进行综合整理，形成博客来供大家进行参考，我是一名前端工程师，希望同是IT行业的你可以多关注一下我，进行技术的探讨与交流，如果看了我的文章感觉对自己今后的学习有帮助的话也可以打赏博主，谢谢大家！！！" class="headerlink" title="建立这个个人博客的目的是为了帮助自己进行更加有效的学习，从事互联网行业涉及的技术技能过多，而不能清晰的记住每个知识点，所有我会把我认为重要的经常用到的或者忘记的一些知识点进行综合整理，形成博客来供大家进行参考，我是一名前端工程师，希望同是IT行业的你可以多关注一下我，进行技术的探讨与交流，如果看了我的文章感觉对自己今后的学习有帮助的话也可以打赏博主，谢谢大家！！！"></a>建立这个个人博客的目的是为了帮助自己进行更加有效的学习，从事互联网行业涉及的技术技能过多，而不能清晰的记住每个知识点，所有我会把我认为重要的经常用到的或者忘记的一些知识点进行综合整理，形成博客来供大家进行参考，我是一名前端工程师，希望同是IT行业的你可以多关注一下我，进行技术的探讨与交流，如果看了我的文章感觉对自己今后的学习有帮助的话也可以打赏博主，谢谢大家！！！</h3>]]></content>
  </entry>
</search>
