<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('http://yoursite.com').hostname,
    root: '/',
    scheme: 'Gemini',
    version: '7.5.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","offset":12,"b2t":true,"scrollpercent":true,"onmobile":false},
    copycode: {"enable":true,"show_result":true,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    sidebarPadding: 40
  };
</script>

  <meta name="description" content="React知识点查漏补缺">
<meta property="og:type" content="article">
<meta property="og:title" content="React知识点查漏补缺">
<meta property="og:url" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2020&#x2F;01&#x2F;04&#x2F;React%E7%9F%A5%E8%AF%86%E7%82%B9%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA&#x2F;index.html">
<meta property="og:site_name" content="等风来。">
<meta property="og:description" content="React知识点查漏补缺">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2020-01-12T03:09:03.441Z">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/2020/01/04/React%E7%9F%A5%E8%AF%86%E7%82%B9%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true,
    isPage: false,
    isArchive: false
  };
</script>

  <title>React知识点查漏补缺 | 等风来。</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="等风来。" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">等风来。</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">成为一名出色的前端工程师</p>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="none"
           placeholder="搜索..." spellcheck="false"
           type="text" id="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/04/React%E7%9F%A5%E8%AF%86%E7%82%B9%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/zhouavtor.jpeg">
      <meta itemprop="name" content="Hson zhou">
      <meta itemprop="description" content="Try to be a better self">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="等风来。">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          React知识点查漏补缺
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-01-04 20:24:35" itemprop="dateCreated datePublished" datetime="2020-01-04T20:24:35+08:00">2020-01-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-01-12 11:09:03" itemprop="dateModified" datetime="2020-01-12T11:09:03+08:00">2020-01-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/React/" itemprop="url" rel="index">
                    <span itemprop="name">React</span>
                  </a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span><br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>12k</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="React知识点查漏补缺"><a href="#React知识点查漏补缺" class="headerlink" title="React知识点查漏补缺"></a>React知识点查漏补缺</h2><a id="more"></a>
<h4 id="问题1：什么是虚拟DOM？"><a href="#问题1：什么是虚拟DOM？" class="headerlink" title="问题1：什么是虚拟DOM？"></a>问题1：什么是虚拟DOM？</h4><blockquote>
<p>难度: ⭐</p>
</blockquote>
<h5 id="虚拟-DOM-VDOM-是真实-DOM-在内存中的表示。UI-的表示形式保存在内存中，并与实际的-DOM-同步。这是一个发生在渲染函数被调用和元素在屏幕上显示之间的步骤，整个过程被称为调和。"><a href="#虚拟-DOM-VDOM-是真实-DOM-在内存中的表示。UI-的表示形式保存在内存中，并与实际的-DOM-同步。这是一个发生在渲染函数被调用和元素在屏幕上显示之间的步骤，整个过程被称为调和。" class="headerlink" title="虚拟 DOM (VDOM)是真实 DOM 在内存中的表示。UI 的表示形式保存在内存中，并与实际的 DOM 同步。这是一个发生在渲染函数被调用和元素在屏幕上显示之间的步骤，整个过程被称为调和。"></a><strong>虚拟 DOM (VDOM)</strong>是真实 DOM 在内存中的表示。UI 的表示形式保存在内存中，并与实际的 DOM 同步。这是一个发生在渲染函数被调用和元素在屏幕上显示之间的步骤，整个过程被称为<strong>调和</strong>。</h5><h4 id="问题2：类组件和函数组件之间的区别是啥"><a href="#问题2：类组件和函数组件之间的区别是啥" class="headerlink" title="问题2：类组件和函数组件之间的区别是啥?"></a>问题2：类组件和函数组件之间的区别是啥?</h4><blockquote>
<p>难度: ⭐⭐</p>
</blockquote>
<ul>
<li>类组件可以使用其他特性，如状态state和生命周期钩子。</li>
<li>当组件只是接收props渲染到页面时，就是无状态组件，就属于函数组件，也被称为哑组件或展示组件。</li>
</ul>
<h5 id="函数组件和类组件当然是有区别的，而且函数组件的性能比类组件的性能要高，因为类组件使用的时候要实例化，而函数组件直接执行函数取返回结果即可，为了提高性能，尽量使用函数组件。"><a href="#函数组件和类组件当然是有区别的，而且函数组件的性能比类组件的性能要高，因为类组件使用的时候要实例化，而函数组件直接执行函数取返回结果即可，为了提高性能，尽量使用函数组件。" class="headerlink" title="函数组件和类组件当然是有区别的，而且函数组件的性能比类组件的性能要高，因为类组件使用的时候要实例化，而函数组件直接执行函数取返回结果即可，为了提高性能，尽量使用函数组件。"></a>函数组件和类组件当然是有区别的，而且函数组件的性能比类组件的性能要高，因为类组件使用的时候要实例化，而函数组件直接执行函数取返回结果即可，为了提高性能，尽量使用函数组件。</h5><table>
<thead>
<tr>
<th>区别</th>
<th>函数组件</th>
<th>类组件</th>
</tr>
</thead>
<tbody><tr>
<td>是否有this</td>
<td>没有</td>
<td>有</td>
</tr>
<tr>
<td>是否有生命周期</td>
<td>没有</td>
<td>有</td>
</tr>
<tr>
<td>是否有状态state</td>
<td>没有</td>
<td>有</td>
</tr>
</tbody></table>
<h4 id="问题3-React中refs干嘛用的？"><a href="#问题3-React中refs干嘛用的？" class="headerlink" title="问题3 React中refs干嘛用的？"></a>问题3 React中refs干嘛用的？</h4><blockquote>
<p>难度: ⭐⭐</p>
</blockquote>
<h5 id="Refs-提供了一种访问在render方法中创建的-DOM-节点或者-React-元素的方法。在典型的数据流中，props-是父子组件交互的唯一方式，想要修改子组件，需要使用新的pros重新渲染它。凡事有例外，某些情况下咱们需要在典型数据流外，强制修改子代，这个时候可以使用-Refs。"><a href="#Refs-提供了一种访问在render方法中创建的-DOM-节点或者-React-元素的方法。在典型的数据流中，props-是父子组件交互的唯一方式，想要修改子组件，需要使用新的pros重新渲染它。凡事有例外，某些情况下咱们需要在典型数据流外，强制修改子代，这个时候可以使用-Refs。" class="headerlink" title="Refs 提供了一种访问在render方法中创建的 DOM 节点或者 React 元素的方法。在典型的数据流中，props 是父子组件交互的唯一方式，想要修改子组件，需要使用新的pros重新渲染它。凡事有例外，某些情况下咱们需要在典型数据流外，强制修改子代，这个时候可以使用 Refs。"></a><code>Refs</code> 提供了一种访问在<code>render</code>方法中创建的 DOM 节点或者 React 元素的方法。在典型的数据流中，<code>props</code> 是父子组件交互的唯一方式，想要修改子组件，需要使用新的<code>pros</code>重新渲染它。凡事有例外，某些情况下咱们需要在典型数据流外，强制修改子代，这个时候可以使用 <code>Refs</code>。</h5><h5 id="咱们可以在组件添加一个-ref-属性来使用，该属性的值是一个回调函数，接收作为其第一个参数的底层-DOM-元素或组件的挂载实例。"><a href="#咱们可以在组件添加一个-ref-属性来使用，该属性的值是一个回调函数，接收作为其第一个参数的底层-DOM-元素或组件的挂载实例。" class="headerlink" title="咱们可以在组件添加一个 ref 属性来使用，该属性的值是一个回调函数，接收作为其第一个参数的底层 DOM 元素或组件的挂载实例。"></a>咱们可以在组件添加一个 <code>ref</code> 属性来使用，该属性的值是一个回调函数，接收作为其第一个参数的底层 DOM 元素或组件的挂载实例。</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class UnControlledForm extends Component &#123;</span><br><span class="line">  handleSubmit = () =&gt; &#123;</span><br><span class="line">    console.log(&quot;Input Value: &quot;, this.input.value)</span><br><span class="line">  &#125;</span><br><span class="line">  render () &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;form onSubmit=&#123;this.handleSubmit&#125;&gt;</span><br><span class="line">        &lt;input</span><br><span class="line">          type=&apos;text&apos;</span><br><span class="line">          ref=&#123;(input) =&gt; this.input = input&#125; /&gt;</span><br><span class="line">        &lt;button type=&apos;submit&apos;&gt;Submit&lt;/button&gt;</span><br><span class="line">      &lt;/form&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="请注意，input-元素有一个ref属性，它的值是一个函数。该函数接收输入的实际-DOM-元素，然后将其放在实例上，这样就可以在-handleSubmit-函数内部访问它。"><a href="#请注意，input-元素有一个ref属性，它的值是一个函数。该函数接收输入的实际-DOM-元素，然后将其放在实例上，这样就可以在-handleSubmit-函数内部访问它。" class="headerlink" title="请注意，input 元素有一个ref属性，它的值是一个函数。该函数接收输入的实际 DOM 元素，然后将其放在实例上，这样就可以在 handleSubmit 函数内部访问它。"></a>请注意，<code>input</code> 元素有一个<code>ref</code>属性，它的值是一个函数。该函数接收输入的实际 DOM 元素，然后将其放在实例上，这样就可以在 <code>handleSubmit</code> 函数内部访问它。</h5><h5 id="经常被误解的只有在类组件中才能使用-refs，但是refs也可以通过利用-JS-中的闭包与函数组件一起使用。"><a href="#经常被误解的只有在类组件中才能使用-refs，但是refs也可以通过利用-JS-中的闭包与函数组件一起使用。" class="headerlink" title="经常被误解的只有在类组件中才能使用 refs，但是refs也可以通过利用 JS 中的闭包与函数组件一起使用。"></a>经常被误解的只有在类组件中才能使用 <code>refs</code>，但是<code>refs</code>也可以通过利用 JS 中的闭包与函数组件一起使用。</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function CustomForm (&#123;handleSubmit&#125;) &#123;</span><br><span class="line">  let inputElement</span><br><span class="line">  return (</span><br><span class="line">    &lt;form onSubmit=&#123;() =&gt; handleSubmit(inputElement.value)&#125;&gt;</span><br><span class="line">      &lt;input</span><br><span class="line">        type=&apos;text&apos;</span><br><span class="line">        ref=&#123;(input) =&gt; inputElement = input&#125; /&gt;</span><br><span class="line">      &lt;button type=&apos;submit&apos;&gt;Submit&lt;/button&gt;</span><br><span class="line">    &lt;/form&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="问题4-在React中如何处理事件"><a href="#问题4-在React中如何处理事件" class="headerlink" title="问题4 在React中如何处理事件"></a>问题4 在React中如何处理事件</h4><blockquote>
<p>难度: ⭐⭐</p>
</blockquote>
<h5 id="为了解决跨浏览器的兼容性问题，SyntheticEvent-实例将被传递给你的事件处理函数，SyntheticEvent是-React-跨浏览器的浏览器原生事件包装器，它还拥有和浏览器原生事件相同的接口，包括-stopPropagation-和-preventDefault-。"><a href="#为了解决跨浏览器的兼容性问题，SyntheticEvent-实例将被传递给你的事件处理函数，SyntheticEvent是-React-跨浏览器的浏览器原生事件包装器，它还拥有和浏览器原生事件相同的接口，包括-stopPropagation-和-preventDefault-。" class="headerlink" title="为了解决跨浏览器的兼容性问题，SyntheticEvent 实例将被传递给你的事件处理函数，SyntheticEvent是 React 跨浏览器的浏览器原生事件包装器，它还拥有和浏览器原生事件相同的接口，包括 stopPropagation() 和 preventDefault()。"></a>为了解决跨浏览器的兼容性问题，<code>SyntheticEvent</code> 实例将被传递给你的事件处理函数，<code>SyntheticEvent</code>是 React 跨浏览器的浏览器原生事件包装器，它还拥有和浏览器原生事件相同的接口，包括 <code>stopPropagation()</code> 和 <code>preventDefault()</code>。</h5><h5 id="比较有趣的是，React-实际上并不将事件附加到子节点本身。React-使用单个事件侦听器侦听顶层的所有事件。这对性能有好处，也意味着-React-在更新-DOM-时不需要跟踪事件监听器。"><a href="#比较有趣的是，React-实际上并不将事件附加到子节点本身。React-使用单个事件侦听器侦听顶层的所有事件。这对性能有好处，也意味着-React-在更新-DOM-时不需要跟踪事件监听器。" class="headerlink" title="比较有趣的是，React 实际上并不将事件附加到子节点本身。React 使用单个事件侦听器侦听顶层的所有事件。这对性能有好处，也意味着 React 在更新 DOM 时不需要跟踪事件监听器。"></a>比较有趣的是，React 实际上并不将事件附加到子节点本身。React 使用单个事件侦听器侦听顶层的所有事件。这对性能有好处，也意味着 React 在更新 DOM 时不需要跟踪事件监听器。</h5><h4 id="问题5-state和props区别是啥"><a href="#问题5-state和props区别是啥" class="headerlink" title="问题5 state和props区别是啥?"></a>问题5 state和props区别是啥?</h4><blockquote>
<p>难度: ⭐⭐</p>
</blockquote>
<h5 id="props和state是普通的-JS-对象。虽然它们都包含影响渲染输出的信息，但是它们在组件方面的功能是不同的。即"><a href="#props和state是普通的-JS-对象。虽然它们都包含影响渲染输出的信息，但是它们在组件方面的功能是不同的。即" class="headerlink" title="props和state是普通的 JS 对象。虽然它们都包含影响渲染输出的信息，但是它们在组件方面的功能是不同的。即"></a><code>props</code>和<code>state</code>是普通的 JS 对象。虽然它们都包含影响渲染输出的信息，但是它们在组件方面的功能是不同的。即</h5><ul>
<li><code>state</code> 是组件自己管理数据，控制自己的状态，可变；</li>
<li><code>props</code> 是外部传入的数据参数，不可变；</li>
<li>没有<code>state</code>的叫做无状态组件，有<code>state</code>的叫做有状态组件；</li>
<li>多用 <code>props</code>，少用 <code>state</code>，也就是多写无状态组件。</li>
</ul>
<h4 id="问题5-如何创建refs"><a href="#问题5-如何创建refs" class="headerlink" title="问题5 如何创建refs"></a>问题5 如何创建refs</h4><blockquote>
<p>难度: ⭐⭐</p>
</blockquote>
<h5 id="Refs-是使用-React-createRef-创建的，并通过-ref-属性附加到-React-元素。在构造组件时，通常将-Refs-分配给实例属性，以便可以在整个组件中引用它们。"><a href="#Refs-是使用-React-createRef-创建的，并通过-ref-属性附加到-React-元素。在构造组件时，通常将-Refs-分配给实例属性，以便可以在整个组件中引用它们。" class="headerlink" title="Refs 是使用 React.createRef() 创建的，并通过 ref 属性附加到 React 元素。在构造组件时，通常将 Refs 分配给实例属性，以便可以在整个组件中引用它们。"></a>Refs 是使用 <code>React.createRef()</code> 创建的，并通过 <code>ref</code> 属性附加到 React 元素。在构造组件时，通常将 <code>Refs</code> 分配给实例属性，以便可以在整个组件中引用它们。</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class MyComponent extends React.Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.myRef = React.createRef();</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return &lt;p ref=&#123;this.myRef&#125; /&gt;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或者这样用：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class UserForm extends Component &#123;</span><br><span class="line">  handleSubmit = () =&gt; &#123;</span><br><span class="line">    console.log(&quot;Input Value is: &quot;, this.input.value)</span><br><span class="line">  &#125;</span><br><span class="line">  render () &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;form onSubmit=&#123;this.handleSubmit&#125;&gt;</span><br><span class="line">        &lt;input</span><br><span class="line">          type=&apos;text&apos;</span><br><span class="line">          ref=&#123;(input) =&gt; this.input = input&#125; /&gt; // Access DOM input in handle submit</span><br><span class="line">        &lt;button type=&apos;submit&apos;&gt;Submit&lt;/button&gt;</span><br><span class="line">      &lt;/form&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="问题7-什么是高阶组件"><a href="#问题7-什么是高阶组件" class="headerlink" title="问题7 什么是高阶组件"></a>问题7 什么是高阶组件</h4><blockquote>
<p>难度: ⭐⭐</p>
</blockquote>
<p><strong>高阶组件(HOC)</strong>是接受一个组件并返回一个新组件的函数。基本上，这是一个模式，是从 React 的组合特性中衍生出来的，称其为<strong>纯组件</strong>，因为它们可以接受任何动态提供的子组件，但不会修改或复制输入组件中的任何行为。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const EnhancedComponent = higherOrderComponent(WrappedComponent);</span><br></pre></td></tr></table></figure>

<p>HOC 可以用于以下许多用例</p>
<ul>
<li>代码重用、逻辑和引导抽象</li>
<li>渲染劫持</li>
<li>state 抽象和操作</li>
<li>props 处理</li>
</ul>
<h4 id="问题-8：在构造函数调用-super-并将-props-作为参数传入的作用是啥？"><a href="#问题-8：在构造函数调用-super-并将-props-作为参数传入的作用是啥？" class="headerlink" title="问题 8：在构造函数调用 super 并将 props 作为参数传入的作用是啥？"></a>问题 8：在构造函数调用 <code>super</code> 并将 <code>props</code> 作为参数传入的作用是啥？</h4><blockquote>
<p>难度: ⭐⭐</p>
</blockquote>
<h5 id="在调用-super-方法之前，子类构造函数无法使用this引用，ES6-子类也是如此。将-props-参数传递给-super-调用的主要原因是在子构造函数中能够通过this-props来获取传入的-props。"><a href="#在调用-super-方法之前，子类构造函数无法使用this引用，ES6-子类也是如此。将-props-参数传递给-super-调用的主要原因是在子构造函数中能够通过this-props来获取传入的-props。" class="headerlink" title="在调用 super() 方法之前，子类构造函数无法使用this引用，ES6 子类也是如此。将 props 参数传递给 super() 调用的主要原因是在子构造函数中能够通过this.props来获取传入的 props。"></a>在调用 <code>super()</code> 方法之前，子类构造函数无法使用<code>this</code>引用，ES6 子类也是如此。将 <code>props</code> 参数传递给 <code>super()</code> 调用的主要原因是在子构造函数中能够通过<code>this.props</code>来获取传入的 <code>props</code>。</h5><h5 id="传递props"><a href="#传递props" class="headerlink" title="传递props"></a>传递props</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class MyComponent extends React.Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    console.log(this.props);  // &#123; name: &apos;sudheer&apos;,age: 30 &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="没传递-props"><a href="#没传递-props" class="headerlink" title="没传递 props"></a><strong>没传递 props</strong></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class MyComponent extends React.Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super();</span><br><span class="line">    console.log(this.props); // undefined</span><br><span class="line">    // 但是 Props 参数仍然可用</span><br><span class="line">    console.log(props); // Prints &#123; name: &apos;sudheer&apos;,age: 30 &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    // 构造函数外部不受影响</span><br><span class="line">    console.log(this.props) // &#123; name: &apos;sudheer&apos;,age: 30 &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="上面示例揭示了一点。props-的行为只有在构造函数中是不同的，在构造函数之外也是一样的。"><a href="#上面示例揭示了一点。props-的行为只有在构造函数中是不同的，在构造函数之外也是一样的。" class="headerlink" title="上面示例揭示了一点。props 的行为只有在构造函数中是不同的，在构造函数之外也是一样的。"></a>上面示例揭示了一点。<code>props</code> 的行为只有在构造函数中是不同的，在构造函数之外也是一样的。</h6><h4 id="问题-9：什么是控制组件？"><a href="#问题-9：什么是控制组件？" class="headerlink" title="问题 9：什么是控制组件？"></a>问题 9：什么是控制组件？</h4><blockquote>
<p>难度: ⭐⭐⭐</p>
</blockquote>
<h5 id="在-HTML-中，表单元素如-、和-通常维护自己的状态，并根据用户输入进行更新。当用户提交表单时，来自上述元素的值将随表单一起发送。"><a href="#在-HTML-中，表单元素如-、和-通常维护自己的状态，并根据用户输入进行更新。当用户提交表单时，来自上述元素的值将随表单一起发送。" class="headerlink" title="在 HTML 中，表单元素如 、和``通常维护自己的状态，并根据用户输入进行更新。当用户提交表单时，来自上述元素的值将随表单一起发送。"></a>在 HTML 中，表单元素如 <code>、</code>和``通常维护自己的状态，并根据用户输入进行更新。当用户提交表单时，来自上述元素的值将随表单一起发送。</h5><h5 id="而-React-的工作方式则不同。包含表单的组件将跟踪其状态中的输入值，并在每次回调函数-例如onChange-触发时重新渲染组件，因为状态被更新。以这种方式由-React-控制其值的输入表单元素称为受控组件。"><a href="#而-React-的工作方式则不同。包含表单的组件将跟踪其状态中的输入值，并在每次回调函数-例如onChange-触发时重新渲染组件，因为状态被更新。以这种方式由-React-控制其值的输入表单元素称为受控组件。" class="headerlink" title="而 React 的工作方式则不同。包含表单的组件将跟踪其状态中的输入值，并在每次回调函数(例如onChange)触发时重新渲染组件，因为状态被更新。以这种方式由 React 控制其值的输入表单元素称为受控组件。"></a>而 React 的工作方式则不同。包含表单的组件将跟踪其状态中的输入值，并在每次回调函数(例如<code>onChange</code>)触发时重新渲染组件，因为状态被更新。以这种方式由 React 控制其值的输入表单元素称为<strong>受控组件</strong>。</h5><h4 id="问题-10：如何-React-createElement-？"><a href="#问题-10：如何-React-createElement-？" class="headerlink" title="问题 10：如何 React.createElement ？"></a>问题 10：如何 React.createElement ？</h4><blockquote>
<p>难度: ⭐⭐⭐</p>
</blockquote>
<h5 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const element = (</span><br><span class="line">  &lt;h1 className=&quot;greeting&quot;&gt;</span><br><span class="line">    Hello, world!</span><br><span class="line">  &lt;/h1&gt;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h5 id="上述代码如何使用-React-createElement-来实现"><a href="#上述代码如何使用-React-createElement-来实现" class="headerlink" title="上述代码如何使用 React.createElement 来实现:"></a>上述代码如何使用 <code>React.createElement</code> 来实现:</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const element = React.createElement(</span><br><span class="line">  &apos;h1&apos;,</span><br><span class="line">  &#123;className: &apos;greeting&apos;&#125;,</span><br><span class="line">  &apos;Hello, world!&apos;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h4 id="问题-11：讲讲什么是-JSX-？"><a href="#问题-11：讲讲什么是-JSX-？" class="headerlink" title="问题 11：讲讲什么是 JSX ？"></a>问题 11：讲讲什么是 JSX ？</h4><blockquote>
<p>难度: ⭐⭐⭐</p>
</blockquote>
<h5 id="当-Facebook-第一次发布-React-时，他们还引入了一种新的-JS-方言-JSX，将原始-HTML-模板嵌入到-JS-代码中。JSX-代码本身不能被浏览器读取，必须使用Babel和webpack等工具将其转换为传统的JS。很多开发人员就能无意识使用-JSX，因为它已经与-React-结合在一直了。"><a href="#当-Facebook-第一次发布-React-时，他们还引入了一种新的-JS-方言-JSX，将原始-HTML-模板嵌入到-JS-代码中。JSX-代码本身不能被浏览器读取，必须使用Babel和webpack等工具将其转换为传统的JS。很多开发人员就能无意识使用-JSX，因为它已经与-React-结合在一直了。" class="headerlink" title="当 Facebook 第一次发布 React 时，他们还引入了一种新的 JS 方言 JSX，将原始 HTML 模板嵌入到 JS 代码中。JSX 代码本身不能被浏览器读取，必须使用Babel和webpack等工具将其转换为传统的JS。很多开发人员就能无意识使用 JSX，因为它已经与 React 结合在一直了。"></a>当 <strong>Facebook</strong> 第一次发布 React 时，他们还引入了一种新的 JS 方言 <code>JSX</code>，将原始 HTML 模板嵌入到 JS 代码中。JSX 代码本身不能被浏览器读取，必须使用<code>Babel</code>和<code>webpack</code>等工具将其转换为传统的JS。很多开发人员就能无意识使用 JSX，因为它已经与 React 结合在一直了。</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class MyComponent extends React.Component &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    let props = this.props;</span><br><span class="line">    return (</span><br><span class="line">      &lt;p className=&quot;my-component&quot;&gt;</span><br><span class="line">      &lt;a href=&#123;props.url&#125;&gt;&#123;props.name&#125;&lt;/a&gt;</span><br><span class="line">      &lt;/p&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="问题-13：为什么不直接更新-state-呢"><a href="#问题-13：为什么不直接更新-state-呢" class="headerlink" title="问题 13：为什么不直接更新 state 呢 ?"></a>问题 13：为什么不直接更新 <code>state</code> 呢 ?</h4><blockquote>
<p>难度: ⭐⭐⭐</p>
</blockquote>
<h5 id="如果试图直接更新-state-，则不会重新渲染组件。"><a href="#如果试图直接更新-state-，则不会重新渲染组件。" class="headerlink" title="如果试图直接更新 state ，则不会重新渲染组件。"></a>如果试图直接更新 <code>state</code> ，则不会重新渲染组件。</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 错误</span><br><span class="line"> This.state.message = &apos;Hello world&apos;;</span><br></pre></td></tr></table></figure>

<h5 id="需要使用setState-方法来更新-state。它调度对组件state对象的更新。当state改变时，组件通过重新渲染来响应："><a href="#需要使用setState-方法来更新-state。它调度对组件state对象的更新。当state改变时，组件通过重新渲染来响应：" class="headerlink" title="需要使用setState()方法来更新 state。它调度对组件state对象的更新。当state改变时，组件通过重新渲染来响应："></a>需要使用<code>setState()</code>方法来更新 <code>state</code>。它调度对组件<code>state</code>对象的更新。当<code>state</code>改变时，组件通过重新渲染来响应：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 正确做法</span><br><span class="line">This.setState(&#123;message: ‘Hello World’&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="问题-14：React-组件生命周期有哪些不同阶段？"><a href="#问题-14：React-组件生命周期有哪些不同阶段？" class="headerlink" title="问题 14：React 组件生命周期有哪些不同阶段？"></a>问题 14：React 组件生命周期有哪些不同阶段？</h4><blockquote>
<p>难度: ⭐⭐⭐</p>
</blockquote>
<h6 id="在组件生命周期中有四个不同的阶段："><a href="#在组件生命周期中有四个不同的阶段：" class="headerlink" title="在组件生命周期中有四个不同的阶段："></a>在组件生命周期中有四个不同的阶段：</h6><ol>
<li><strong>Initialization</strong>：在这个阶段，组件准备设置初始化状态和默认属性。</li>
<li><strong>Mounting</strong>：react 组件已经准备好挂载到浏览器 DOM 中。这个阶段包括<code>componentWillMount</code>和<code>componentDidMount</code>生命周期方法。</li>
<li><strong>Updating</strong>：在这个阶段，组件以两种方式更新，发送新的 props 和 state 状态。此阶段包括<code>shouldComponentUpdate</code>、<code>componentWillUpdate</code>和<code>componentDidUpdate</code>生命周期方法。</li>
<li><strong>Unmounting</strong>：在这个阶段，组件已经不再被需要了，它从浏览器 DOM 中卸载下来。这个阶段包含 <code>componentWillUnmount</code> 生命周期方法。</li>
</ol>
<p>除以上四个常用生命周期外，还有一个错误处理的阶段：</p>
<p><strong>Error Handling</strong>：在这个阶段，不论在渲染的过程中，还是在生命周期方法中或是在任何子组件的构造函数中发生错误，该组件都会被调用。这个阶段包含了 <code>componentDidCatch</code> 生命周期方法。</p>
<h4 id="问题-15：React-的生命周期方法有哪些？"><a href="#问题-15：React-的生命周期方法有哪些？" class="headerlink" title="问题 15：React 的生命周期方法有哪些？"></a>问题 15：React 的生命周期方法有哪些？</h4><blockquote>
<p>难度: ⭐⭐⭐</p>
</blockquote>
<ul>
<li><code>componentWillMount</code>:在渲染之前执行，用于根组件中的 App 级配置。</li>
<li><code>componentDidMount</code>：在第一次渲染之后执行，可以在这里做AJAX请求，DOM 的操作或状态更新以及设置事件监听器。</li>
<li><code>componentWillReceiveProps</code>：在初始化<code>render</code>的时候不会执行，它会在组件接受到新的状态(Props)时被触发，一般用于父组件状态更新时子组件的重新渲染</li>
<li><code>shouldComponentUpdate</code>：确定是否更新组件。默认情况下，它返回<code>true</code>。如果确定在 <code>state</code> 或 <code>props</code> 更新后组件不需要在重新渲染，则可以返回<code>false</code>，这是一个提高性能的方法。</li>
<li><code>componentWillUpdate</code>：在<code>shouldComponentUpdate</code>返回 <code>true</code> 确定要更新组件之前执行。</li>
<li><code>componentDidUpdate</code>：它主要用于更新DOM以响应<code>props</code>或<code>state</code>更改。</li>
<li><code>componentWillUnmount</code>：它用于取消任何的网络请求，或删除与组件关联的所有事件监听器。</li>
</ul>
<h4 id="问题-16：这三个点-…-在-React-干嘛用的？"><a href="#问题-16：这三个点-…-在-React-干嘛用的？" class="headerlink" title="问题 16：这三个点(…)在 React 干嘛用的？"></a>问题 16：这三个点(…)在 React 干嘛用的？</h4><blockquote>
<p>难度: ⭐⭐⭐</p>
</blockquote>
<h5 id="在React（使用JSX）代码中做什么？它叫什么？"><a href="#在React（使用JSX）代码中做什么？它叫什么？" class="headerlink" title="... 在React（使用JSX）代码中做什么？它叫什么？"></a><code>...</code> 在React（使用JSX）代码中做什么？它叫什么？</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Modal &#123;...this.props&#125; title=&apos;Modal heading&apos;  animation=&#123;false&#125;/&gt;</span><br></pre></td></tr></table></figure>

<h5 id="这个叫扩展操作符号或者展开操作符，例如，如果this-props包含a：1和b：2，则"><a href="#这个叫扩展操作符号或者展开操作符，例如，如果this-props包含a：1和b：2，则" class="headerlink" title="这个叫扩展操作符号或者展开操作符，例如，如果this.props包含a：1和b：2，则"></a>这个叫扩展操作符号或者展开操作符，例如，如果<code>this.props</code>包含<code>a：1</code>和<code>b：2</code>，则</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Modal &#123;...this.props&#125; title=&apos;Modal heading&apos; animation=&#123;false&#125;&gt;</span><br></pre></td></tr></table></figure>

<h5 id="等价于下面内容："><a href="#等价于下面内容：" class="headerlink" title="等价于下面内容："></a>等价于下面内容：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Modal a=&#123;this.props.a&#125; b=&#123;this.props.b&#125; title=&apos;Modal heading&apos; animation=&#123;false&#125;&gt;</span><br></pre></td></tr></table></figure>

<h5 id="扩展符号不仅适用于该用例，而且对于创建具有现有对象的大多数（或全部）属性的新对象非常方便，在更新state-咱们就经常这么做："><a href="#扩展符号不仅适用于该用例，而且对于创建具有现有对象的大多数（或全部）属性的新对象非常方便，在更新state-咱们就经常这么做：" class="headerlink" title="扩展符号不仅适用于该用例，而且对于创建具有现有对象的大多数（或全部）属性的新对象非常方便，在更新state 咱们就经常这么做："></a>扩展符号不仅适用于该用例，而且对于创建具有现有对象的大多数（或全部）属性的新对象非常方便，在更新<code>state</code> 咱们就经常这么做：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">this.setState(prevState =&gt; &#123;</span><br><span class="line">    return &#123;foo: &#123;...prevState.foo, a: &quot;updated&quot;&#125;&#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="问题-17：使用-React-Hooks-好处是啥？"><a href="#问题-17：使用-React-Hooks-好处是啥？" class="headerlink" title="问题 17：使用 React Hooks 好处是啥？"></a>问题 17：使用 React Hooks 好处是啥？</h4><blockquote>
<p>难度: ⭐⭐⭐</p>
</blockquote>
<h5 id="首先，Hooks-通常支持提取和重用跨多个组件通用的有状态逻辑，而无需承担高阶组件或渲染-props-的负担。Hooks-可以轻松地操作函数组件的状态，而不需要将它们转换为类组件。"><a href="#首先，Hooks-通常支持提取和重用跨多个组件通用的有状态逻辑，而无需承担高阶组件或渲染-props-的负担。Hooks-可以轻松地操作函数组件的状态，而不需要将它们转换为类组件。" class="headerlink" title="首先，Hooks 通常支持提取和重用跨多个组件通用的有状态逻辑，而无需承担高阶组件或渲染 props 的负担。Hooks 可以轻松地操作函数组件的状态，而不需要将它们转换为类组件。"></a>首先，Hooks 通常支持提取和重用跨多个组件通用的有状态逻辑，而无需承担高阶组件或渲染 <code>props</code> 的负担。<code>Hooks</code> 可以轻松地操作函数组件的状态，而不需要将它们转换为类组件。</h5><h5 id="Hooks-在类中不起作用，通过使用它们，咱们可以完全避免使用生命周期方法，例如-componentDidMount、componentDidUpdate、componentWillUnmount。相反，使用像useEffect这样的内置钩子。"><a href="#Hooks-在类中不起作用，通过使用它们，咱们可以完全避免使用生命周期方法，例如-componentDidMount、componentDidUpdate、componentWillUnmount。相反，使用像useEffect这样的内置钩子。" class="headerlink" title="Hooks 在类中不起作用，通过使用它们，咱们可以完全避免使用生命周期方法，例如 componentDidMount、componentDidUpdate、componentWillUnmount。相反，使用像useEffect这样的内置钩子。"></a>Hooks 在类中不起作用，通过使用它们，咱们可以完全避免使用生命周期方法，例如 <code>componentDidMount</code>、<code>componentDidUpdate</code>、<code>componentWillUnmount</code>。相反，使用像<code>useEffect</code>这样的内置钩子。</h5><h4 id="问题-18：什么是-React-Hooks？"><a href="#问题-18：什么是-React-Hooks？" class="headerlink" title="问题 18：什么是 React Hooks？"></a>问题 18：什么是 React Hooks？</h4><blockquote>
<p>难度: ⭐⭐⭐</p>
</blockquote>
<h5 id="Hooks是-React-16-8-中的新添加内容。它们允许在不编写类的情况下使用state和其他-React-特性。使用-Hooks，可以从组件中提取有状态逻辑，这样就可以独立地测试和重用它。Hooks-允许咱们在不改变组件层次结构的情况下重用有状态逻辑，这样在许多组件之间或与社区共享-Hooks-变得很容易。"><a href="#Hooks是-React-16-8-中的新添加内容。它们允许在不编写类的情况下使用state和其他-React-特性。使用-Hooks，可以从组件中提取有状态逻辑，这样就可以独立地测试和重用它。Hooks-允许咱们在不改变组件层次结构的情况下重用有状态逻辑，这样在许多组件之间或与社区共享-Hooks-变得很容易。" class="headerlink" title="Hooks是 React 16.8 中的新添加内容。它们允许在不编写类的情况下使用state和其他 React 特性。使用 Hooks，可以从组件中提取有状态逻辑，这样就可以独立地测试和重用它。Hooks 允许咱们在不改变组件层次结构的情况下重用有状态逻辑，这样在许多组件之间或与社区共享 Hooks 变得很容易。"></a><strong>Hooks</strong>是 React 16.8 中的新添加内容。它们允许在不编写类的情况下使用<code>state</code>和其他 React 特性。使用 Hooks，可以从组件中提取有状态逻辑，这样就可以独立地测试和重用它。Hooks 允许咱们在不改变组件层次结构的情况下重用有状态逻辑，这样在许多组件之间或与社区共享 Hooks 变得很容易。</h5><h4 id="问题-19：React-中的-useState-是什么？"><a href="#问题-19：React-中的-useState-是什么？" class="headerlink" title="问题 19：React 中的 useState() 是什么？"></a>问题 19：React 中的 <code>useState()</code> 是什么？</h4><blockquote>
<p>难度: ⭐⭐⭐</p>
</blockquote>
<h5 id="下面说明useState-0-的用途："><a href="#下面说明useState-0-的用途：" class="headerlink" title="下面说明useState(0)的用途："></a>下面说明<code>useState(0)</code>的用途：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const [count, setCounter] = useState(0);</span><br><span class="line">const [moreStuff, setMoreStuff] = useState(...);</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">const setCount = () =&gt; &#123;</span><br><span class="line">    setCounter(count + 1);</span><br><span class="line">    setMoreStuff(...);</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="useState-是一个内置的-React-Hook。useState-0-返回一个元组，其中第一个参数count是计数器的当前状态，setCounter-提供更新计数器状态的方法。"><a href="#useState-是一个内置的-React-Hook。useState-0-返回一个元组，其中第一个参数count是计数器的当前状态，setCounter-提供更新计数器状态的方法。" class="headerlink" title="useState 是一个内置的 React Hook。useState(0) 返回一个元组，其中第一个参数count是计数器的当前状态，setCounter 提供更新计数器状态的方法。"></a><code>useState</code> 是一个内置的 React Hook。<code>useState(0)</code> 返回一个元组，其中第一个参数<code>count</code>是计数器的当前状态，<code>setCounter</code> 提供更新计数器状态的方法。</h5><h5 id="咱们可以在任何地方使用setCounter方法更新计数状态-在这种情况下，咱们在setCount函数内部使用它可以做更多的事情，使用-Hooks，能够使咱们的代码保持更多功能，还可以避免过多使用基于类的组件。"><a href="#咱们可以在任何地方使用setCounter方法更新计数状态-在这种情况下，咱们在setCount函数内部使用它可以做更多的事情，使用-Hooks，能够使咱们的代码保持更多功能，还可以避免过多使用基于类的组件。" class="headerlink" title="咱们可以在任何地方使用setCounter方法更新计数状态-在这种情况下，咱们在setCount函数内部使用它可以做更多的事情，使用 Hooks，能够使咱们的代码保持更多功能，还可以避免过多使用基于类的组件。"></a>咱们可以在任何地方使用<code>setCounter</code>方法更新计数状态-在这种情况下，咱们在<code>setCount</code>函数内部使用它可以做更多的事情，使用 Hooks，能够使咱们的代码保持更多功能，还可以避免过多使用基于类的组件。</h5><h4 id="问题-20：React-中的StrictMode-严格模式-是什么？？"><a href="#问题-20：React-中的StrictMode-严格模式-是什么？？" class="headerlink" title="问题 20：React 中的StrictMode(严格模式)是什么？？"></a>问题 20：React 中的StrictMode(严格模式)是什么？？</h4><blockquote>
<p>难度: ⭐⭐⭐</p>
</blockquote>
<p>React 的<code>StrictMode</code>是一种辅助组件，可以帮助咱们编写更好的 react 组件，可以使用``包装一组组件，并且可以帮咱们以下检查：</p>
<ul>
<li>验证内部组件是否遵循某些推荐做法，如果没有，会在控制台给出警告。</li>
<li>验证是否使用的已经废弃的方法，如果有，会在控制台给出警告。</li>
<li>通过识别潜在的风险预防一些副作用。</li>
</ul>
<h4 id="问题-21：为什么类方法需要绑定到类实例？"><a href="#问题-21：为什么类方法需要绑定到类实例？" class="headerlink" title="问题 21：为什么类方法需要绑定到类实例？"></a>问题 21：为什么类方法需要绑定到类实例？</h4><blockquote>
<p>难度: ⭐⭐⭐</p>
</blockquote>
<h5 id="在-JS-中，this-值会根据当前上下文变化。在-React-类组件方法中，开发人员通常希望-this-引用组件的当前实例，因此有必要将这些方法绑定到实例。通常这是在构造函数中完成的"><a href="#在-JS-中，this-值会根据当前上下文变化。在-React-类组件方法中，开发人员通常希望-this-引用组件的当前实例，因此有必要将这些方法绑定到实例。通常这是在构造函数中完成的" class="headerlink" title="在 JS 中，this 值会根据当前上下文变化。在 React 类组件方法中，开发人员通常希望 this 引用组件的当前实例，因此有必要将这些方法绑定到实例。通常这是在构造函数中完成的:"></a>在 JS 中，<code>this</code> 值会根据当前上下文变化。在 React 类组件方法中，开发人员通常希望 <code>this</code> 引用组件的当前实例，因此有必要将这些方法绑定到实例。通常这是在构造函数中完成的:</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class SubmitButton extends React.Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.state = &#123;</span><br><span class="line">      isFormSubmitted: false</span><br><span class="line">    &#125;;</span><br><span class="line">    this.handleSubmit = this.handleSubmit.bind(this);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleSubmit() &#123;</span><br><span class="line">    this.setState(&#123;</span><br><span class="line">      isFormSubmitted: true</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;button onClick=&#123;this.handleSubmit&#125;&gt;Submit&lt;/button&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="问题-22：什么是-prop-drilling，如何避免？"><a href="#问题-22：什么是-prop-drilling，如何避免？" class="headerlink" title="问题 22：什么是 prop drilling，如何避免？"></a>问题 22：什么是 prop drilling，如何避免？</h4><blockquote>
<p>难度: ⭐⭐⭐</p>
</blockquote>
<h5 id="在构建-React-应用程序时，在多层嵌套组件来使用另一个嵌套组件提供的数据。最简单的方法是将一个-prop-从每个组件一层层的传递下去，从源组件传递到深层嵌套组件，这叫做prop-drilling。"><a href="#在构建-React-应用程序时，在多层嵌套组件来使用另一个嵌套组件提供的数据。最简单的方法是将一个-prop-从每个组件一层层的传递下去，从源组件传递到深层嵌套组件，这叫做prop-drilling。" class="headerlink" title="在构建 React 应用程序时，在多层嵌套组件来使用另一个嵌套组件提供的数据。最简单的方法是将一个 prop 从每个组件一层层的传递下去，从源组件传递到深层嵌套组件，这叫做prop drilling。"></a>在构建 React 应用程序时，在多层嵌套组件来使用另一个嵌套组件提供的数据。最简单的方法是将一个 <code>prop</code> 从每个组件一层层的传递下去，从源组件传递到深层嵌套组件，这叫做<strong>prop drilling</strong>。</h5><h5 id="prop-drilling的主要缺点是原本不需要数据的组件变得不必要地复杂，并且难以维护。"><a href="#prop-drilling的主要缺点是原本不需要数据的组件变得不必要地复杂，并且难以维护。" class="headerlink" title="prop drilling的主要缺点是原本不需要数据的组件变得不必要地复杂，并且难以维护。"></a><code>prop drilling</code>的主要缺点是原本不需要数据的组件变得不必要地复杂，并且难以维护。</h5><h5 id="为了避免prop-drilling，一种常用的方法是使用React-Context。通过定义提供数据的Provider组件，并允许嵌套的组件通过Consumer组件或useContext-Hook-使用上下文数据。"><a href="#为了避免prop-drilling，一种常用的方法是使用React-Context。通过定义提供数据的Provider组件，并允许嵌套的组件通过Consumer组件或useContext-Hook-使用上下文数据。" class="headerlink" title="为了避免prop drilling，一种常用的方法是使用React Context。通过定义提供数据的Provider组件，并允许嵌套的组件通过Consumer组件或useContext Hook 使用上下文数据。"></a>为了避免<code>prop drilling</code>，一种常用的方法是使用<strong>React Context</strong>。通过定义提供数据的<code>Provider</code>组件，并允许嵌套的组件通过<code>Consumer</code>组件或<code>useContext</code> Hook 使用上下文数据。</h5><h4 id="问题-23：描述-Flux-与-MVC？"><a href="#问题-23：描述-Flux-与-MVC？" class="headerlink" title="问题 23：描述 Flux 与 MVC？"></a>问题 23：描述 Flux 与 MVC？</h4><blockquote>
<p>难度: ⭐⭐⭐</p>
</blockquote>
<h6 id="传统的-MVC-模式在分离数据-Model-、UI-View和逻辑-Controller-方面工作得很好，但是-MVC-架构经常遇到两个主要问题"><a href="#传统的-MVC-模式在分离数据-Model-、UI-View和逻辑-Controller-方面工作得很好，但是-MVC-架构经常遇到两个主要问题" class="headerlink" title="传统的 MVC 模式在分离数据(Model)、UI(View和逻辑(Controller)方面工作得很好，但是 MVC 架构经常遇到两个主要问题:"></a>传统的 MVC 模式在分离数据(Model)、UI(View和逻辑(Controller)方面工作得很好，但是 MVC 架构经常遇到两个主要问题:</h6><p><strong>数据流不够清晰</strong>:跨视图发生的级联更新常常会导致混乱的事件网络，难于调试。</p>
<p><strong>缺乏数据完整性</strong>:模型数据可以在任何地方发生突变，从而在整个UI中产生不可预测的结果。</p>
<h6 id="使用-Flux-模式的复杂用户界面不再遭受级联更新，任何给定的React-组件都能够根据-store-提供的数据重建其状态。Flux-模式还通过限制对共享数据的直接访问来加强数据完整性。"><a href="#使用-Flux-模式的复杂用户界面不再遭受级联更新，任何给定的React-组件都能够根据-store-提供的数据重建其状态。Flux-模式还通过限制对共享数据的直接访问来加强数据完整性。" class="headerlink" title="使用 Flux 模式的复杂用户界面不再遭受级联更新，任何给定的React 组件都能够根据 store 提供的数据重建其状态。Flux 模式还通过限制对共享数据的直接访问来加强数据完整性。"></a>使用 Flux 模式的复杂用户界面不再遭受级联更新，任何给定的React 组件都能够根据 <code>store</code> 提供的数据重建其状态。Flux 模式还通过限制对共享数据的直接访问来加强数据完整性。</h6><h4 id="问题-24：受控组件和非受控组件区别是啥？"><a href="#问题-24：受控组件和非受控组件区别是啥？" class="headerlink" title="问题 24：受控组件和非受控组件区别是啥？"></a>问题 24：受控组件和非受控组件区别是啥？</h4><blockquote>
<p>难度: ⭐⭐⭐</p>
</blockquote>
<ul>
<li><strong>受控组件</strong>是 React 控制中的组件，并且是表单数据真实的唯一来源。</li>
<li>非受控组件是由 DOM 处理表单数据的地方，而不是在 React 组件中。</li>
</ul>
<h5 id="尽管非受控组件通常更易于实现，因为只需使用refs即可从-DOM-中获取值，但通常建议优先选择受控制的组件，而不是非受控制的组件。"><a href="#尽管非受控组件通常更易于实现，因为只需使用refs即可从-DOM-中获取值，但通常建议优先选择受控制的组件，而不是非受控制的组件。" class="headerlink" title="尽管非受控组件通常更易于实现，因为只需使用refs即可从 DOM 中获取值，但通常建议优先选择受控制的组件，而不是非受控制的组件。"></a>尽管非受控组件通常更易于实现，因为只需使用<code>refs</code>即可从 DOM 中获取值，但通常建议优先选择受控制的组件，而不是非受控制的组件。</h5><h5 id="这样做的主要原因是受控组件支持即时字段验证，允许有条件地禁用-启用按钮，强制输入格式。"><a href="#这样做的主要原因是受控组件支持即时字段验证，允许有条件地禁用-启用按钮，强制输入格式。" class="headerlink" title="这样做的主要原因是受控组件支持即时字段验证，允许有条件地禁用/启用按钮，强制输入格式。"></a>这样做的主要原因是受控组件支持即时字段验证，允许有条件地禁用/启用按钮，强制输入格式。</h5><h4 id="问题-25：这段代码有什么问题吗？"><a href="#问题-25：这段代码有什么问题吗？" class="headerlink" title="问题 25：这段代码有什么问题吗？"></a>问题 25：这段代码有什么问题吗？</h4><blockquote>
<p>难度: ⭐⭐⭐⭐</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">this.setState((prevState, props) =&gt; &#123;</span><br><span class="line">  return &#123;</span><br><span class="line">    streak: prevState.streak + props.count</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h6 id="没有什么问题。这种方式很少被使用，咱们可以将一个函数传递给setState，该函数接收上一个-state-的值和当前的props，并返回一个新的状态，如果咱们需要根据以前的状态重新设置状态，推荐使用这种方式。"><a href="#没有什么问题。这种方式很少被使用，咱们可以将一个函数传递给setState，该函数接收上一个-state-的值和当前的props，并返回一个新的状态，如果咱们需要根据以前的状态重新设置状态，推荐使用这种方式。" class="headerlink" title="没有什么问题。这种方式很少被使用，咱们可以将一个函数传递给setState，该函数接收上一个 state 的值和当前的props，并返回一个新的状态，如果咱们需要根据以前的状态重新设置状态，推荐使用这种方式。"></a>没有什么问题。这种方式很少被使用，咱们可以将一个函数传递给<code>setState</code>，该函数接收上一个 <code>state</code> 的值和当前的<code>props</code>，并返回一个新的状态，如果咱们需要根据以前的状态重新设置状态，推荐使用这种方式。</h6><h4 id="问题-26：什么是-React-Context"><a href="#问题-26：什么是-React-Context" class="headerlink" title="问题 26：什么是 React Context?"></a>问题 26：什么是 React Context?</h4><blockquote>
<p>难度: ⭐⭐⭐⭐</p>
</blockquote>
<h5 id="Context-通过组件树提供了一个传递数据的方法，从而避免了在每一个层级手动的传递-props-属性。"><a href="#Context-通过组件树提供了一个传递数据的方法，从而避免了在每一个层级手动的传递-props-属性。" class="headerlink" title="Context 通过组件树提供了一个传递数据的方法，从而避免了在每一个层级手动的传递 props 属性。"></a><code>Context</code> 通过组件树提供了一个传递数据的方法，从而避免了在每一个层级手动的传递 <code>props</code> 属性。</h5><h4 id="问题-27：什么是-React-Fiber"><a href="#问题-27：什么是-React-Fiber" class="headerlink" title="问题 27：什么是 React Fiber?"></a>问题 27：什么是 React Fiber?</h4><blockquote>
<p>难度: ⭐⭐⭐⭐</p>
</blockquote>
<h5 id="Fiber-是-React-16-中新的协调引擎或重新实现核心算法。它的主要目标是支持虚拟DOM的增量渲染。React-Fiber-的目标是提高其在动画、布局、手势、暂停、中止或重用等方面的适用性，并为不同类型的更新分配优先级，以及新的并发原语。"><a href="#Fiber-是-React-16-中新的协调引擎或重新实现核心算法。它的主要目标是支持虚拟DOM的增量渲染。React-Fiber-的目标是提高其在动画、布局、手势、暂停、中止或重用等方面的适用性，并为不同类型的更新分配优先级，以及新的并发原语。" class="headerlink" title="Fiber 是 React 16 中新的协调引擎或重新实现核心算法。它的主要目标是支持虚拟DOM的增量渲染。React Fiber 的目标是提高其在动画、布局、手势、暂停、中止或重用等方面的适用性，并为不同类型的更新分配优先级，以及新的并发原语。"></a><strong>Fiber</strong> 是 React 16 中新的协调引擎或重新实现核心算法。它的主要目标是支持虚拟DOM的增量渲染。<strong>React Fiber</strong> 的目标是提高其在动画、布局、手势、暂停、中止或重用等方面的适用性，并为不同类型的更新分配优先级，以及新的并发原语。</h5><h5 id="React-Fiber-的目标是增强其在动画、布局和手势等领域的适用性。它的主要特性是增量渲染-能够将渲染工作分割成块，并将其分散到多个帧中。"><a href="#React-Fiber-的目标是增强其在动画、布局和手势等领域的适用性。它的主要特性是增量渲染-能够将渲染工作分割成块，并将其分散到多个帧中。" class="headerlink" title="React Fiber 的目标是增强其在动画、布局和手势等领域的适用性。它的主要特性是增量渲染:能够将渲染工作分割成块，并将其分散到多个帧中。"></a>React Fiber 的目标是增强其在动画、布局和手势等领域的适用性。它的主要特性是增量渲染:能够将渲染工作分割成块，并将其分散到多个帧中。</h5><h4 id="问题-28：如何在-ReactJS-的-Props上应用验证？"><a href="#问题-28：如何在-ReactJS-的-Props上应用验证？" class="headerlink" title="问题 28：如何在 ReactJS 的 Props上应用验证？"></a>问题 28：如何在 ReactJS 的 Props上应用验证？</h4><blockquote>
<p>难度: ⭐⭐⭐⭐</p>
</blockquote>
<h5 id="当应用程序在开发模式下运行时，React-将自动检查咱们在组件上设置的所有-props，以确保它们具有正确的数据类型。对于不正确的类型，开发模式下会在控制台中生成警告消息，而在生产模式中由于性能影响而禁用它。强制的-props-用-isRequired定义的。"><a href="#当应用程序在开发模式下运行时，React-将自动检查咱们在组件上设置的所有-props，以确保它们具有正确的数据类型。对于不正确的类型，开发模式下会在控制台中生成警告消息，而在生产模式中由于性能影响而禁用它。强制的-props-用-isRequired定义的。" class="headerlink" title="当应用程序在开发模式下运行时，React 将自动检查咱们在组件上设置的所有 props，以确保它们具有正确的数据类型。对于不正确的类型，开发模式下会在控制台中生成警告消息，而在生产模式中由于性能影响而禁用它。强制的 props 用 isRequired定义的。"></a>当应用程序在开发模式下运行时，React 将自动检查咱们在组件上设置的所有 <code>props</code>，以确保它们具有正确的数据类型。对于不正确的类型，开发模式下会在控制台中生成警告消息，而在生产模式中由于性能影响而禁用它。强制的 <code>props</code> 用 <code>isRequired</code>定义的。</h5><p>下面是一组预定义的 prop 类型:</p>
<ul>
<li>React.PropTypes.string</li>
<li>React.PropTypes.number</li>
<li>React.PropTypes.func</li>
<li>React.PropTypes.node</li>
<li>React.PropTypes.bool</li>
</ul>
<p>例如，咱们为用户组件定义了如下的<code>propTypes</code></p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">import PropTypes from &apos;prop-types&apos;;</span><br><span class="line"></span><br><span class="line">class User extends React.Component &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;h1&gt;Welcome, &#123;this.props.name&#125;&lt;/h1&gt;</span><br><span class="line">      &lt;h2&gt;Age, &#123;this.props.age&#125;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">User.propTypes = &#123;</span><br><span class="line">  name: PropTypes.string.isRequired,</span><br><span class="line">  age: PropTypes.number.isRequired</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="问题-29：在-React-中使用构造函数和-getInitialState-有什么区别？"><a href="#问题-29：在-React-中使用构造函数和-getInitialState-有什么区别？" class="headerlink" title="问题 29：在 React 中使用构造函数和 getInitialState 有什么区别？"></a>问题 29：在 React 中使用构造函数和 getInitialState 有什么区别？</h4><blockquote>
<p>难度: ⭐⭐⭐⭐</p>
</blockquote>
<h5 id="构造函数和getInitialState之间的区别就是ES6和ES5本身的区别。在使用ES6类时，应该在构造函数中初始化state，并在使用React-createClass时定义getInitialState方法。"><a href="#构造函数和getInitialState之间的区别就是ES6和ES5本身的区别。在使用ES6类时，应该在构造函数中初始化state，并在使用React-createClass时定义getInitialState方法。" class="headerlink" title="构造函数和getInitialState之间的区别就是ES6和ES5本身的区别。在使用ES6类时，应该在构造函数中初始化state，并在使用React.createClass时定义getInitialState方法。"></a>构造函数和<code>getInitialState</code>之间的区别就是<code>ES6</code>和<code>ES5</code>本身的区别。在使用<code>ES6</code>类时，应该在构造函数中初始化<code>state</code>，并在使用<code>React.createClass</code>时定义<code>getInitialState</code>方法。</h5> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class MyComponent extends React.Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.state = &#123; /* initial state */ &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="问题-30：如何有条件地向-React-组件添加属性？"><a href="#问题-30：如何有条件地向-React-组件添加属性？" class="headerlink" title="问题 30：如何有条件地向 React 组件添加属性？"></a>问题 30：如何有条件地向 React 组件添加属性？</h4><blockquote>
<p>难度: ⭐⭐⭐⭐</p>
</blockquote>
<h5 id="对于某些属性，React-非常聪明，如果传递给它的值是虚值，可以省略该属性。例如："><a href="#对于某些属性，React-非常聪明，如果传递给它的值是虚值，可以省略该属性。例如：" class="headerlink" title="对于某些属性，React 非常聪明，如果传递给它的值是虚值，可以省略该属性。例如："></a>对于某些属性，React 非常聪明，如果传递给它的值是虚值，可以省略该属性。例如：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var InputComponent = React.createClass(&#123;</span><br><span class="line">    render: function() &#123;</span><br><span class="line">      var required = true;</span><br><span class="line">      var disabled = false;</span><br><span class="line"></span><br><span class="line">      return (</span><br><span class="line">        &lt;input type=&quot;text&quot; disabled=&#123;disabled&#125; required=	  			&#123;required&#125; /&gt;</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>渲染结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=&quot;text&quot; required&gt;</span><br></pre></td></tr></table></figure>

<p>另一种可能的方法是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var condition = true;</span><br><span class="line"></span><br><span class="line">var component = (</span><br><span class="line">  &lt;p</span><br><span class="line">    value=&quot;foo&quot;</span><br><span class="line">    &#123; ...( condition &amp;&amp; &#123; disabled: true &#125; ) &#125; /&gt;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h4 id="问题-31：Hooks会取代-render-props-和高阶组件吗？"><a href="#问题-31：Hooks会取代-render-props-和高阶组件吗？" class="headerlink" title="问题 31：Hooks会取代 render props 和高阶组件吗？"></a>问题 31：Hooks会取代 <code>render props</code> 和高阶组件吗？</h4><blockquote>
<p>难度: ⭐⭐⭐⭐</p>
</blockquote>
<h5 id="通常，render-props和高阶组件仅渲染一个子组件。React团队认为，Hooks-是服务此用例的更简单方法。"><a href="#通常，render-props和高阶组件仅渲染一个子组件。React团队认为，Hooks-是服务此用例的更简单方法。" class="headerlink" title="通常，render props和高阶组件仅渲染一个子组件。React团队认为，Hooks 是服务此用例的更简单方法。"></a>通常，<code>render props</code>和高阶组件仅渲染一个子组件。React团队认为，Hooks 是服务此用例的更简单方法。</h5><h5 id="这两种模式仍然有一席之地-例如，一个虚拟的-scroller-组件可能有一个-renderItem-prop，或者一个可视化的容器组件可能有它自己的-DOM-结构-。但在大多数情况下，Hooks-就足够了，可以帮助减少树中的嵌套。"><a href="#这两种模式仍然有一席之地-例如，一个虚拟的-scroller-组件可能有一个-renderItem-prop，或者一个可视化的容器组件可能有它自己的-DOM-结构-。但在大多数情况下，Hooks-就足够了，可以帮助减少树中的嵌套。" class="headerlink" title="这两种模式仍然有一席之地(例如，一个虚拟的 scroller 组件可能有一个 renderItem prop，或者一个可视化的容器组件可能有它自己的 DOM 结构)。但在大多数情况下，Hooks 就足够了，可以帮助减少树中的嵌套。"></a>这两种模式仍然有一席之地(例如，一个虚拟的 <code>scroller</code> 组件可能有一个 <code>renderItem prop</code>，或者一个可视化的容器组件可能有它自己的 DOM 结构)。但在大多数情况下，Hooks 就足够了，可以帮助减少树中的嵌套。</h5><h4 id="问题-32：如何避免组件的重新渲染？"><a href="#问题-32：如何避免组件的重新渲染？" class="headerlink" title="问题 32：如何避免组件的重新渲染？"></a>问题 32：如何避免组件的重新渲染？</h4><blockquote>
<p>难度: ⭐⭐⭐⭐</p>
</blockquote>
<p>React 中最常见的问题之一是组件不必要地重新渲染。React 提供了两个方法，在这些情况下非常有用：</p>
<ul>
<li><code>React.memo()</code>:这可以防止不必要地重新渲染函数组件</li>
<li><code>PureComponent</code>:这可以防止不必要地重新渲染类组件</li>
</ul>
<h5 id="这两种方法都依赖于对传递给组件的props的浅比较，如果-props-没有改变，那么组件将不会重新渲染。虽然这两种工具都非常有用，但是浅比较会带来额外的性能损失，因此如果使用不当，这两种方法都会对性能产生负面影响。"><a href="#这两种方法都依赖于对传递给组件的props的浅比较，如果-props-没有改变，那么组件将不会重新渲染。虽然这两种工具都非常有用，但是浅比较会带来额外的性能损失，因此如果使用不当，这两种方法都会对性能产生负面影响。" class="headerlink" title="这两种方法都依赖于对传递给组件的props的浅比较，如果 props 没有改变，那么组件将不会重新渲染。虽然这两种工具都非常有用，但是浅比较会带来额外的性能损失，因此如果使用不当，这两种方法都会对性能产生负面影响。"></a>这两种方法都依赖于对传递给组件的<code>props</code>的浅比较，如果 <code>props</code> 没有改变，那么组件将不会重新渲染。虽然这两种工具都非常有用，但是浅比较会带来额外的性能损失，因此如果使用不当，这两种方法都会对性能产生负面影响。</h5><h5 id="通过使用-React-Profiler，可以在使用这些方法前后对性能进行测量，从而确保通过进行给定的更改来实际改进性能。"><a href="#通过使用-React-Profiler，可以在使用这些方法前后对性能进行测量，从而确保通过进行给定的更改来实际改进性能。" class="headerlink" title="通过使用 React Profiler，可以在使用这些方法前后对性能进行测量，从而确保通过进行给定的更改来实际改进性能。"></a>通过使用 <strong>React Profiler</strong>，可以在使用这些方法前后对性能进行测量，从而确保通过进行给定的更改来实际改进性能。</h5><h4 id="问题-33：什么是纯函数？"><a href="#问题-33：什么是纯函数？" class="headerlink" title="问题 33：什么是纯函数？"></a>问题 33：什么是纯函数？</h4><blockquote>
<p>难度: ⭐⭐⭐⭐⭐</p>
</blockquote>
<h5 id="纯函数是不依赖并且不会在其作用域之外修改变量状态的函数。本质上，纯函数始终在给定相同参数的情况下返回相同结果。"><a href="#纯函数是不依赖并且不会在其作用域之外修改变量状态的函数。本质上，纯函数始终在给定相同参数的情况下返回相同结果。" class="headerlink" title="纯函数是不依赖并且不会在其作用域之外修改变量状态的函数。本质上，纯函数始终在给定相同参数的情况下返回相同结果。"></a>纯函数是不依赖并且不会在其作用域之外修改变量状态的函数。本质上，纯函数始终在给定相同参数的情况下返回相同结果。</h5><h4 id="问题-34：当调用setState时，React-render-是如何工作的？"><a href="#问题-34：当调用setState时，React-render-是如何工作的？" class="headerlink" title="问题 34：当调用setState时，React render 是如何工作的？"></a>问题 34：当调用<code>setState</code>时，React <code>render</code> 是如何工作的？</h4><blockquote>
<p>难度: ⭐⭐⭐⭐⭐</p>
</blockquote>
<h5 id="咱们可以将”render“分为两个步骤："><a href="#咱们可以将”render“分为两个步骤：" class="headerlink" title="咱们可以将”render“分为两个步骤："></a>咱们可以将”<code>render</code>“分为两个步骤：</h5><ol>
<li><h5 id="虚拟-DOM-渲染-当render方法被调用时，它返回一个新的组件的虚拟-DOM-结构。当调用setState-时，render会被再次调用，因为默认情况下shouldComponentUpdate总是返回true，所以默认情况下-React-是没有优化的。"><a href="#虚拟-DOM-渲染-当render方法被调用时，它返回一个新的组件的虚拟-DOM-结构。当调用setState-时，render会被再次调用，因为默认情况下shouldComponentUpdate总是返回true，所以默认情况下-React-是没有优化的。" class="headerlink" title="虚拟 DOM 渲染:当render方法被调用时，它返回一个新的组件的虚拟 DOM 结构。当调用setState()时，render会被再次调用，因为默认情况下shouldComponentUpdate总是返回true，所以默认情况下 React 是没有优化的。"></a>虚拟 DOM 渲染:当<code>render</code>方法被调用时，它返回一个新的组件的虚拟 DOM 结构。当调用<code>setState()</code>时，<code>render</code>会被再次调用，因为默认情况下<code>shouldComponentUpdate</code>总是返回<code>true</code>，所以默认情况下 React 是没有优化的。</h5></li>
<li><h5 id="原生-DOM-渲染-React-只会在虚拟DOM中修改真实DOM节点，而且修改的次数非常少——这是很棒的React特性，它优化了真实DOM的变化，使React变得更快。"><a href="#原生-DOM-渲染-React-只会在虚拟DOM中修改真实DOM节点，而且修改的次数非常少——这是很棒的React特性，它优化了真实DOM的变化，使React变得更快。" class="headerlink" title="原生 DOM 渲染:React 只会在虚拟DOM中修改真实DOM节点，而且修改的次数非常少——这是很棒的React特性，它优化了真实DOM的变化，使React变得更快。"></a>原生 DOM 渲染:React 只会在虚拟DOM中修改真实DOM节点，而且修改的次数非常少——这是很棒的React特性，它优化了真实DOM的变化，使React变得更快。</h5></li>
</ol>
<h4 id="问题-35：如何避免在React重新绑定实例？"><a href="#问题-35：如何避免在React重新绑定实例？" class="headerlink" title="问题 35：如何避免在React重新绑定实例？"></a>问题 35：如何避免在React重新绑定实例？</h4><blockquote>
<p>难度: ⭐⭐⭐⭐⭐</p>
</blockquote>
<h6 id="有几种常用方法可以避免在-React-中绑定方法："><a href="#有几种常用方法可以避免在-React-中绑定方法：" class="headerlink" title="有几种常用方法可以避免在 React 中绑定方法："></a>有几种常用方法可以避免在 React 中绑定方法：</h6><h6 id="1-将事件处理程序定义为内联箭头函数"><a href="#1-将事件处理程序定义为内联箭头函数" class="headerlink" title="1.将事件处理程序定义为内联箭头函数"></a>1.将事件处理程序定义为内联箭头函数</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class SubmitButton extends React.Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.state = &#123;</span><br><span class="line">      isFormSubmitted: false</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;button onClick=&#123;() =&gt; &#123;</span><br><span class="line">        this.setState(&#123; isFormSubmitted: true &#125;);</span><br><span class="line">      &#125;&#125;&gt;Submit&lt;/button&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="2-使用箭头函数来定义方法："><a href="#2-使用箭头函数来定义方法：" class="headerlink" title="2.使用箭头函数来定义方法："></a>2.使用箭头函数来定义方法：</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class SubmitButton extends React.Component &#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    isFormSubmitted: false</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleSubmit = () =&gt; &#123;</span><br><span class="line">    this.setState(&#123;</span><br><span class="line">      isFormSubmitted: true</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;button onClick=&#123;this.handleSubmit&#125;&gt;Submit&lt;/button&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="3-使用带有-Hooks-的函数组件"><a href="#3-使用带有-Hooks-的函数组件" class="headerlink" title="3.使用带有 Hooks 的函数组件"></a>3.使用带有 Hooks 的函数组件</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const SubmitButton = () =&gt; &#123;</span><br><span class="line">  const [isFormSubmitted, setIsFormSubmitted] = useState(false);</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;button onClick=&#123;() =&gt; &#123;</span><br><span class="line">        setIsFormSubmitted(true);</span><br><span class="line">    &#125;&#125;&gt;Submit&lt;/button&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>






    </div>

    
    
    
    <div>
      
      <div>
    
        <div style="text-align:center;color: #ccc;font-size:14px;">-------------本文结束<i class="fa fa-paw"></i>感谢您的阅读-------------</div>
    
</div>
      
    </div>
        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>Hson zhou
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="http://yoursite.com/2020/01/04/React%E7%9F%A5%E8%AF%86%E7%82%B9%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA/" title="React知识点查漏补缺">http://yoursite.com/2020/01/04/React知识点查漏补缺/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/zh-CN" rel="noopener" target="_blank"><i class="fa fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2019/12/28/webpack-vue-cil%E6%A1%86%E6%9E%B6%E7%9A%84%E6%90%AD%E5%BB%BA/" rel="prev" title="webpack+vue-cil框架的搭建">
      <i class="fa fa-chevron-left"></i> webpack+vue-cil框架的搭建
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/01/07/JS%E9%9D%A2%E8%AF%95%E5%B8%B8%E5%AE%A2%EF%BC%8C%E9%98%B2%E6%8A%96%E4%B8%8E%E8%8A%82%E6%B5%81/" rel="next" title="JS面试常客，防抖与节流">
      JS面试常客，防抖与节流 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#React知识点查漏补缺"><span class="nav-text">React知识点查漏补缺</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#问题1：什么是虚拟DOM？"><span class="nav-text">问题1：什么是虚拟DOM？</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#虚拟-DOM-VDOM-是真实-DOM-在内存中的表示。UI-的表示形式保存在内存中，并与实际的-DOM-同步。这是一个发生在渲染函数被调用和元素在屏幕上显示之间的步骤，整个过程被称为调和。"><span class="nav-text">虚拟 DOM (VDOM)是真实 DOM 在内存中的表示。UI 的表示形式保存在内存中，并与实际的 DOM 同步。这是一个发生在渲染函数被调用和元素在屏幕上显示之间的步骤，整个过程被称为调和。</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#问题2：类组件和函数组件之间的区别是啥"><span class="nav-text">问题2：类组件和函数组件之间的区别是啥?</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#函数组件和类组件当然是有区别的，而且函数组件的性能比类组件的性能要高，因为类组件使用的时候要实例化，而函数组件直接执行函数取返回结果即可，为了提高性能，尽量使用函数组件。"><span class="nav-text">函数组件和类组件当然是有区别的，而且函数组件的性能比类组件的性能要高，因为类组件使用的时候要实例化，而函数组件直接执行函数取返回结果即可，为了提高性能，尽量使用函数组件。</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#问题3-React中refs干嘛用的？"><span class="nav-text">问题3 React中refs干嘛用的？</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Refs-提供了一种访问在render方法中创建的-DOM-节点或者-React-元素的方法。在典型的数据流中，props-是父子组件交互的唯一方式，想要修改子组件，需要使用新的pros重新渲染它。凡事有例外，某些情况下咱们需要在典型数据流外，强制修改子代，这个时候可以使用-Refs。"><span class="nav-text">Refs 提供了一种访问在render方法中创建的 DOM 节点或者 React 元素的方法。在典型的数据流中，props 是父子组件交互的唯一方式，想要修改子组件，需要使用新的pros重新渲染它。凡事有例外，某些情况下咱们需要在典型数据流外，强制修改子代，这个时候可以使用 Refs。</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#咱们可以在组件添加一个-ref-属性来使用，该属性的值是一个回调函数，接收作为其第一个参数的底层-DOM-元素或组件的挂载实例。"><span class="nav-text">咱们可以在组件添加一个 ref 属性来使用，该属性的值是一个回调函数，接收作为其第一个参数的底层 DOM 元素或组件的挂载实例。</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#请注意，input-元素有一个ref属性，它的值是一个函数。该函数接收输入的实际-DOM-元素，然后将其放在实例上，这样就可以在-handleSubmit-函数内部访问它。"><span class="nav-text">请注意，input 元素有一个ref属性，它的值是一个函数。该函数接收输入的实际 DOM 元素，然后将其放在实例上，这样就可以在 handleSubmit 函数内部访问它。</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#经常被误解的只有在类组件中才能使用-refs，但是refs也可以通过利用-JS-中的闭包与函数组件一起使用。"><span class="nav-text">经常被误解的只有在类组件中才能使用 refs，但是refs也可以通过利用 JS 中的闭包与函数组件一起使用。</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#问题4-在React中如何处理事件"><span class="nav-text">问题4 在React中如何处理事件</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#为了解决跨浏览器的兼容性问题，SyntheticEvent-实例将被传递给你的事件处理函数，SyntheticEvent是-React-跨浏览器的浏览器原生事件包装器，它还拥有和浏览器原生事件相同的接口，包括-stopPropagation-和-preventDefault-。"><span class="nav-text">为了解决跨浏览器的兼容性问题，SyntheticEvent 实例将被传递给你的事件处理函数，SyntheticEvent是 React 跨浏览器的浏览器原生事件包装器，它还拥有和浏览器原生事件相同的接口，包括 stopPropagation() 和 preventDefault()。</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#比较有趣的是，React-实际上并不将事件附加到子节点本身。React-使用单个事件侦听器侦听顶层的所有事件。这对性能有好处，也意味着-React-在更新-DOM-时不需要跟踪事件监听器。"><span class="nav-text">比较有趣的是，React 实际上并不将事件附加到子节点本身。React 使用单个事件侦听器侦听顶层的所有事件。这对性能有好处，也意味着 React 在更新 DOM 时不需要跟踪事件监听器。</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#问题5-state和props区别是啥"><span class="nav-text">问题5 state和props区别是啥?</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#props和state是普通的-JS-对象。虽然它们都包含影响渲染输出的信息，但是它们在组件方面的功能是不同的。即"><span class="nav-text">props和state是普通的 JS 对象。虽然它们都包含影响渲染输出的信息，但是它们在组件方面的功能是不同的。即</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#问题5-如何创建refs"><span class="nav-text">问题5 如何创建refs</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Refs-是使用-React-createRef-创建的，并通过-ref-属性附加到-React-元素。在构造组件时，通常将-Refs-分配给实例属性，以便可以在整个组件中引用它们。"><span class="nav-text">Refs 是使用 React.createRef() 创建的，并通过 ref 属性附加到 React 元素。在构造组件时，通常将 Refs 分配给实例属性，以便可以在整个组件中引用它们。</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#问题7-什么是高阶组件"><span class="nav-text">问题7 什么是高阶组件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#问题-8：在构造函数调用-super-并将-props-作为参数传入的作用是啥？"><span class="nav-text">问题 8：在构造函数调用 super 并将 props 作为参数传入的作用是啥？</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#在调用-super-方法之前，子类构造函数无法使用this引用，ES6-子类也是如此。将-props-参数传递给-super-调用的主要原因是在子构造函数中能够通过this-props来获取传入的-props。"><span class="nav-text">在调用 super() 方法之前，子类构造函数无法使用this引用，ES6 子类也是如此。将 props 参数传递给 super() 调用的主要原因是在子构造函数中能够通过this.props来获取传入的 props。</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#传递props"><span class="nav-text">传递props</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#没传递-props"><span class="nav-text">没传递 props</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#上面示例揭示了一点。props-的行为只有在构造函数中是不同的，在构造函数之外也是一样的。"><span class="nav-text">上面示例揭示了一点。props 的行为只有在构造函数中是不同的，在构造函数之外也是一样的。</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#问题-9：什么是控制组件？"><span class="nav-text">问题 9：什么是控制组件？</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#在-HTML-中，表单元素如-、和-通常维护自己的状态，并根据用户输入进行更新。当用户提交表单时，来自上述元素的值将随表单一起发送。"><span class="nav-text">在 HTML 中，表单元素如 、和``通常维护自己的状态，并根据用户输入进行更新。当用户提交表单时，来自上述元素的值将随表单一起发送。</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#而-React-的工作方式则不同。包含表单的组件将跟踪其状态中的输入值，并在每次回调函数-例如onChange-触发时重新渲染组件，因为状态被更新。以这种方式由-React-控制其值的输入表单元素称为受控组件。"><span class="nav-text">而 React 的工作方式则不同。包含表单的组件将跟踪其状态中的输入值，并在每次回调函数(例如onChange)触发时重新渲染组件，因为状态被更新。以这种方式由 React 控制其值的输入表单元素称为受控组件。</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#问题-10：如何-React-createElement-？"><span class="nav-text">问题 10：如何 React.createElement ？</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#问题："><span class="nav-text">问题：</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#上述代码如何使用-React-createElement-来实现"><span class="nav-text">上述代码如何使用 React.createElement 来实现:</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#问题-11：讲讲什么是-JSX-？"><span class="nav-text">问题 11：讲讲什么是 JSX ？</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#当-Facebook-第一次发布-React-时，他们还引入了一种新的-JS-方言-JSX，将原始-HTML-模板嵌入到-JS-代码中。JSX-代码本身不能被浏览器读取，必须使用Babel和webpack等工具将其转换为传统的JS。很多开发人员就能无意识使用-JSX，因为它已经与-React-结合在一直了。"><span class="nav-text">当 Facebook 第一次发布 React 时，他们还引入了一种新的 JS 方言 JSX，将原始 HTML 模板嵌入到 JS 代码中。JSX 代码本身不能被浏览器读取，必须使用Babel和webpack等工具将其转换为传统的JS。很多开发人员就能无意识使用 JSX，因为它已经与 React 结合在一直了。</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#问题-13：为什么不直接更新-state-呢"><span class="nav-text">问题 13：为什么不直接更新 state 呢 ?</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#如果试图直接更新-state-，则不会重新渲染组件。"><span class="nav-text">如果试图直接更新 state ，则不会重新渲染组件。</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#需要使用setState-方法来更新-state。它调度对组件state对象的更新。当state改变时，组件通过重新渲染来响应："><span class="nav-text">需要使用setState()方法来更新 state。它调度对组件state对象的更新。当state改变时，组件通过重新渲染来响应：</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#问题-14：React-组件生命周期有哪些不同阶段？"><span class="nav-text">问题 14：React 组件生命周期有哪些不同阶段？</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#在组件生命周期中有四个不同的阶段："><span class="nav-text">在组件生命周期中有四个不同的阶段：</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#问题-15：React-的生命周期方法有哪些？"><span class="nav-text">问题 15：React 的生命周期方法有哪些？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#问题-16：这三个点-…-在-React-干嘛用的？"><span class="nav-text">问题 16：这三个点(…)在 React 干嘛用的？</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#在React（使用JSX）代码中做什么？它叫什么？"><span class="nav-text">... 在React（使用JSX）代码中做什么？它叫什么？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#这个叫扩展操作符号或者展开操作符，例如，如果this-props包含a：1和b：2，则"><span class="nav-text">这个叫扩展操作符号或者展开操作符，例如，如果this.props包含a：1和b：2，则</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#等价于下面内容："><span class="nav-text">等价于下面内容：</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#扩展符号不仅适用于该用例，而且对于创建具有现有对象的大多数（或全部）属性的新对象非常方便，在更新state-咱们就经常这么做："><span class="nav-text">扩展符号不仅适用于该用例，而且对于创建具有现有对象的大多数（或全部）属性的新对象非常方便，在更新state 咱们就经常这么做：</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#问题-17：使用-React-Hooks-好处是啥？"><span class="nav-text">问题 17：使用 React Hooks 好处是啥？</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#首先，Hooks-通常支持提取和重用跨多个组件通用的有状态逻辑，而无需承担高阶组件或渲染-props-的负担。Hooks-可以轻松地操作函数组件的状态，而不需要将它们转换为类组件。"><span class="nav-text">首先，Hooks 通常支持提取和重用跨多个组件通用的有状态逻辑，而无需承担高阶组件或渲染 props 的负担。Hooks 可以轻松地操作函数组件的状态，而不需要将它们转换为类组件。</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Hooks-在类中不起作用，通过使用它们，咱们可以完全避免使用生命周期方法，例如-componentDidMount、componentDidUpdate、componentWillUnmount。相反，使用像useEffect这样的内置钩子。"><span class="nav-text">Hooks 在类中不起作用，通过使用它们，咱们可以完全避免使用生命周期方法，例如 componentDidMount、componentDidUpdate、componentWillUnmount。相反，使用像useEffect这样的内置钩子。</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#问题-18：什么是-React-Hooks？"><span class="nav-text">问题 18：什么是 React Hooks？</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Hooks是-React-16-8-中的新添加内容。它们允许在不编写类的情况下使用state和其他-React-特性。使用-Hooks，可以从组件中提取有状态逻辑，这样就可以独立地测试和重用它。Hooks-允许咱们在不改变组件层次结构的情况下重用有状态逻辑，这样在许多组件之间或与社区共享-Hooks-变得很容易。"><span class="nav-text">Hooks是 React 16.8 中的新添加内容。它们允许在不编写类的情况下使用state和其他 React 特性。使用 Hooks，可以从组件中提取有状态逻辑，这样就可以独立地测试和重用它。Hooks 允许咱们在不改变组件层次结构的情况下重用有状态逻辑，这样在许多组件之间或与社区共享 Hooks 变得很容易。</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#问题-19：React-中的-useState-是什么？"><span class="nav-text">问题 19：React 中的 useState() 是什么？</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#下面说明useState-0-的用途："><span class="nav-text">下面说明useState(0)的用途：</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#useState-是一个内置的-React-Hook。useState-0-返回一个元组，其中第一个参数count是计数器的当前状态，setCounter-提供更新计数器状态的方法。"><span class="nav-text">useState 是一个内置的 React Hook。useState(0) 返回一个元组，其中第一个参数count是计数器的当前状态，setCounter 提供更新计数器状态的方法。</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#咱们可以在任何地方使用setCounter方法更新计数状态-在这种情况下，咱们在setCount函数内部使用它可以做更多的事情，使用-Hooks，能够使咱们的代码保持更多功能，还可以避免过多使用基于类的组件。"><span class="nav-text">咱们可以在任何地方使用setCounter方法更新计数状态-在这种情况下，咱们在setCount函数内部使用它可以做更多的事情，使用 Hooks，能够使咱们的代码保持更多功能，还可以避免过多使用基于类的组件。</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#问题-20：React-中的StrictMode-严格模式-是什么？？"><span class="nav-text">问题 20：React 中的StrictMode(严格模式)是什么？？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#问题-21：为什么类方法需要绑定到类实例？"><span class="nav-text">问题 21：为什么类方法需要绑定到类实例？</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#在-JS-中，this-值会根据当前上下文变化。在-React-类组件方法中，开发人员通常希望-this-引用组件的当前实例，因此有必要将这些方法绑定到实例。通常这是在构造函数中完成的"><span class="nav-text">在 JS 中，this 值会根据当前上下文变化。在 React 类组件方法中，开发人员通常希望 this 引用组件的当前实例，因此有必要将这些方法绑定到实例。通常这是在构造函数中完成的:</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#问题-22：什么是-prop-drilling，如何避免？"><span class="nav-text">问题 22：什么是 prop drilling，如何避免？</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#在构建-React-应用程序时，在多层嵌套组件来使用另一个嵌套组件提供的数据。最简单的方法是将一个-prop-从每个组件一层层的传递下去，从源组件传递到深层嵌套组件，这叫做prop-drilling。"><span class="nav-text">在构建 React 应用程序时，在多层嵌套组件来使用另一个嵌套组件提供的数据。最简单的方法是将一个 prop 从每个组件一层层的传递下去，从源组件传递到深层嵌套组件，这叫做prop drilling。</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#prop-drilling的主要缺点是原本不需要数据的组件变得不必要地复杂，并且难以维护。"><span class="nav-text">prop drilling的主要缺点是原本不需要数据的组件变得不必要地复杂，并且难以维护。</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#为了避免prop-drilling，一种常用的方法是使用React-Context。通过定义提供数据的Provider组件，并允许嵌套的组件通过Consumer组件或useContext-Hook-使用上下文数据。"><span class="nav-text">为了避免prop drilling，一种常用的方法是使用React Context。通过定义提供数据的Provider组件，并允许嵌套的组件通过Consumer组件或useContext Hook 使用上下文数据。</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#问题-23：描述-Flux-与-MVC？"><span class="nav-text">问题 23：描述 Flux 与 MVC？</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#传统的-MVC-模式在分离数据-Model-、UI-View和逻辑-Controller-方面工作得很好，但是-MVC-架构经常遇到两个主要问题"><span class="nav-text">传统的 MVC 模式在分离数据(Model)、UI(View和逻辑(Controller)方面工作得很好，但是 MVC 架构经常遇到两个主要问题:</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#使用-Flux-模式的复杂用户界面不再遭受级联更新，任何给定的React-组件都能够根据-store-提供的数据重建其状态。Flux-模式还通过限制对共享数据的直接访问来加强数据完整性。"><span class="nav-text">使用 Flux 模式的复杂用户界面不再遭受级联更新，任何给定的React 组件都能够根据 store 提供的数据重建其状态。Flux 模式还通过限制对共享数据的直接访问来加强数据完整性。</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#问题-24：受控组件和非受控组件区别是啥？"><span class="nav-text">问题 24：受控组件和非受控组件区别是啥？</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#尽管非受控组件通常更易于实现，因为只需使用refs即可从-DOM-中获取值，但通常建议优先选择受控制的组件，而不是非受控制的组件。"><span class="nav-text">尽管非受控组件通常更易于实现，因为只需使用refs即可从 DOM 中获取值，但通常建议优先选择受控制的组件，而不是非受控制的组件。</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#这样做的主要原因是受控组件支持即时字段验证，允许有条件地禁用-启用按钮，强制输入格式。"><span class="nav-text">这样做的主要原因是受控组件支持即时字段验证，允许有条件地禁用/启用按钮，强制输入格式。</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#问题-25：这段代码有什么问题吗？"><span class="nav-text">问题 25：这段代码有什么问题吗？</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#没有什么问题。这种方式很少被使用，咱们可以将一个函数传递给setState，该函数接收上一个-state-的值和当前的props，并返回一个新的状态，如果咱们需要根据以前的状态重新设置状态，推荐使用这种方式。"><span class="nav-text">没有什么问题。这种方式很少被使用，咱们可以将一个函数传递给setState，该函数接收上一个 state 的值和当前的props，并返回一个新的状态，如果咱们需要根据以前的状态重新设置状态，推荐使用这种方式。</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#问题-26：什么是-React-Context"><span class="nav-text">问题 26：什么是 React Context?</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Context-通过组件树提供了一个传递数据的方法，从而避免了在每一个层级手动的传递-props-属性。"><span class="nav-text">Context 通过组件树提供了一个传递数据的方法，从而避免了在每一个层级手动的传递 props 属性。</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#问题-27：什么是-React-Fiber"><span class="nav-text">问题 27：什么是 React Fiber?</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Fiber-是-React-16-中新的协调引擎或重新实现核心算法。它的主要目标是支持虚拟DOM的增量渲染。React-Fiber-的目标是提高其在动画、布局、手势、暂停、中止或重用等方面的适用性，并为不同类型的更新分配优先级，以及新的并发原语。"><span class="nav-text">Fiber 是 React 16 中新的协调引擎或重新实现核心算法。它的主要目标是支持虚拟DOM的增量渲染。React Fiber 的目标是提高其在动画、布局、手势、暂停、中止或重用等方面的适用性，并为不同类型的更新分配优先级，以及新的并发原语。</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#React-Fiber-的目标是增强其在动画、布局和手势等领域的适用性。它的主要特性是增量渲染-能够将渲染工作分割成块，并将其分散到多个帧中。"><span class="nav-text">React Fiber 的目标是增强其在动画、布局和手势等领域的适用性。它的主要特性是增量渲染:能够将渲染工作分割成块，并将其分散到多个帧中。</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#问题-28：如何在-ReactJS-的-Props上应用验证？"><span class="nav-text">问题 28：如何在 ReactJS 的 Props上应用验证？</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#当应用程序在开发模式下运行时，React-将自动检查咱们在组件上设置的所有-props，以确保它们具有正确的数据类型。对于不正确的类型，开发模式下会在控制台中生成警告消息，而在生产模式中由于性能影响而禁用它。强制的-props-用-isRequired定义的。"><span class="nav-text">当应用程序在开发模式下运行时，React 将自动检查咱们在组件上设置的所有 props，以确保它们具有正确的数据类型。对于不正确的类型，开发模式下会在控制台中生成警告消息，而在生产模式中由于性能影响而禁用它。强制的 props 用 isRequired定义的。</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#问题-29：在-React-中使用构造函数和-getInitialState-有什么区别？"><span class="nav-text">问题 29：在 React 中使用构造函数和 getInitialState 有什么区别？</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#构造函数和getInitialState之间的区别就是ES6和ES5本身的区别。在使用ES6类时，应该在构造函数中初始化state，并在使用React-createClass时定义getInitialState方法。"><span class="nav-text">构造函数和getInitialState之间的区别就是ES6和ES5本身的区别。在使用ES6类时，应该在构造函数中初始化state，并在使用React.createClass时定义getInitialState方法。</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#问题-30：如何有条件地向-React-组件添加属性？"><span class="nav-text">问题 30：如何有条件地向 React 组件添加属性？</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#对于某些属性，React-非常聪明，如果传递给它的值是虚值，可以省略该属性。例如："><span class="nav-text">对于某些属性，React 非常聪明，如果传递给它的值是虚值，可以省略该属性。例如：</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#问题-31：Hooks会取代-render-props-和高阶组件吗？"><span class="nav-text">问题 31：Hooks会取代 render props 和高阶组件吗？</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#通常，render-props和高阶组件仅渲染一个子组件。React团队认为，Hooks-是服务此用例的更简单方法。"><span class="nav-text">通常，render props和高阶组件仅渲染一个子组件。React团队认为，Hooks 是服务此用例的更简单方法。</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#这两种模式仍然有一席之地-例如，一个虚拟的-scroller-组件可能有一个-renderItem-prop，或者一个可视化的容器组件可能有它自己的-DOM-结构-。但在大多数情况下，Hooks-就足够了，可以帮助减少树中的嵌套。"><span class="nav-text">这两种模式仍然有一席之地(例如，一个虚拟的 scroller 组件可能有一个 renderItem prop，或者一个可视化的容器组件可能有它自己的 DOM 结构)。但在大多数情况下，Hooks 就足够了，可以帮助减少树中的嵌套。</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#问题-32：如何避免组件的重新渲染？"><span class="nav-text">问题 32：如何避免组件的重新渲染？</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#这两种方法都依赖于对传递给组件的props的浅比较，如果-props-没有改变，那么组件将不会重新渲染。虽然这两种工具都非常有用，但是浅比较会带来额外的性能损失，因此如果使用不当，这两种方法都会对性能产生负面影响。"><span class="nav-text">这两种方法都依赖于对传递给组件的props的浅比较，如果 props 没有改变，那么组件将不会重新渲染。虽然这两种工具都非常有用，但是浅比较会带来额外的性能损失，因此如果使用不当，这两种方法都会对性能产生负面影响。</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#通过使用-React-Profiler，可以在使用这些方法前后对性能进行测量，从而确保通过进行给定的更改来实际改进性能。"><span class="nav-text">通过使用 React Profiler，可以在使用这些方法前后对性能进行测量，从而确保通过进行给定的更改来实际改进性能。</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#问题-33：什么是纯函数？"><span class="nav-text">问题 33：什么是纯函数？</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#纯函数是不依赖并且不会在其作用域之外修改变量状态的函数。本质上，纯函数始终在给定相同参数的情况下返回相同结果。"><span class="nav-text">纯函数是不依赖并且不会在其作用域之外修改变量状态的函数。本质上，纯函数始终在给定相同参数的情况下返回相同结果。</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#问题-34：当调用setState时，React-render-是如何工作的？"><span class="nav-text">问题 34：当调用setState时，React render 是如何工作的？</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#咱们可以将”render“分为两个步骤："><span class="nav-text">咱们可以将”render“分为两个步骤：</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#虚拟-DOM-渲染-当render方法被调用时，它返回一个新的组件的虚拟-DOM-结构。当调用setState-时，render会被再次调用，因为默认情况下shouldComponentUpdate总是返回true，所以默认情况下-React-是没有优化的。"><span class="nav-text">虚拟 DOM 渲染:当render方法被调用时，它返回一个新的组件的虚拟 DOM 结构。当调用setState()时，render会被再次调用，因为默认情况下shouldComponentUpdate总是返回true，所以默认情况下 React 是没有优化的。</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#原生-DOM-渲染-React-只会在虚拟DOM中修改真实DOM节点，而且修改的次数非常少——这是很棒的React特性，它优化了真实DOM的变化，使React变得更快。"><span class="nav-text">原生 DOM 渲染:React 只会在虚拟DOM中修改真实DOM节点，而且修改的次数非常少——这是很棒的React特性，它优化了真实DOM的变化，使React变得更快。</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#问题-35：如何避免在React重新绑定实例？"><span class="nav-text">问题 35：如何避免在React重新绑定实例？</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#有几种常用方法可以避免在-React-中绑定方法："><span class="nav-text">有几种常用方法可以避免在 React 中绑定方法：</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#1-将事件处理程序定义为内联箭头函数"><span class="nav-text">1.将事件处理程序定义为内联箭头函数</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2-使用箭头函数来定义方法："><span class="nav-text">2.使用箭头函数来定义方法：</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#3-使用带有-Hooks-的函数组件"><span class="nav-text">3.使用带有 Hooks 的函数组件</span></a></li></ol></li></ol></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Hson zhou"
      src="/images/zhouavtor.jpeg">
  <p class="site-author-name" itemprop="name">Hson zhou</p>
  <div class="site-description" itemprop="description">Try to be a better self</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">10</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">15</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/hsonzhou95" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;hsonzhou95" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://weibo.com/u/5493344233/home?wvr=5" title="微博 → https:&#x2F;&#x2F;weibo.com&#x2F;u&#x2F;5493344233&#x2F;home?wvr=5" rel="noopener" target="_blank"><i class="fa fa-fw fa-weibo"></i>微博</a>
      </span>
      <span class="links-of-author-item">
        <a href="/mailto:zhouxiaobin9c@163.com" title="E-Mail → mailto:zhouxiaobin9c@163.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="/atom.xml" title="RSS → &#x2F;atom.xml"><i class="fa fa-fw fa-rss"></i>RSS</a>
      </span>
  </div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/zh-CN" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>



      </div>
      <div>
        
        <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=29378196&auto=1&height=66"></iframe>
        
      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        
<div>
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<span id="busuanzi_container_site_pv" style='display:none'>
    本站总访问量 <span id="busuanzi_value_site_pv"></span> 次
    <span class="post-meta-divider">|</span>
</span>
<span id="busuanzi_container_site_uv" style='display:none'>
    有<span id="busuanzi_value_site_uv"></span>人看过我的博客啦
</span>
</div>
<div class="copyright">
  
  &copy; 2017 – 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Hson zhou</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
      <span class="post-meta-item-text">站点总字数：</span>
    <span title="站点总字数">81k</span>
</div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








        
      </div>
    </footer>
  </div>

  
  
  <script color='0,0,0' opacity='0.5' zIndex='-1' count='150' src="/lib/canvas-nest/canvas-nest.min.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script>
<script src="/js/schemes/pisces.js"></script>
<script src="/js/next-boot.js"></script>



  




  <script src="/js/local-search.js"></script>













  

  

</body>
</html>
<script type="text/javascript" src="/js/src/clicklove.js"></script>

